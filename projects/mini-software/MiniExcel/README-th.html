<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniExcel - เครื่องมือช่วย Excel .NET ที่รวดเร็ว ใช้หน่วยความจำน้อย ใช้งานง่าย สำหรับนำเข้า/ส่งออก/สร้างเทมเพลตสเปรดชีต (รองรับ Linux, Mac)</title>
    <meta name="description" content="เครื่องมือช่วย Excel .NET ที่รวดเร็ว ใช้หน่วยความจำน้อย ใช้งานง่าย สำหรับนำเข้า/ส่งออก/สร้างเทมเพลตสเปรดชีต (รองรับ Linux, Mac)">
    <meta name="keywords" content="MiniExcel, Thai, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MiniExcel",
  "description": "เครื่องมือช่วย Excel .NET ที่รวดเร็ว ใช้หน่วยความจำน้อย ใช้งานง่าย สำหรับนำเข้า/ส่งออก/สร้างเทมเพลตสเปรดชีต (รองรับ Linux, Mac)",
  "author": {
    "@type": "Person",
    "name": "mini-software"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3234
  },
  "url": "https://OpenAiTx.github.io/projects/mini-software/MiniExcel/README-th.html",
  "sameAs": "https://raw.githubusercontent.com/mini-software/MiniExcel/master/README.md",
  "datePublished": "2025-10-09",
  "dateModified": "2025-10-09"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/mini-software/MiniExcel" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MiniExcel
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3234 stars</span>
                <span class="language">Thai</span>
                <span>by mini-software</span>
            </div>
        </div>
        
        <div class="content">
            <p><div align="center">
<p><a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/v/MiniExcel.svg" alt="NuGet"></a>  <a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/dt/MiniExcel.svg" alt=""></a>
<a href="https://ci.appveyor.com/project/mini-software/miniexcel/branch/master"><img src="https://ci.appveyor.com/api/projects/status/b2vustrwsuqx45f4/branch/master?svg=true" alt="Build status"></a>
<a href="https://gitee.com/dotnetchina/MiniExcel"><img src="https://gitee.com/dotnetchina/MiniExcel/badge/star.svg" alt="star"></a> <a href="https://github.com/mini-software/MiniExcel" rel="nofollow"><img src="https://img.shields.io/github/stars/mini-software/MiniExcel?logo=github" alt="GitHub stars"></a>
<a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/badge/.NET-%3E%3D%204.5-red.svg" alt="version"></a>
<a href="https://deepwiki.com/mini-software/MiniExcel"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
</p>
</div></p><hr></p><p><a href="https://www.dotnetfoundation.org/" target="_blank" rel="noopener noreferrer"><img align="right" src="https://github.com/dotnet-foundation/swag/blob/main/logo/dotnetfoundation_v4.png?raw=true" width="100" /></a></p><p><div align="center">
<p>โปรเจ็กต์นี้เป็นส่วนหนึ่งของ <a href="https://www.dotnetfoundation.org/">.NET Foundation</a> และดำเนินงานภายใต้ <a href="https://www.dotnetfoundation.org/code-of-conduct">จรรยาบรรณ</a> ของพวกเขา </p>
</div></p><hr></p><p><div align="center">
<p><strong><a href="README.md">English</a> | <a href="README.zh-CN.md">简体中文</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=zh-TW">繁體中文</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=ja">日本語</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=ko">한국어</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=hi">हिन्दी</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=th">ไทย</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=fr">Français</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=de">Deutsch</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=es">Español</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=it">Italiano</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=ru">Русский</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=pt">Português</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=nl">Nederlands</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=pl">Polski</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=ar">العربية</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=fa">فارسی</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=tr">Türkçe</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=vi">Tiếng Việt</a> | <a href="https://openaitx.github.io/view.html?user=mini-software&amp;project=MiniExcel&amp;lang=id">Bahasa Indonesia</a>
</strong></p>
</div></p><hr></p><p><div align="center">
 การให้<a href="https://github.com/mini-software/MiniExcel">ดาว</a> หรือ <a href="https://miniexcel.github.io">บริจาค</a>ของคุณสามารถทำให้ MiniExcel ดียิ่งขึ้น
</div></p><hr></p><h3>บทนำ</h3></p><p>MiniExcel เป็นเครื่องมือจัดการ Excel ที่เรียบง่ายและมีประสิทธิภาพสำหรับ .NET โดยออกแบบมาเพื่อลดการใช้หน่วยความจำให้เหลือน้อยที่สุด</p><p>ปัจจุบัน เฟรมเวิร์กยอดนิยมส่วนใหญ่ต้องโหลดข้อมูลทั้งหมดจากเอกสาร Excel เข้าสู่หน่วยความจำเพื่อให้ง่ายต่อการดำเนินการ แต่สิ่งนี้อาจทำให้เกิดปัญหาการใช้หน่วยความจำสูง วิธีการของ MiniExcel แตกต่างออกไป: ข้อมูลจะถูกประมวลผลทีละแถวในรูปแบบสตรีมมิ่ง ลดการใช้หน่วยความจำจากเดิมที่อาจสูงถึงหลักร้อยเมกะไบต์ให้เหลือเพียงไม่กี่เมกะไบต์ และช่วยป้องกันปัญหาหน่วยความจำไม่พอ (OOM) ได้อย่างมีประสิทธิภาพ</p><pre><code class="language-mermaid">flowchart LR
    A1(["Excel analysis<br>process"]) --> A2{{"Unzipping<br>XLSX file"}} --> A3{{"Parsing<br>OpenXML"}} --> A4{{"Model<br>conversion"}} --> A5(["Output"])</p><p>    B1(["Other Excel<br>Frameworks"]) --> B2{{"Memory"}} --> B3{{"Memory"}} --> B4{{"Workbooks &<br>Worksheets"}} --> B5(["All rows at<br>the same time"])</p><p>    C1(["MiniExcel"]) --> C2{{"Stream"}} --> C3{{"Stream"}} --> C4{{"POCO or dynamic"}} --> C5(["Deferred execution<br>row by row"])</p><p>    classDef analysis fill:#D0E8FF,stroke:#1E88E5,color:#0D47A1,font-weight:bold;
    classDef others fill:#FCE4EC,stroke:#EC407A,color:#880E4F,font-weight:bold;
    classDef miniexcel fill:#E8F5E9,stroke:#388E3C,color:#1B5E20,font-weight:bold;</p><p>    class A1,A2,A3,A4,A5 analysis;
    class B1,B2,B3,B4,B5 others;
    class C1,C2,C3,C4,C5 miniexcel;</code></pre></p><h3>คุณสมบัติ</h3></p><ul><li>ลดการใช้หน่วยความจำ ป้องกันข้อผิดพลาดหน่วยความจำหมด (OOM) และหลีกเลี่ยงการเก็บขยะ (garbage collection) เต็มรูปแบบ</li>
<li>รองรับการดำเนินการข้อมูลระดับแถวแบบเรียลไทม์ เพื่อประสิทธิภาพที่ดีกว่าในชุดข้อมูลขนาดใหญ่</li>
<li>รองรับ LINQ ด้วยการดำเนินการแบบเลื่อนเวลา (deferred execution) ทำให้สามารถแบ่งหน้าและคิวรีที่ซับซ้อนได้อย่างรวดเร็วและใช้หน่วยความจำน้อย</li>
<li>น้ำหนักเบา ไม่ต้องใช้ Microsoft Office หรือคอมโพเนนต์ COM+ และไฟล์ DLL มีขนาดไม่เกิน 500KB</li>
<li>API ใช้งานง่ายและเข้าใจได้สะดวกสำหรับการอ่าน/เขียน/เติมข้อมูล excel</li></p><p></ul><h3>เวอร์ชัน 2.0 พรีวิว</h3></p><p>เรากำลังพัฒนา MiniExcel เวอร์ชันใหม่ โดยมี API ที่แยกโมดูลและโฟกัสมากขึ้น, 
มีแพ็กเกจ NuGet แยกสำหรับ Core และฟังก์ชัน Csv, รองรับการสตรีมคิวรีแบบอะซิงโครนัสเต็มรูปแบบผ่าน <code>IAsyncEnumerable</code>,
และฟีเจอร์อื่น ๆ อีกมากมายที่กำลังจะตามมา! แพ็กเกจเหล่านี้จะมีให้ใช้งานในสถานะ pre-release คุณสามารถทดลองใช้และให้ข้อเสนอแนะกับเราได้!</p><p>หากคุณสนใจ กรุณาตรวจสอบ <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/README-V2.md" target="_blank" rel="noopener noreferrer">เอกสารใหม่</a> และ <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/V2-Upgrade-Notes.md" target="_blank" rel="noopener noreferrer">บันทึกการอัปเกรด</a> ด้วยเช่นกัน</p><h3>เริ่มต้นใช้งาน</h3></p><ul><li><a href="#getstart1" target="_blank" rel="noopener noreferrer">นำเข้า/คิวรี Excel</a></li></p><p><li><a href="#getstart2" target="_blank" rel="noopener noreferrer">ส่งออก/สร้าง Excel</a></li></p><p><li><a href="#getstart3" target="_blank" rel="noopener noreferrer">เทมเพลต Excel</a></li></p><p><li><a href="#getstart4" target="_blank" rel="noopener noreferrer">ชื่อคอลัมน์/ดัชนี/แอตทริบิวต์ Ignore ใน Excel</a></li></p><p><li><a href="#getstart5" target="_blank" rel="noopener noreferrer">ตัวอย่าง</a></li></p><p>
</ul><h3>การติดตั้ง</h3></p><p>คุณสามารถติดตั้งแพ็กเกจ <a href="https://www.nuget.org/packages/MiniExcel" target="_blank" rel="noopener noreferrer">จาก NuGet</a></p><h3>หมายเหตุการอัปเดตเวอร์ชัน</h3></p><p>กรุณาตรวจสอบ <a href="docs" target="_blank" rel="noopener noreferrer">Release Notes</a></p><h3>สิ่งที่ต้องทำ</h3></p><p>โปรดตรวจสอบ <a href="https://github.com/mini-software/MiniExcel/projects/1?fullscreen=true" target="_blank" rel="noopener noreferrer">TODO</a></p><h3>ประสิทธิภาพ</h3></p><p>โค้ดสำหรับการทดสอบประสิทธิภาพสามารถดูได้ที่ <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/benchmarks/MiniExcel.Benchmarks/Program.cs" target="_blank" rel="noopener noreferrer">MiniExcel.Benchmarks</a></p><p>ไฟล์ที่ใช้ในการทดสอบประสิทธิภาพคือ <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/benchmarks/MiniExcel.Benchmarks/Test1%2C000%2C000x10.xlsx" target="_blank" rel="noopener noreferrer"><strong>Test1,000,000x10.xlsx</strong></a> ซึ่งเป็นเอกสารขนาด 32MB ที่มี 1,000,000 แถว * 10 คอลัมน์ โดยแต่ละเซลล์จะถูกเติมด้วยสตริง "HelloWorld"</p><p>เพื่อเรียกใช้งานการทดสอบประสิทธิภาพทั้งหมด ให้ใช้:</p><pre><code class="language-bash">dotnet run -project .\benchmarks\MiniExcel.Benchmarks -c Release -f net9.0 -filter * --join</code></pre>
คุณสามารถดูผลลัพธ์ของการทดสอบประสิทธิภาพสำหรับรุ่นล่าสุดได้ <a href="benchmarks/results" target="_blank" rel="noopener noreferrer">ที่นี่</a></p><h3>การดึงข้อมูล/นำเข้า Excel  <a name="getstart1"></a></h3></p><p>#### 1. รันคำสั่ง query และแมปผลลัพธ์ไปยัง IEnumerable ที่มีชนิดข้อมูลแบบเจาะจง [[ลองใช้ดู]](https://dotnetfiddle.net/w5WD1J)</p><p>แนะนำให้ใช้ Stream.Query เนื่องจากมีประสิทธิภาพที่ดีกว่า</p><pre><code class="language-csharp">public class UserAccount
{
    public Guid ID { get; set; }
    public string Name { get; set; }
    public DateTime BoD { get; set; }
    public int Age { get; set; }
    public bool VIP { get; set; }
    public decimal Points { get; set; }
}</p><p>var rows = MiniExcel.Query<UserAccount>(path);</p><p>// or</p><p>using (var stream = File.OpenRead(path))
    var rows = stream.Query<UserAccount>();</code></pre>
<img src="https://user-images.githubusercontent.com/12729184/111107423-c8c46b80-8591-11eb-982f-c97a2dafb379.png" alt="image"></p><p>#### 2. รันคำสั่งค้นหาและแมปผลลัพธ์ไปยังลิสต์ของอ็อบเจกต์แบบไดนามิกโดยไม่ใช้ head [[ลองเลย]](https://dotnetfiddle.net/w5WD1J)</p><ul><li>คีย์ไดนามิกคือ <code>A.B.C.D..</code></li></p><p></ul>| MiniExcel | 1 |
|-----------|---|
| Github    | 2 |</p><pre><code class="language-csharp">
var rows = MiniExcel.Query(path).ToList();</p><p>// or
using (var stream = File.OpenRead(path))
{
    var rows = stream.Query().ToList();</p><p>    Assert.Equal("MiniExcel", rows[0].A);
    Assert.Equal(1, rows[0].B);
    Assert.Equal("Github", rows[1].A);
    Assert.Equal(2, rows[1].B);
}</code></pre>
#### 3. รันคำสั่งค้นหาพร้อมแถวหัวข้อแรก [[ลองใช้งาน]](https://dotnetfiddle.net/w5WD1J)</p><p>หมายเหตุ : ถ้าชื่อคอลัมน์ซ้ำกัน จะใช้ชื่อด้านขวาสุด</p><p>ไฟล์ Excel ตัวอย่าง :</p><p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p><pre><code class="language-csharp">
var rows = MiniExcel.Query(useHeaderRow:true).ToList();</p><p>// or</p><p>using (var stream = File.OpenRead(path))
{
    var rows = stream.Query(useHeaderRow:true).ToList();</p><p>    Assert.Equal("MiniExcel", rows[0].Column1);
    Assert.Equal(1, rows[0].Column2);
    Assert.Equal("Github", rows[1].Column1);
    Assert.Equal(2, rows[1].Column2);
}</code></pre>
#### 4. รองรับการสืบค้นด้วย LINQ Extension เช่น First/Take/Skip ...ฯลฯ</p><p>สืบค้นรายการแรก</p><pre><code class="language-csharp">var row = MiniExcel.Query(path).First();
Assert.Equal("HelloWorld", row.A);</p><p>// or</p><p>using (var stream = File.OpenRead(path))
{
    var row = stream.Query().First();
    Assert.Equal("HelloWorld", row.A);
}</code></pre>
ประสิทธิภาพระหว่าง MiniExcel/ExcelDataReader/ClosedXML/EPPlus
<img src="https://user-images.githubusercontent.com/12729184/111072392-6037a900-8515-11eb-9693-5ce2dad1e460.gif" alt="queryfirst"></p><p>#### 5. สืบค้นโดยชื่อชีต</p><pre><code class="language-csharp">MiniExcel.Query(path, sheetName: "SheetName");
//or
stream.Query(sheetName: "SheetName");</code></pre>
#### 6. คิวรีชื่อชีตและแถวทั้งหมด</p><pre><code class="language-csharp">var sheetNames = MiniExcel.GetSheetNames(path);
foreach (var sheetName in sheetNames)
{
    var rows = MiniExcel.Query(path, sheetName: sheetName);
}</code></pre>
#### 7. รับคอลัมน์</p><pre><code class="language-csharp">var columns = MiniExcel.GetColumns(path); // e.g result : ["A","B"...]</p><p>var cnt = columns.Count;  // get column count</code></pre>
#### 8. การคิวรีแบบไดนามิกแปลงแถวเป็น <code>IDictionary<string,object></code></p><pre><code class="language-csharp">foreach(IDictionary<string,object> row in MiniExcel.Query(path))
{
    //..
}</p><p>// or
var rows = MiniExcel.Query(path).Cast<IDictionary<string,object>>();
// or Query specified ranges (capitalized)
// A2 represents the second row of column A, C3 represents the third row of column C
// If you don't want to restrict rows, just don't include numbers
var rows = MiniExcel.QueryRange(path, startCell: "A2", endCell: "C3").Cast<IDictionary<string, object>>();</code></pre></p><p>
#### 9. การใช้ Query Excel เพื่อคืนค่า DataTable</p><p>ไม่แนะนำ เนื่องจาก DataTable จะโหลดข้อมูลทั้งหมดเข้าสู่หน่วยความจำและทำให้สูญเสียคุณสมบัติการใช้หน่วยความจำต่ำของ MiniExcel</p><p>
``<code>C#
var table = MiniExcel.QueryAsDataTable(path, useHeaderRow: true);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/116673475-07917200-a9d6-11eb-947e-a6f68cce58df.png" alt="image"></p><p>#### 10. ระบุเซลล์ที่จะเริ่มต้นอ่านข้อมูล</p><p></code></pre>csharp
MiniExcel.Query(path,useHeaderRow:true,startCell:"B3")
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/117260316-8593c400-ae81-11eb-9877-c087b7ac2b01.png" alt="image"></p><p>#### 11. เติมค่าลงในเซลล์ที่ถูกรวม</p><p>หมายเหตุ: ประสิทธิภาพจะช้ากว่าการ </code>ไม่ใช้การเติมค่าลงในเซลล์ที่ถูกรวม<code></p><p>เหตุผล: มาตรฐาน OpenXml จะวาง mergeCells ไว้ที่ส่วนล่างของไฟล์ ทำให้จำเป็นต้องวนลูป foreach sheetxml สองรอบ</p><p></code></pre>csharp
    var config = new OpenXmlConfiguration()
    {
        FillMergedCells = true
    };
    var rows = MiniExcel.Query(path, configuration: config);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/117973630-3527d500-b35f-11eb-95c3-bde255f8114e.png" alt="image"></p><p>รองรับการเติมข้อมูลหลายแถวและหลายคอลัมน์ที่มีความยาวและความกว้างแบบแปรผัน</p><p><img src="https://user-images.githubusercontent.com/12729184/117973820-6d2f1800-b35f-11eb-88d8-555063938108.png" alt="image"></p><p>#### 12. การอ่านไฟล์ขนาดใหญ่โดยใช้แคชบนดิสก์ (Disk-Base Cache - SharedString)</p><p>หากขนาดของ SharedStrings เกิน 5 MB MiniExcel โดยค่าเริ่มต้นจะใช้แคชบนดิสก์ภายในเครื่อง เช่น <a href="https://github.com/MiniExcel/MiniExcel/files/8403819/NotDuplicateSharedStrings_10x100000.xlsx" target="_blank" rel="noopener noreferrer">10x100000.xlsx</a> (ข้อมูลหนึ่งล้านแถว) เมื่อปิดการใช้แคชบนดิสก์จะใช้หน่วยความจำสูงสุด 195MB แต่เมื่อเปิดแคชบนดิสก์จะใช้เพียง 65MB โปรดทราบว่าการเพิ่มประสิทธิภาพนี้จะมีค่าใช้จ่ายด้านประสิทธิภาพ ดังนั้นกรณีนี้จะทำให้เวลาอ่านเพิ่มจาก 7.4 วินาทีเป็น 27.2 วินาที หากคุณไม่ต้องการใช้งานนี้สามารถปิดแคชบนดิสก์ได้ด้วยโค้ดดังต่อไปนี้:</p><p></code></pre>csharp
var config = new OpenXmlConfiguration { EnableSharedStringCache = false };
MiniExcel.Query(path,configuration: config)
<pre><code class="language-">คุณสามารถใช้ </code>SharedStringCacheSize<code> เพื่อเปลี่ยนขนาดไฟล์ sharedString ให้เกินขนาดที่กำหนดสำหรับการแคชลงดิสก์
</code></pre>csharp
var config = new OpenXmlConfiguration { SharedStringCacheSize=500<em>1024</em>1024 };
MiniExcel.Query(path, configuration: config);
<pre><code class="language-"></p><p>
<img src="https://user-images.githubusercontent.com/12729184/161411851-1c3f72a7-33b3-4944-84dc-ffc1d16747dd.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/12729184/161411825-17f53ec7-bef4-4b16-b234-e24799ea41b0.png" alt="image"></p><h3>สร้าง/ส่งออก Excel  <a name="getstart2"></a></h3></p><ul><li>ต้องเป็นชนิดที่ไม่ใช่ abstract และมี constructor สาธารณะที่ไม่มีพารามิเตอร์</li></p><p><li>MiniExcel รองรับ IEnumerable Deferred Execution หากคุณต้องการใช้หน่วยความจำน้อยที่สุด กรุณาอย่าเรียกใช้เมธอด เช่น ToList</li></p><p></ul>ตัวอย่าง : ToList หรือไม่ใช้หน่วยความจำ
<img src="https://user-images.githubusercontent.com/12729184/112587389-752b0b00-8e38-11eb-8a52-cfb76c57e5eb.png" alt="image"></p><p>#### 1. Anonymous หรือ strongly type [[ลองใช้งาน]](https://dotnetfiddle.net/w5WD1J)</p><p></code></pre>csharp
var path = Path.Combine(Path.GetTempPath(), $"{Guid.NewGuid()}.xlsx");
MiniExcel.SaveAs(path, new[] {
    new { Column1 = "MiniExcel", Column2 = 1 },
    new { Column1 = "Github", Column2 = 2}
});
<pre><code class="language-">#### 2. </code>IEnumerable<IDictionary<string, object>><code></p><p></code></pre>csharp
var values = new List<Dictionary<string, object>>()
{
    new Dictionary<string,object>{{ "Column1", "MiniExcel" }, { "Column2", 1 } },
    new Dictionary<string,object>{{ "Column1", "Github" }, { "Column2", 2 } }
};
MiniExcel.SaveAs(path, values);
<pre><code class="language-">สร้างผลลัพธ์ไฟล์ :</p><p>| คอลัมน์1    | คอลัมน์2 |
|-------------|-----------|
| MiniExcel   | 1         |
| Github      | 2         |</p><p>
#### 3.  IDataReader
<ul><li></code>แนะนำ<code>, สามารถหลีกเลี่ยงการโหลดข้อมูลทั้งหมดเข้าสู่หน่วยความจำ</li>
</ul></code></pre>csharp
MiniExcel.SaveAs(path, reader);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/121275378-149a5e80-c8bc-11eb-85fe-5453552134f0.png" alt="image"></p><p>DataReader ส่งออกหลายชีต (แนะนำโดย Dapper ExecuteReader)</p><p></code></pre>csharp
using (var cnn = Connection)
{
    cnn.Open();
    var sheets = new Dictionary<string,object>();
    sheets.Add("sheet1", cnn.ExecuteReader("select 1 id"));
    sheets.Add("sheet2", cnn.ExecuteReader("select 2 id"));
    MiniExcel.SaveAs("Demo.xlsx", sheets);
}
<pre><code class="language-"></p><p>#### 4. Datatable</p><ul><li></code>ไม่แนะนำ<code> เนื่องจากจะโหลดข้อมูลทั้งหมดเข้าหน่วยความจำ</li></p><p><li>DataTable ใช้ Caption เป็นชื่อคอลัมน์ก่อน จากนั้นจึงใช้ columname</li></p><p></ul></code></pre>csharp
var path = Path.Combine(Path.GetTempPath(), $"{Guid.NewGuid()}.xlsx");
var table = new DataTable();
{
    table.Columns.Add("Column1", typeof(string));
    table.Columns.Add("Column2", typeof(decimal));
    table.Rows.Add("MiniExcel", 1);
    table.Rows.Add("Github", 2);
}</p><p>MiniExcel.SaveAs(path, table);
<pre><code class="language-">####  5. Dapper Query</p><p>ขอบคุณ @shaofing #552 กรุณาใช้ </code>CommandDefinition + CommandFlags.NoCache<code></p><p></code></pre>csharp
using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(
        new CommandDefinition(
            @"select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2"
            , flags: CommandFlags.NoCache)
        );
    // Note: QueryAsync will throw close connection exception
    MiniExcel.SaveAs(path, rows);
}
<pre><code class="language-">โค้ดด้านล่างนี้จะโหลดข้อมูลทั้งหมดเข้าไปในหน่วยความจำ</p><p></code></pre>csharp
using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(@"select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2");
    MiniExcel.SaveAs(path, rows);
}
<pre><code class="language-">#### 6. SaveAs ไปยัง MemoryStream  [[ลองใช้งาน]](https://dotnetfiddle.net/JOen0e)</p><p>
</code></pre>csharp
using (var stream = new MemoryStream()) //support FileStream,MemoryStream ect.
{
    stream.SaveAs(values);
}
<pre><code class="language-">ตัวอย่าง: API สำหรับส่งออก Excel</p><p></code></pre>csharp
public IActionResult DownloadExcel()
{
    var values = new[] {
        new { Column1 = "MiniExcel", Column2 = 1 },
        new { Column1 = "Github", Column2 = 2}
    };</p><p>    var memoryStream = new MemoryStream();
    memoryStream.SaveAs(values);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    {
        FileDownloadName = "demo.xlsx"
    };
}
<pre><code class="language-">#### 7. สร้างชีทหลายแผ่น</p><p>
</code></pre>csharp
// 1. Dictionary<string,object>
var users = new[] { new { Name = "Jack", Age = 25 }, new { Name = "Mike", Age = 44 } };
var department = new[] { new { ID = "01", Name = "HR" }, new { ID = "02", Name = "IT" } };
var sheets = new Dictionary<string, object>
{
    ["users"] = users,
    ["department"] = department
};
MiniExcel.SaveAs(path, sheets);</p><p>// 2. DataSet
var sheets = new DataSet();
sheets.Add(UsersDataTable);
sheets.Add(DepartmentDataTable);
//..
MiniExcel.SaveAs(path, sheets);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/118130875-6e7c4580-b430-11eb-9b82-22f02716bd63.png" alt="image"></p><p>
#### 8. ตัวเลือก TableStyles</p><p>สไตล์เริ่มต้น</p><p><img src="https://user-images.githubusercontent.com/12729184/138234373-cfa97109-b71f-4711-b7f5-0eaaa4a0a3a6.png" alt="image"></p><p>โดยไม่มีการกำหนดค่าสไตล์</p><p></code></pre>csharp
var config = new OpenXmlConfiguration()
{
     TableStyles = TableStyles.None
};
MiniExcel.SaveAs(path, value,configuration:config);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/118784917-f3e57700-b8c2-11eb-8718-8d955b1bc197.png" alt="image"></p><p>
#### 9. AutoFilter</p><p>ตั้งแต่ v0.19.0  </code>OpenXmlConfiguration.AutoFilter<code> สามารถเปิด/ปิดใช้งาน AutoFilter ได้ โดยค่าเริ่มต้นคือ </code>true<code> และวิธีการตั้งค่า AutoFilter มีดังนี้:</p><p></code></pre>csharp
MiniExcel.SaveAs(path, value, configuration: new OpenXmlConfiguration() { AutoFilter = false });
<pre><code class="language-"></p><p>#### 10. สร้างภาพ</p><p></code></pre>csharp
var value = new[] {
    new { Name="github",Image=File.ReadAllBytes(PathHelper.GetFile("images/github_logo.png"))},
    new { Name="google",Image=File.ReadAllBytes(PathHelper.GetFile("images/google_logo.png"))},
    new { Name="microsoft",Image=File.ReadAllBytes(PathHelper.GetFile("images/microsoft_logo.png"))},
    new { Name="reddit",Image=File.ReadAllBytes(PathHelper.GetFile("images/reddit_logo.png"))},
    new { Name="statck_overflow",Image=File.ReadAllBytes(PathHelper.GetFile("images/statck_overflow_logo.png"))},
};
MiniExcel.SaveAs(path, value);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/150462383-ad9931b3-ed8d-4221-a1d6-66f799743433.png" alt="image"></p><p>#### 11. การส่งออกไฟล์เป็น Byte Array</p><p>ตั้งแต่เวอร์ชัน 1.22.0 เมื่อชนิดข้อมูลเป็น </code>byte[]<code> ระบบจะบันทึกเส้นทางไฟล์ในเซลล์โดยอัตโนมัติ และเมื่อทำการนำเข้า ระบบจะสามารถแปลงกลับเป็น </code>byte[]<code> ได้ และหากคุณไม่ต้องการใช้ฟีเจอร์นี้ คุณสามารถตั้งค่า </code>OpenXmlConfiguration.EnableConvertByteArray<code> เป็น </code>false<code> เพื่อปรับปรุงประสิทธิภาพของระบบ</p><p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image"></p><p>ตั้งแต่เวอร์ชัน 1.22.0 เมื่อชนิดข้อมูลเป็น </code>byte[]<code> ระบบจะบันทึกเส้นทางไฟล์ในเซลล์โดยอัตโนมัติ และเมื่อทำการนำเข้า ระบบจะสามารถแปลงกลับเป็น </code>byte[]<code> ได้ และหากคุณไม่ต้องการใช้ฟีเจอร์นี้ คุณสามารถตั้งค่า </code>OpenXmlConfiguration.EnableConvertByteArray<code> เป็น </code>false<code> เพื่อปรับปรุงประสิทธิภาพของระบบ</p><p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image"></p><p>#### 12. การรวมเซลล์เดียวกันในแนวตั้ง</p><p>ฟังก์ชันนี้รองรับเฉพาะในรูปแบบ </code>xlsx<code> และจะรวมเซลล์ในแนวตั้งระหว่างแท็ก @merge และ @endmerge
คุณสามารถใช้ @mergelimit เพื่อจำกัดขอบเขตของการรวมเซลล์ในแนวตั้ง</p><p></code></pre>csharp
var mergedFilePath = Path.Combine(Path.GetTempPath(), $"{Guid.NewGuid().ToString()}.xlsx");</p><p>var path = @"../../../../../samples/xlsx/TestMergeWithTag.xlsx";</p><p>MiniExcel.MergeSameCells(mergedFilePath, path);
<pre><code class="language-"></p><p></code></pre>csharp
var memoryStream = new MemoryStream();</p><p>var path = @"../../../../../samples/xlsx/TestMergeWithTag.xlsx";</p><p>memoryStream.MergeSameCells(path);
<pre><code class="language-">เนื้อหาของไฟล์ก่อนและหลังการรวมเซลล์:</p><p>โดยไม่มีขีดจำกัดการรวมเซลล์:</p><p><img width="318" alt="Screenshot 2023-08-07 at 11 59 24" src="https://github.com/mini-software/MiniExcel/assets/38832863/49cc96b9-6c35-4bf3-8d43-a9752a15b22e"></p><p><img width="318" alt="Screenshot 2023-08-07 at 11 59 57" src="https://github.com/mini-software/MiniExcel/assets/38832863/3fbd529b-3ae6-4bbe-b4d8-2793a5a58010"></p><p>โดยมีขีดจำกัดการรวมเซลล์:</p><p><img width="346" alt="Screenshot 2023-08-08 at 18 21 00" src="https://github.com/mini-software/MiniExcel/assets/38832863/04049d28-84d5-4c2a-bcff-5847547df5e1"></p><p><img width="346" alt="Screenshot 2023-08-08 at 18 21 40" src="https://github.com/mini-software/MiniExcel/assets/38832863/f5cf8957-b0b0-4831-b8fc-8556299235c2"></p><p>#### 13. ข้ามค่าที่เป็น null</p><p>ตัวเลือกใหม่ที่ชัดเจนสำหรับการเขียนเซลล์ว่างเมื่อค่ามีค่าเป็น null:</p><p></code></pre>csharp
DataTable dt = new DataTable();</p><p>/<em> ... </em>/</p><p>DataRow dr = dt.NewRow();</p><p>dr["Name1"] = "Somebody once";
dr["Name2"] = null;
dr["Name3"] = "told me.";</p><p>dt.Rows.Add(dr);</p><p>OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = true // Default value.
};</p><p>MiniExcel.SaveAs(@"C:\temp\Book1.xlsx", dt, configuration: configuration);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/31481586/241419455-3c0aec8a-4e5f-4d83-b7ec-6572124c165d.png" alt="image"></p><p></code></pre>xml
<x:row r="2">
    <x:c r="A2" t ="str" s="2">
        <x:v>Somebody once</x:v>
    </x:c>
    <x:c r="B2" s="2"></x:c>
    <x:c r="C2" t ="str" s="2">
        <x:v>told me.</x:v>
    </x:c>
</x:row>
<pre><code class="language-"></p><p>พฤติกรรมก่อนหน้านี้:</p><p></code></pre>csharp
/<em> ... </em>/</p><p>OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = false // Default value is true.
};</p><p>MiniExcel.SaveAs(@"C:\temp\Book1.xlsx", dt, configuration: configuration);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/31481586/241419441-c4f27e8f-3f87-46db-a10f-08665864c874.png" alt="image"></p><p></code></pre>xml
<x:row r="2">
    <x:c r="A2" t ="str" s="2">
        <x:v>Somebody once</x:v>
    </x:c>
    <x:c r="B2" t ="str" s="2">
        <x:v></x:v>
    </x:c>
    <x:c r="C2" t ="str" s="2">
        <x:v>told me.</x:v>
    </x:c>
</x:row>
<pre><code class="language-">ใช้งานได้กับค่า null และ DBNull</p><p>#### 14. แช่ค้างบานหน้าต่าง
</code></pre>csharp
/<em> ... </em>/</p><p>OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
    FreezeRowCount = 1,     // default is 1
    FreezeColumnCount = 2   // default is 0
};</p><p>MiniExcel.SaveAs(@"C:\temp\Book1.xlsx", dt, configuration: configuration);
<pre><code class="language-"><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/freeze-pane-1.png" alt="image"></p><h3>เติมข้อมูลลงในเทมเพลต Excel <a name="getstart3"></a></h3></p><ul><li>การประกาศตัวแปรคล้ายกับเทมเพลตของ Vue เช่น </code>{{ชื่อ ตัวแปร}}<code> หรือการแสดงผลแบบคอลเลกชัน </code>{{ชื่อคอลเลกชัน.ชื่อฟิลด์}}<code></li>
<li>การแสดงผลแบบคอลเลกชันรองรับ IEnumerable/DataTable/DapperRow</li></p><p></ul>#### 1. การเติมข้อมูลพื้นฐาน</p><p>เทมเพลต:
<img src="https://user-images.githubusercontent.com/12729184/114537556-ed8d2b00-9c84-11eb-8303-a69f62c41e5b.png" alt="image"></p><p>ผลลัพธ์:
<img src="https://user-images.githubusercontent.com/12729184/114537490-d8180100-9c84-11eb-8c69-db58692f3a85.png" alt="image"></p><p>โค้ด:
</code></pre>csharp
// 1. By POCO
var value = new
{
    Name = "Jack",
    CreateDate = new DateTime(2021, 01, 01),
    VIP = true,
    Points = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);</p><p>
// 2. By Dictionary
var value = new Dictionary<string, object>()
{
    ["Name"] = "Jack",
    ["CreateDate"] = new DateTime(2021, 01, 01),
    ["VIP"] = true,
    ["Points"] = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 2. การเติมข้อมูลแบบ IEnumerable</p><blockquote>หมายเหตุ1: ใช้ IEnumerable แรกของคอลัมน์เดียวกันเป็นพื้นฐานในการเติมรายการ</blockquote></p><p>เทมเพลต:
<img src="https://user-images.githubusercontent.com/12729184/114564652-14f2f080-9ca3-11eb-831f-09e3fedbc5fc.png" alt="image"></p><p>ผลลัพธ์:
<img src="https://user-images.githubusercontent.com/12729184/114564204-b2015980-9ca2-11eb-900d-e21249f93f7c.png" alt="image"></p><p>โค้ด:</p><p>
</code></pre>csharp
//1. By POCO
var value = new
{
    employees = new[] {
        new {name="Jack",department="HR"},
        new {name="Lisa",department="HR"},
        new {name="John",department="HR"},
        new {name="Mike",department="IT"},
        new {name="Neo",department="IT"},
        new {name="Loan",department="IT"}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);</p><p>//2. By Dictionary
var value = new Dictionary<string, object>()
{
    ["employees"] = new[] {
        new {name="Jack",department="HR"},
        new {name="Lisa",department="HR"},
        new {name="John",department="HR"},
        new {name="Mike",department="IT"},
        new {name="Neo",department="IT"},
        new {name="Loan",department="IT"}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 3. การเติมข้อมูลที่ซับซ้อน</p><blockquote>หมายเหตุ: รองรับหลายชีทและการใช้ตัวแปรเดียวกัน</blockquote></p><p>เทมเพลต:</p><p><img src="https://user-images.githubusercontent.com/12729184/114565255-acf0da00-9ca3-11eb-8a7f-8131b2265ae8.png" alt="image"></p><p>ผลลัพธ์:</p><p><img src="https://user-images.githubusercontent.com/12729184/114565329-bf6b1380-9ca3-11eb-85e3-3969e8bf6378.png" alt="image"></p><p></code></pre>csharp
// 1. By POCO
var value = new
{
    title = "FooCompany",
    managers = new[] {
        new {name="Jack",department="HR"},
        new {name="Loan",department="IT"}
    },
    employees = new[] {
        new {name="Wade",department="HR"},
        new {name="Felix",department="HR"},
        new {name="Eric",department="IT"},
        new {name="Keaton",department="IT"}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);</p><p>// 2. By Dictionary
var value = new Dictionary<string, object>()
{
    ["title"] = "FooCompany",
    ["managers"] = new[] {
        new {name="Jack",department="HR"},
        new {name="Loan",department="IT"}
    },
    ["employees"] = new[] {
        new {name="Wade",department="HR"},
        new {name="Felix",department="HR"},
        new {name="Eric",department="IT"},
        new {name="Keaton",department="IT"}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 4. ประสิทธิภาพการเติมข้อมูล Big Data</p><blockquote>หมายเหตุ: การใช้ IEnumerable ที่มี deferred execution แทนการใช้ ToList สามารถประหยัดการใช้หน่วยความจำสูงสุดใน MiniExcel</blockquote></p><p><img src="https://user-images.githubusercontent.com/12729184/114577091-5046ec80-9cae-11eb-924b-087c7becf8da.png" alt="image"></p><p>#### 5. การจับคู่อัตโนมัติชนิดข้อมูลของค่าเซลล์</p><p>แม่แบบ</p><p><img src="https://user-images.githubusercontent.com/12729184/114802504-64830a80-9dd0-11eb-8d56-8e8c401b3ace.png" alt="image"></p><p>ผลลัพธ์</p><p><img src="https://user-images.githubusercontent.com/12729184/114802419-43221e80-9dd0-11eb-9ffe-a2ce34fe7076.png" alt="image"></p><p>คลาส</p><p></code></pre>csharp
public class Poco
{
    public string @string { get; set; }
    public int? @int { get; set; }
    public decimal? @decimal { get; set; }
    public double? @double { get; set; }
    public DateTime? datetime { get; set; }
    public bool? @bool { get; set; }
    public Guid? Guid { get; set; }
}
<pre><code class="language-"></p><p>โค้ด</p><p></code></pre>csharp
var poco = new TestIEnumerableTypePoco { @string = "string", @int = 123, @decimal = decimal.Parse("123.45"), @double = (double)123.33, @datetime = new DateTime(2021, 4, 1), @bool = true, @Guid = Guid.NewGuid() };
var value = new
{
    Ts = new[] {
        poco,
        new TestIEnumerableTypePoco{},
        null,
        poco
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 6. ตัวอย่าง : แสดงรายการโปรเจ็กต์ Github</p><p>แม่แบบ</p><p><img src="https://user-images.githubusercontent.com/12729184/115068623-12073280-9f25-11eb-9124-f4b3efcdb2a7.png" alt="image"></p><p>
ผลลัพธ์</p><p><img src="https://user-images.githubusercontent.com/12729184/115068639-1a5f6d80-9f25-11eb-9f45-27c434d19a78.png" alt="image"></p><p>โค้ด</p><p></code></pre>csharp
var projects = new[]
{
    new {Name = "MiniExcel",Link="https://github.com/mini-software/MiniExcel",Star=146, CreateTime=new DateTime(2021,03,01)},
    new {Name = "HtmlTableHelper",Link="https://github.com/mini-software/HtmlTableHelper",Star=16, CreateTime=new DateTime(2020,02,01)},
    new {Name = "PocoClassGenerator",Link="https://github.com/mini-software/PocoClassGenerator",Star=16, CreateTime=new DateTime(2019,03,17)}
};
var value = new
{
    User = "ITWeiHan",
    Projects = projects,
    TotalStar = projects.Sum(s => s.Star)
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 7. การเติมข้อมูลแบบกลุ่ม</p><p></code></pre>csharp
var value = new Dictionary<string, object>()
{
    ["employees"] = new[] {
        new {name="Jack",department="HR"},
        new {name="Jack",department="HR"},
        new {name="John",department="HR"},
        new {name="John",department="IT"},
        new {name="Neo",department="IT"},
        new {name="Loan",department="IT"}
    }
};
await MiniExcel.SaveAsByTemplateAsync(path, templatePath, value);
<pre><code class="language-">##### 1. มีแท็ก </code>@group<code> และมีแท็ก </code>@header<code></p><p>ก่อน</p><p><img src="https://user-images.githubusercontent.com/38832863/218646717-21b9d57a-2be2-4e9a-801b-ae212231d2b4.PNG" alt="before_with_header"></p><p>หลัง</p><p><img src="https://user-images.githubusercontent.com/38832863/218646721-58a7a340-7004-4bc2-af24-cffcb2c20737.PNG" alt="after_with_header"></p><p>##### 2. มีแท็ก @group แต่ไม่มีแท็ก @header</p><p>ก่อน</p><p><img src="https://user-images.githubusercontent.com/38832863/218646873-b12417fa-801b-4890-8e96-669ed3b43902.PNG" alt="before_without_header"></p><p>หลัง</p><p><img src="https://user-images.githubusercontent.com/38832863/218646872-622461ba-342e-49ee-834f-b91ad9c2dac3.PNG" alt="after_without_header"></p><p>##### 3. ไม่มีแท็ก @group</p><p>ก่อน</p><p><img src="https://user-images.githubusercontent.com/38832863/218646975-f52a68eb-e031-43b5-abaa-03b67c052d1a.PNG" alt="without_group"></p><p>หลัง</p><p><img src="https://user-images.githubusercontent.com/38832863/218646974-4a3c0e07-7c66-4088-ad07-b4ad3695b7e1.PNG" alt="without_group_after"></p><p>#### 8. คำสั่ง If/ElseIf/Else ภายในเซลล์</p><p>กฎ:
<ul><li>รองรับ DateTime, Double, Int ด้วยตัวดำเนินการ ==, !=, >, >=, <, <=</li>
<li>รองรับ String ด้วยตัวดำเนินการ ==, !=</li>
<li>แต่ละคำสั่งควรขึ้นบรรทัดใหม่</li>
<li>ควรเว้นวรรค 1 ช่องหน้าหลังตัวดำเนินการ</li>
<li>ไม่ควรมีการขึ้นบรรทัดใหม่ภายในคำสั่ง</li>
<li>เซลล์ควรอยู่ในรูปแบบเดียวกับตัวอย่างด้านล่าง</li>
</ul></code></pre>csharp
@if(name == Jack)
{{employees.name}}
@elseif(name == Neo)
Test {{employees.name}}
@else
{{employees.department}}
@endif
<pre><code class="language-">ก่อน</p><p><img src="https://user-images.githubusercontent.com/38832863/235360606-ca654769-ff55-4f5b-98d2-d2ec0edb8173.PNG" alt="if_before"></p><p>หลัง</p><p><img src="https://user-images.githubusercontent.com/38832863/235360609-869bb960-d63d-45ae-8d64-9e8b0d0ab658.PNG" alt="if_after"></p><p>#### 9. DataTable เป็นพารามิเตอร์</p><p></code></pre>csharp
var managers = new DataTable();
{
    managers.Columns.Add("name");
    managers.Columns.Add("department");
    managers.Rows.Add("Jack", "HR");
    managers.Rows.Add("Loan", "IT");
}
var value = new Dictionary<string, object>()
{
    ["title"] = "FooCompany",
    ["managers"] = managers,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
<pre><code class="language-">#### 10. สูตรคำนวณ</p><p>##### 1. ตัวอย่าง
เติม </code>$<code> หน้าสูตรของคุณและใช้ </code>$enumrowstart<code> กับ </code>$enumrowend<code> เพื่อกำหนดจุดเริ่มต้นและจุดสิ้นสุดของแถวที่วนซ้ำ:</p><p><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/template-formulas-1.png" alt="image"></p><p>เมื่อมีการเรนเดอร์เทมเพลต ตัวคำนำหน้า </code>$<code> จะถูกลบออก และ </code>$enumrowstart<code> กับ </code>$enumrowend<code> จะถูกแทนที่ด้วยเลขแถวเริ่มต้นและสิ้นสุดของรายการที่วนซ้ำ:</p><p><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/template-formulas-2.png" alt="image"></p><p>##### 2. ตัวอย่างสูตรอื่น ๆ:</p><p>|              |                                                                                           |
|--------------|-------------------------------------------------------------------------------------------|
| ผลรวม        | </code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}})<code>                                              |
| ค่าเฉลี่ยทางเลือก | </code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}}) / COUNT(C{{$enumrowstart}}:C{{$enumrowend}})<code> |
| ช่วง         | </code>$=MAX(C{{$enumrowstart}}:C{{$enumrowend}}) - MIN(C{{$enumrowstart}}:C{{$enumrowend}})<code>   |</p><p>
#### 11. อื่น ๆ</p><p>##### 1. การตรวจสอบคีย์พารามิเตอร์ของเทมเพลต</p><p>ตั้งแต่ V1.24.0 ระบบจะละเว้นคีย์พารามิเตอร์ที่หายไปของเทมเพลตโดยอัตโนมัติและแทนที่ด้วยสตริงว่าง คุณสามารถใช้ </code>IgnoreTemplateParameterMissing<code> เพื่อควบคุมว่าจะให้ระบบแจ้งข้อผิดพลาดหรือไม่
</code></pre>csharp
var config = new OpenXmlConfiguration()
{
    IgnoreTemplateParameterMissing = false,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value, config)
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/157464332-e316f829-54aa-4c84-a5aa-9aef337b668d.png" alt="image"></p><h3>ชื่อคอลัมน์/ดัชนีคอลัมน์/Attribute การละเว้นใน Excel <a name="getstart4"></a></h3></p><p>#### 1. ระบุชื่อคอลัมน์, ดัชนีคอลัมน์, ละเว้นคอลัมน์</p><p>ตัวอย่าง Excel</p><p><img src="https://user-images.githubusercontent.com/12729184/114230869-3e163700-99ac-11eb-9a90-2039d4b4b313.png" alt="image"></p><p>โค้ด</p><p></code></pre>csharp
public class ExcelAttributeDemo
{
    [ExcelColumnName("Column1")]
    public string Test1 { get; set; }
    [ExcelColumnName("Column2")]
    public string Test2 { get; set; }
    [ExcelIgnore]
    public string Test3 { get; set; }
    [ExcelColumnIndex("I")] // system will convert "I" to 8 index
    public string Test4 { get; set; }
    public string Test5 { get; } //wihout set will ignore
    public string Test6 { get; private set; } //un-public set will ignore
    [ExcelColumnIndex(3)] // start with 0
    public string Test7 { get; set; }
}</p><p>var rows = MiniExcel.Query<ExcelAttributeDemo>(path).ToList();
Assert.Equal("Column1", rows[0].Test1);
Assert.Equal("Column2", rows[0].Test2);
Assert.Null(rows[0].Test3);
Assert.Equal("Test7", rows[0].Test4);
Assert.Null(rows[0].Test5);
Assert.Null(rows[0].Test6);
Assert.Equal("Test4", rows[0].Test7);
<pre><code class="language-"></p><p>#### 2. รูปแบบกำหนดเอง (ExcelFormatAttribute)</p><p>ตั้งแต่เวอร์ชัน V0.21.0 รองรับคลาสที่มีเมธอด </code>ToString(string content)<code> สำหรับการจัดรูปแบบ</p><p>คลาส</p><p></code></pre>csharp
public class Dto
{
    public string Name { get; set; }</p><p>    [ExcelFormat("MMMM dd, yyyy")]
    public DateTime InDate { get; set; }
}
<pre><code class="language-"></p><p>โค้ด</p><p></code></pre>csharp
var value = new Dto[] {
    new Issue241Dto{ Name="Jack",InDate=new DateTime(2021,01,04)},
    new Issue241Dto{ Name="Henry",InDate=new DateTime(2020,04,05)},
};
MiniExcel.SaveAs(path, value);
<pre><code class="language-">ผลลัพธ์</p><p><img src="https://user-images.githubusercontent.com/12729184/118910788-ab2bcd80-b957-11eb-8d42-bfce36621b1b.png" alt="image"></p><p>คิวรีรองรับการแปลงรูปแบบที่กำหนดเอง</p><p><img src="https://user-images.githubusercontent.com/12729184/118911286-87b55280-b958-11eb-9a88-c8ff403d240a.png" alt="image"></p><p>#### 3. กำหนดความกว้างของคอลัมน์ (ExcelColumnWidthAttribute)</p><p></code></pre>csharp
public class Dto
{
    [ExcelColumnWidth(20)]
    public int ID { get; set; }
    [ExcelColumnWidth(15.50)]
    public string Name { get; set; }
}
<pre><code class="language-">#### 4. การแมปชื่อคอลัมน์หลายชื่อไปยังพร็อพเพอร์ตี้เดียวกัน</p><p></code></pre>csharp
public class Dto
{
    [ExcelColumnName(excelColumnName:"EmployeeNo",aliases:new[] { "EmpNo","No" })]
    public string Empno { get; set; }
    public string Name { get; set; }
}
<pre><code class="language-"></p><p>#### 5. System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</p><p>ตั้งแต่เวอร์ชัน 1.24.0 ระบบรองรับ System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</p><p></code></pre>C#
public class TestIssueI4TXGTDto
{
    public int ID { get; set; }
    public string Name { get; set; }
    [DisplayName("Specification")]
    public string Spc { get; set; }
    [DisplayName("Unit Price")]
    public decimal Up { get; set; }
}
<pre><code class="language-">#### 6. ExcelColumnAttribute</p><p>ตั้งแต่เวอร์ชัน V1.26.0 สามารถทำให้หลายแอตทริบิวต์ง่ายขึ้นได้ เช่น:</p><p>
</code></pre>csharp
        public class TestIssueI4ZYUUDto
        {
            [ExcelColumn(Name = "ID",Index =0)]
            public string MyProperty { get; set; }
            [ExcelColumn(Name = "CreateDate", Index = 1,Format ="yyyy-MM",Width =100)]
            public DateTime MyProperty2 { get; set; }
        }
<pre><code class="language-"></p><p>#### 7. DynamicColumnAttribute</p><p>ตั้งแต่เวอร์ชัน V1.26.0 เราสามารถกำหนดแอตทริบิวต์ของ Column ได้แบบไดนามิก</code></pre>csharp
            var config = new OpenXmlConfiguration
            {
                DynamicColumns = new DynamicExcelColumn[] {
                    new DynamicExcelColumn("id"){Ignore=true},
                    new DynamicExcelColumn("name"){Index=1,Width=10},
                    new DynamicExcelColumn("createdate"){Index=0,Format="yyyy-MM-dd",Width=15},
                    new DynamicExcelColumn("point"){Index=2,Name="Account Point"},
                }
            };
            var path = PathHelper.GetTempPath();
            var value = new[] { new { id = 1, name = "Jack", createdate = new DateTime(2022, 04, 12) ,point = 123.456} };
            MiniExcel.SaveAs(path, value, configuration: config);
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/164510353-5aecbc4e-c3ce-41e8-b6cf-afd55eb23b68.png" alt="image"></p><p>#### 8. DynamicSheetAttribute</p><p>ตั้งแต่เวอร์ชัน V1.31.4 เราสามารถตั้งค่าคุณสมบัติของชีตได้แบบไดนามิก เราสามารถตั้งชื่อชีตและสถานะ (การมองเห็น) ได้</p><p></code></pre>csharp
            var configuration = new OpenXmlConfiguration
            {
                DynamicSheets = new DynamicExcelSheet[] {
                    new DynamicExcelSheet("usersSheet") { Name = "Users", State = SheetState.Visible },
                    new DynamicExcelSheet("departmentSheet") { Name = "Departments", State = SheetState.Hidden }
                }
            };</p><p>            var users = new[] { new { Name = "Jack", Age = 25 }, new { Name = "Mike", Age = 44 } };
            var department = new[] { new { ID = "01", Name = "HR" }, new { ID = "02", Name = "IT" } };
            var sheets = new Dictionary<string, object>
            {
                ["usersSheet"] = users,
                ["departmentSheet"] = department
            };</p><p>            var path = PathHelper.GetTempPath();
            MiniExcel.SaveAs(path, sheets, configuration: configuration);
<pre><code class="language-">เรายังสามารถใช้แอตทริบิวต์ใหม่ ExcelSheetAttribute ได้อีกด้วย:</p><p></code></pre>C#
   [ExcelSheet(Name = "Departments", State = SheetState.Hidden)]
   private class DepartmentDto
   {
      [ExcelColumn(Name = "ID",Index = 0)]
      public string ID { get; set; }
      [ExcelColumn(Name = "Name",Index = 1)]
      public string Name { get; set; }
   }
<pre><code class="language-">### เพิ่ม, ลบ, อัปเดต</p><p>#### เพิ่ม</p><p>v1.28.0 รองรับการแทรกข้อมูล CSV หลายแถวหลังจากแถวสุดท้าย</p><p></code></pre>csharp
// Origin
{
    var value = new[] {
          new { ID=1,Name ="Jack",InDate=new DateTime(2021,01,03)},
          new { ID=2,Name ="Henry",InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value);
}
// Insert 1 rows after last
{
    var value = new { ID=3,Name = "Mike", InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, value);
}
// Insert N rows after last
{
    var value = new[] {
          new { ID=4,Name ="Frank",InDate=new DateTime(2021,06,07)},
          new { ID=5,Name ="Gloria",InDate=new DateTime(2022,05,03)},
    };
    MiniExcel.Insert(path, value);
}
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/191023733-1e2fa732-db5c-4a3a-9722-b891fe5aa069.png" alt="image"></p><p>v1.37.0 รองรับการแทรกแผ่นงานใหม่ในไฟล์ Excel ที่มีอยู่</p><p></code></pre>csharp
// Origin excel
{
    var value = new[] {
          new { ID=1,Name ="Jack",InDate=new DateTime(2021,01,03)},
          new { ID=2,Name ="Henry",InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value, sheetName: "Sheet1");
}
// Insert a new sheet
{
    var value = new { ID=3,Name = "Mike", InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, table, sheetName: "Sheet2");
}
<pre><code class="language-"></p><p>#### ลบ(รอ)</p><p>#### อัปเดต(รอ)</p><h3>ตรวจสอบประเภท Excel อัตโนมัติ <a name="getstart5"></a></h3></p><ul><li>MiniExcel จะตรวจสอบว่าเป็น xlsx หรือ csv ตาม </code>นามสกุลไฟล์<code> โดยค่าเริ่มต้น แต่ข้อมูลอาจคลาดเคลื่อน กรุณาระบุด้วยตนเอง</li>
<li>กรณีเป็น Stream จะไม่สามารถทราบได้ว่าเป็น excel ประเภทใด กรุณาระบุด้วยตนเอง</li></p><p></ul></code></pre>csharp
stream.SaveAs(excelType:ExcelType.CSV);
//or
stream.SaveAs(excelType:ExcelType.XLSX);
//or
stream.Query(excelType:ExcelType.CSV);
//or
stream.Query(excelType:ExcelType.XLSX);
<pre><code class="language-"></p><h3>CSV</h3></p><p>#### หมายเหตุ</p><ul><li>โดยปกติจะส่งค่ากลับเป็นประเภท </code>string<code> และค่าจะไม่ถูกแปลงเป็นตัวเลขหรือวันที่และเวลา เว้นแต่จะมีการกำหนดประเภทโดยการใช้ generic ที่มี strong typing</li></p><p></ul>#### ตัวคั่นแบบกำหนดเอง</p><p>ค่าดีฟอลต์คือ </code>,<code> เป็นตัวคั่น คุณสามารถปรับแต่งได้โดยการแก้ไขคุณสมบัติ </code>Seperator<code></p><p></code></pre>csharp
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    Seperator=';'
};
MiniExcel.SaveAs(path, values,configuration: config);
<pre><code class="language-">ตั้งแต่ V1.30.1 รองรับฟังก์ชันในการกำหนดตัวคั่นเอง (ขอบคุณ @hyzx86)</p><p></code></pre>csharp
var config = new CsvConfiguration()
{
    SplitFn = (row) => Regex.Split(row, $"<a href="?=(?:[^\"]|\"[^\"]<em>\"" target="_blank" rel="noopener noreferrer">\t,</a></em>$)")
        .Select(s => Regex.Replace(s.Replace("\"\"", "\""), "^\"|\"$", "")).ToArray()
};
var rows = MiniExcel.Query(path, configuration: config).ToList();
<pre><code class="language-">#### ขึ้นบรรทัดใหม่แบบกำหนดเอง</p><p>ค่าปกติคือ </code>\r\n<code> เป็นอักขระขึ้นบรรทัดใหม่ คุณสามารถปรับแต่งได้โดยแก้ไขคุณสมบัติ </code>NewLine<code></p><p></code></pre>csharp
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    NewLine='\n'
};
MiniExcel.SaveAs(path, values,configuration: config);
<pre><code class="language-">#### การเขียนโค้ดเอง</p><ul><li>การเข้ารหัสเริ่มต้นคือ "ตรวจจับการเข้ารหัสจาก Byte Order Marks" (detectEncodingFromByteOrderMarks: true)</li>
<li>หากคุณมีข้อกำหนดการเข้ารหัสแบบกำหนดเอง กรุณาแก้ไขคุณสมบัติ StreamReaderFunc / StreamWriterFunc</li></p><p></ul></code></pre>csharp
// Read
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamReaderFunc = (stream) => new StreamReader(stream,Encoding.GetEncoding("gb2312"))
};
var rows = MiniExcel.Query(path, true,excelType:ExcelType.CSV,configuration: config);</p><p>// Write
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamWriterFunc = (stream) => new StreamWriter(stream, Encoding.GetEncoding("gb2312"))
};
MiniExcel.SaveAs(path, value,excelType:ExcelType.CSV, configuration: config);
<pre><code class="language-">#### อ่านสตริงว่างเป็นค่าว่าง (null)</p><p>โดยค่าเริ่มต้น ค่าว่างจะถูกแมปเป็น string.Empty คุณสามารถปรับเปลี่ยนพฤติกรรมนี้ได้</p><p></code></pre>csharp
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
   ReadEmptyStringAsNull = true
};
<pre><code class="language-">### DataReader</p><p>#### 1. GetReader
ตั้งแต่เวอร์ชัน 1.23.0 คุณสามารถใช้ GetDataReader ได้</p><p>
</code></pre>csharp
    using (var reader = MiniExcel.GetReader(path,true))
    {
        while (reader.Read())
        {
            for (int i = 0; i < reader.FieldCount; i++)
            {
                var value = reader.GetValue(i);
            }
        }
    }
<pre><code class="language-"></p><h3> แอซิงโครนัส</h3></p><ul><li>v0.17.0 รองรับแอซิงโครนัส (ขอบคุณ isdaniel ( SHIH,BING-SIOU)](https://github.com/isdaniel))</li></p><p></ul></code></pre>csharp
public static Task SaveAsAsync(string path, object value, bool printHeader = true, string sheetName = "Sheet1", ExcelType excelType = ExcelType.UNKNOWN, IConfiguration configuration = null)
public static Task SaveAsAsync(this Stream stream, object value, bool printHeader = true, string sheetName = "Sheet1", ExcelType excelType = ExcelType.XLSX, IConfiguration configuration = null)
public static Task<IEnumerable<dynamic>> QueryAsync(string path, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = "A1", IConfiguration configuration = null)
public static Task<IEnumerable<T>> QueryAsync<T>(this Stream stream, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = "A1", IConfiguration configuration = null) where T : class, new()
public static Task<IEnumerable<T>> QueryAsync<T>(string path, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = "A1", IConfiguration configuration = null) where T : class, new()
public static Task<IEnumerable<IDictionary<string, object>>> QueryAsync(this Stream stream, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = "A1", IConfiguration configuration = null)
public static Task SaveAsByTemplateAsync(this Stream stream, string templatePath, object value)
public static Task SaveAsByTemplateAsync(this Stream stream, byte[] templateBytes, object value)
public static Task SaveAsByTemplateAsync(string path, string templatePath, object value)
public static Task SaveAsByTemplateAsync(string path, byte[] templateBytes, object value)
public static Task<DataTable> QueryAsDataTableAsync(string path, bool useHeaderRow = true, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = "A1", IConfiguration configuration = null)
<pre><code class="language-">-  v1.25.0 รองรับ </code>cancellationToken<code>。</p><h3>อื่น ๆ</h3></p><p>#### 1. Enum</p><p>โปรดตรวจสอบให้แน่ใจว่า excel และชื่อพร็อพเพอร์ตี้ตรงกัน ระบบจะทำการแมปอัตโนมัติ (ไม่สนใจตัวพิมพ์ใหญ่-เล็ก)</p><p><img src="https://user-images.githubusercontent.com/12729184/116210595-9784b100-a775-11eb-936f-8e7a8b435961.png" alt="image"></p><p>ตั้งแต่ V0.18.0 รองรับ Enum Description</p><p></code></pre>csharp
public class Dto
{
    public string Name { get; set; }
    public I49RYZUserType UserType { get; set; }
}</p><p>public enum Type
{
    [Description("General User")]
    V1,
    [Description("General Administrator")]
    V2,
    [Description("Super Administrator")]
    V3
}
<pre><code class="language-"><img src="https://user-images.githubusercontent.com/12729184/133116630-27cc7161-099a-48b8-9784-cd1e443af3d1.png" alt="image"></p><p>ตั้งแต่เวอร์ชัน 1.30.0 รองรับฟีเจอร์แปลง Description ใน Excel เป็น Enum ขอบคุณ @KaneLeung</p><p>#### 2. แปลงไฟล์ CSV เป็น XLSX หรือแปลง XLSX เป็น CSV</p><p></code></pre>csharp
MiniExcel.ConvertXlsxToCsv(xlsxPath, csvPath);
MiniExcel.ConvertXlsxToCsv(xlsxStream, csvStream);
MiniExcel.ConvertCsvToXlsx(csvPath, xlsxPath);
MiniExcel.ConvertCsvToXlsx(csvStream, xlsxStream);
<pre><code class="language-"></code>`<code>csharp
using (var excelStream = new FileStream(path: filePath, FileMode.Open, FileAccess.Read))
using (var csvStream = new MemoryStream())
{
   MiniExcel.ConvertXlsxToCsv(excelStream, csvStream);
}</code></pre>
#### 3. กำหนดค่า CultureInfo เอง</p><p>ตั้งแต่เวอร์ชัน 1.22.0 คุณสามารถกำหนด CultureInfo เองได้ตามตัวอย่างด้านล่าง โดยปกติระบบจะใช้ </code>CultureInfo.InvariantCulture<code> เป็นค่าเริ่มต้น</p><pre><code class="language-csharp">var config = new CsvConfiguration()
{
    Culture = new CultureInfo("fr-FR"),
};
MiniExcel.SaveAs(path, value, configuration: config);</p><p>// or
MiniExcel.Query(path, configuration: config);</code></pre>
#### 4. ขนาดบัฟเฟอร์ที่กำหนดเอง</p><pre><code class="language-csharp">    public abstract class Configuration : IConfiguration
    {
        public int BufferSize { get; set; } = 1024 * 512;
    }</code></pre>
#### 5. FastMode</p><p>ระบบจะไม่ควบคุมหน่วยความจำ แต่คุณจะสามารถบันทึกข้อมูลได้เร็วขึ้น</p><pre><code class="language-csharp">var config = new OpenXmlConfiguration() { FastMode = true };
MiniExcel.SaveAs(path, reader,configuration:config);</code></pre>
#### 6. การเพิ่มรูปภาพแบบชุด (MiniExcel.AddPicture)</p><p>กรุณาเพิ่มรูปภาพก่อนการสร้างข้อมูลแถวแบบชุด มิฉะนั้นระบบจะใช้หน่วยความจำจำนวนมากเมื่อเรียกใช้ AddPicture</p><pre><code class="language-csharp">var images = new[]
{
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile("images/github_logo.png")),
        SheetName = null, // default null is first sheet
        CellAddress = "C3", // required
    },
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile("images/google_logo.png")),
        PictureType = "image/png", // default PictureType = image/png
        SheetName = "Demo",
        CellAddress = "C9", // required
        WidthPx = 100,
        HeightPx = 100,
    },
};
MiniExcel.AddPicture(path, images);</code></pre>
<img src="https://github.com/user-attachments/assets/19c4d241-9753-4ede-96c8-f810c1a22247" alt="Image"></p><p>#### 7. รับขนาดของชีต</p><pre><code class="language-csharp">var dim = MiniExcel.GetSheetDimensions(path);</code></pre>
<h3>ตัวอย่าง:</h3></p><p>#### 1. SQLite & Dapper </code>ไฟล์ขนาดใหญ่<code> การแทรกข้อมูล SQL เพื่อหลีกเลี่ยง OOM</p><p>หมายเหตุ : กรุณาอย่าเรียกใช้เมธอด ToList/ToArray หลังจาก Query เพราะจะโหลดข้อมูลทั้งหมดเข้าหน่วยความจำ</p><pre><code class="language-csharp">using (var connection = new SQLiteConnection(connectionString))
{
    connection.Open();
    using (var transaction = connection.BeginTransaction())
    using (var stream = File.OpenRead(path))
    {
       var rows = stream.Query();
       foreach (var row in rows)
             connection.Execute("insert into T (A,B) values (@A,@B)", new { row.A, row.B }, transaction: transaction);
       transaction.Commit();
    }
}</code></pre>
ประสิทธิภาพ:
<img src="https://user-images.githubusercontent.com/12729184/111072579-2dda7b80-8516-11eb-9843-c01a1edc88ec.png" alt="image"></p><p>#### 2. ตัวอย่าง API ASP.NET Core 3.1 หรือ MVC 5 สำหรับดาวน์โหลด/อัปโหลด Excel Xlsx <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/tests/MiniExcel.Tests.AspNetCore" target="_blank" rel="noopener noreferrer">ทดลองใช้งาน</a></p><pre><code class="language-csharp">public class ApiController : Controller
{
    public IActionResult Index()
    {
        return new ContentResult
        {
            ContentType = "text/html",
            StatusCode = (int)HttpStatusCode.OK,
            Content = @"<html><body>
<a href='api/DownloadExcel'>DownloadExcel</a><br>
<a href='api/DownloadExcelFromTemplatePath'>DownloadExcelFromTemplatePath</a><br>
<a href='api/DownloadExcelFromTemplateBytes'>DownloadExcelFromTemplateBytes</a><br>
<p>Upload Excel</p>
<form method='post' enctype='multipart/form-data' action='/api/uploadexcel'>
    <input type='file' name='excel'> <br>
    <input type='submit' >
</form>
</body></html{{"
        };
    }</p><p>    public IActionResult DownloadExcel()
    {
        var values = new[] {
            new { Column1 = "MiniExcel", Column2 = 1 },
            new { Column1 = "Github", Column2 = 2}
        };
        var memoryStream = new MemoryStream();
        memoryStream.SaveAs(values);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        {
            FileDownloadName = "demo.xlsx"
        };
    }</p><p>    public IActionResult DownloadExcelFromTemplatePath()
    {
        string templatePath = "TestTemplateComplex.xlsx";</p><p>        Dictionary<string, object> value = new Dictionary<string, object>()
        {
            ["title"] = "FooCompany",
            ["managers"] = new[] {
                new {name="Jack",department="HR"},
                new {name="Loan",department="IT"}
            },
            ["employees"] = new[] {
                new {name="Wade",department="HR"},
                new {name="Felix",department="HR"},
                new {name="Eric",department="IT"},
                new {name="Keaton",department="IT"}
            }
        };</p><p>        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(templatePath, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        {
            FileDownloadName = "demo.xlsx"
        };
    }</p><p>    private static Dictionary<string, Byte[]> TemplateBytesCache = new Dictionary<string, byte[]>();</p><p>    static ApiController()
    {
        string templatePath = "TestTemplateComplex.xlsx";
        byte[] bytes = System.IO.File.ReadAllBytes(templatePath);
        TemplateBytesCache.Add(templatePath, bytes);
    }</p><p>    public IActionResult DownloadExcelFromTemplateBytes()
    {
        byte[] bytes = TemplateBytesCache["TestTemplateComplex.xlsx"];</p><p>        Dictionary<string, object> value = new Dictionary<string, object>()
        {
            ["title"] = "FooCompany",
            ["managers"] = new[] {
                new {name="Jack",department="HR"},
                new {name="Loan",department="IT"}
            },
            ["employees"] = new[] {
                new {name="Wade",department="HR"},
                new {name="Felix",department="HR"},
                new {name="Eric",department="IT"},
                new {name="Keaton",department="IT"}
            }
        };</p><p>        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(bytes, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        {
            FileDownloadName = "demo.xlsx"
        };
    }</p><p>    public IActionResult UploadExcel(IFormFile excel)
    {
        var stream = new MemoryStream();
        excel.CopyTo(stream);</p><p>        foreach (var item in stream.Query(true))
        {
            // do your logic etc.
        }</p><p>        return Ok("File uploaded successfully");
    }
}</code></pre>
####  3. การคิวรีแบบแบ่งหน้า</p><pre><code class="language-csharp">void Main()
{
    var rows = MiniExcel.Query(path);</p><p>    Console.WriteLine("==== No.1 Page ====");
    Console.WriteLine(Page(rows,pageSize:3,page:1));
    Console.WriteLine("==== No.50 Page ====");
    Console.WriteLine(Page(rows,pageSize:3,page:50));
    Console.WriteLine("==== No.5000 Page ====");
    Console.WriteLine(Page(rows,pageSize:3,page:5000));
}</p><p>public static IEnumerable<T> Page<T>(IEnumerable<T> en, int pageSize, int page)
{
    return en.Skip(page * pageSize).Take(pageSize);
}</code></pre>
<img src="https://user-images.githubusercontent.com/12729184/114679083-6ef4c400-9d3e-11eb-9f78-a86daa45fe46.gif" alt="20210419"></p><p>#### 4. WebForm ส่งออก Excel โดยใช้ memorystream</p><pre><code class="language-csharp">var fileName = "Demo.xlsx";
var sheetName = "Sheet1";
HttpResponse response = HttpContext.Current.Response;
response.Clear();
response.ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
response.AddHeader("Content-Disposition", $"attachment;filename=\"{fileName}\"");
var values = new[] {
    new { Column1 = "MiniExcel", Column2 = 1 },
    new { Column1 = "Github", Column2 = 2}
};
var memoryStream = new MemoryStream();
memoryStream.SaveAs(values, sheetName: sheetName);
memoryStream.Seek(0, SeekOrigin.Begin);
memoryStream.CopyTo(Response.OutputStream);
response.End();</code></pre></p><p>
#### 5. การจัดการหลายภาษาแบบไดนามิก (i18n) และการจัดการสิทธิ์ตามบทบาท</p><p>เช่นเดียวกับตัวอย่าง ให้สร้างเมธอดสำหรับจัดการ i18n และการจัดการสิทธิ์ และใช้ </code>yield return เพื่อคืนค่า IEnumerable<Dictionary<string, object>><code> เพื่อให้ได้ผลลัพธ์แบบไดนามิกและประหยัดหน่วยความจำ</p><pre><code class="language-csharp">void Main()
{
    var value = new Order[] {
        new Order(){OrderNo = "SO01",CustomerID="C001",ProductID="P001",Qty=100,Amt=500},
        new Order(){OrderNo = "SO02",CustomerID="C002",ProductID="P002",Qty=300,Amt=400},
    };</p><p>    Console.WriteLine("en-Us and Sales role");
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + ".xlsx";
        var lang = "en-US";
        var role = "Sales";
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }</p><p>    Console.WriteLine("zh-CN and PMC role");
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + ".xlsx";
        var lang = "zh-CN";
        var role = "PMC";
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }
}</p><p>private IEnumerable<Dictionary<string, object>> GetOrders(string lang, string role, Order[] orders)
{
    foreach (var order in orders)
    {
        var newOrder = new Dictionary<string, object>();</p><p>        if (lang == "zh-CN")
        {
            newOrder.Add("客户编号", order.CustomerID);
            newOrder.Add("订单编号", order.OrderNo);
            newOrder.Add("产品编号", order.ProductID);
            newOrder.Add("数量", order.Qty);
            if (role == "Sales")
                newOrder.Add("价格", order.Amt);
            yield return newOrder;
        }
        else if (lang == "en-US")
        {
            newOrder.Add("Customer ID", order.CustomerID);
            newOrder.Add("Order No", order.OrderNo);
            newOrder.Add("Product ID", order.ProductID);
            newOrder.Add("Quantity", order.Qty);
            if (role == "Sales")
                newOrder.Add("Amount", order.Amt);
            yield return newOrder;
        }
        else
        {
            throw new InvalidDataException($"lang {lang} wrong");
        }
    }
}</p><p>public class Order
{
    public string OrderNo { get; set; }
    public string CustomerID { get; set; }
    public decimal Qty { get; set; }
    public string ProductID { get; set; }
    public decimal Amt { get; set; }
}</code></pre>
<img src="https://user-images.githubusercontent.com/12729184/118939964-d24bc480-b982-11eb-88dd-f06655f6121a.png" alt="image"></p><h3>คำถามที่พบบ่อย</h3></p><p>#### ถาม: ชื่อหัวตารางใน Excel ไม่ตรงกับชื่อ property ในคลาส จะ mapping อย่างไร?</p><p>ตอบ กรุณาใช้ attribute ชื่อ ExcelColumnName</p><p><img src="https://user-images.githubusercontent.com/12729184/116020475-eac50980-a678-11eb-8804-129e87200e5e.png" alt="image"></p><p>#### ถาม: จะ query หรือ export หลายชีทได้อย่างไร?</p><p>ตอบ ใช้วิธี </code>GetSheetNames<code> กับพารามิเตอร์  Query  ชื่อ sheetName.</p><pre><code class="language-csharp">var sheets = MiniExcel.GetSheetNames(path);
foreach (var sheet in sheets)
{
    Console.WriteLine($"sheet name : {sheet} ");
    var rows = MiniExcel.Query(path,useHeaderRow:true,sheetName:sheet);
    Console.WriteLine(rows);
}</code></pre>
<img src="https://user-images.githubusercontent.com/12729184/116199841-2a1f5300-a76a-11eb-90a3-6710561cf6db.png" alt="image"></p><p>#### ถาม: จะค้นหาหรือส่งออกข้อมูลเกี่ยวกับการแสดงผลของชีตได้อย่างไร?</p><p>ตอบ: ใช้วิธี </code>GetSheetInformations<code></p><pre><code class="language-csharp">var sheets = MiniExcel.GetSheetInformations(path);
foreach (var sheetInfo in sheets)
{
    Console.WriteLine($"sheet index : {sheetInfo.Index} "); // next sheet index - numbered from 0
    Console.WriteLine($"sheet name : {sheetInfo.Name} ");   // sheet name
    Console.WriteLine($"sheet state : {sheetInfo.State} "); // sheet visibility state - visible / hidden
}</code></pre>
#### ถาม: การใช้ Count จะโหลดข้อมูลทั้งหมดเข้าสู่หน่วยความจำหรือไม่?</p><p>ไม่, จากการทดสอบภาพมีข้อมูล 1 ล้านแถว*10 คอลัมน์, การใช้หน่วยความจำสูงสุด <60MB, และใช้เวลา 13.65 วินาที</p><p><img src="https://user-images.githubusercontent.com/12729184/117118518-70586000-adc3-11eb-9ce3-2ba76cf8b5e5.png" alt="image"></p><p>#### ถาม: Query ใช้ดัชนีเป็นเลขจำนวนเต็มอย่างไร?</p><p>ดัชนีเริ่มต้นของ Query คือ Key แบบสตริง: A,B,C.... หากต้องการเปลี่ยนเป็นดัชนีตัวเลข กรุณาสร้างเมธอดต่อไปนี้เพื่อแปลง</p><pre><code class="language-csharp">void Main()
{
    var path = @"D:\git\MiniExcel\samples\xlsx\TestTypeMapping.xlsx";
    var rows = MiniExcel.Query(path,true);
    foreach (var r in ConvertToIntIndexRows(rows))
    {
        Console.Write($"column 0 : {r[0]} ,column 1 : {r[1]}");
        Console.WriteLine();
    }
}</p><p>private IEnumerable<Dictionary<int, object>> ConvertToIntIndexRows(IEnumerable<object> rows)
{
    ICollection<string> keys = null;
    var isFirst = true;
    foreach (IDictionary<string,object> r in rows)
    {
        if(isFirst)
        {
            keys = r.Keys;
            isFirst = false;
        }</p><p>        var dic = new Dictionary<int, object>();
        var index = 0;
        foreach (var key in keys)
            dic[index++] = r[key];
        yield return dic;
    }
}</code></pre>
#### ถาม: ไม่มีหัวข้อและไฟล์ Excel ว่างถูกสร้างขึ้นเมื่อค่าที่ส่งออกเป็นค่าว่าง</p><p>เนื่องจาก MiniExcel ใช้ตรรกะที่คล้ายกับ JSON.NET ในการดึงชนิดข้อมูลจากค่าต่างๆ แบบไดนามิกเพื่อให้ง่ายต่อการใช้งาน API จึงไม่สามารถทราบชนิดข้อมูลได้หากไม่มีข้อมูล คุณสามารถดู <a href="https://github.com/mini-software/MiniExcel/issues/133" target="_blank" rel="noopener noreferrer">issue #133</a> เพื่อทำความเข้าใจเพิ่มเติม</p><p><img src="https://user-images.githubusercontent.com/12729184/122639771-546c0c00-d12e-11eb-800c-498db27889ca.png" alt="image"></p><blockquote>ชนิดข้อมูลแบบระบุแน่นอน & DataTable จะสร้างหัวข้อคอลัมน์ แต่ Dictionary จะยังคงเป็น Excel ว่างเปล่า</blockquote></p><p>#### ถาม: จะหยุด foreach เมื่อเจอแถวว่างได้อย่างไร?</p><p>MiniExcel สามารถใช้ร่วมกับ </code>LINQ TakeWhile<code> เพื่อหยุดการวนลูป foreach</p><p><img src="https://user-images.githubusercontent.com/12729184/130209137-162621c2-f337-4479-9996-beeac65bc4d4.png" alt="Image"></p><p>#### ถาม: จะลบแถวว่างได้อย่างไร?</p><p><img src="https://user-images.githubusercontent.com/12729184/137873865-7107d8f5-eb59-42db-903a-44e80589f1b2.png" alt="image"></p><p>
IEnumerable :</p><pre><code class="language-csharp">public static IEnumerable<dynamic> QueryWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary<string,object> row in rows)
    {
        if(row.Keys.Any(key=>row[key]!=null))
            yield return row;
    }
}</code></pre></p><p>ตารางข้อมูล :</p><pre><code class="language-csharp">public static DataTable QueryAsDataTableWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    if (sheetName == null && excelType != ExcelType.CSV) /<em>Issue #279</em>/
        sheetName = stream.GetSheetNames().First();</p><p>    var dt = new DataTable(sheetName);
    var first = true;
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary<string, object> row in rows)
    {
        if (first)
        {</p><p>            foreach (var key in row.Keys)
            {
                var column = new DataColumn(key, typeof(object)) { Caption = key };
                dt.Columns.Add(column);
            }</p><p>            dt.BeginLoadData();
            first = false;
        }</p><p>        var newRow = dt.NewRow();
        var isNull=true;
        foreach (var key in row.Keys)
        {
            var _v = row[key];
            if(_v!=null)
                isNull = false;
            newRow[key] = _v;
        }</p><p>        if(!isNull)
            dt.Rows.Add(newRow);
    }</p><p>    dt.EndLoadData();
    return dt;
}</code></pre></p><p>
#### ถาม: จะใช้ SaveAs(path,value) เพื่อแทนที่ไฟล์ที่มีอยู่โดยไม่ให้เกิดข้อผิดพลาด "The file ...xlsx already exists error" ได้อย่างไร</p><p>
โปรดใช้คลาส Stream เพื่อปรับแต่งตรรกะการสร้างไฟล์ เช่น:</p><p>
</code>`<code>C#
    using (var stream = File.Create("Demo.xlsx"))
        MiniExcel.SaveAs(stream,value);
<pre><code class="language-">หรือ ตั้งแต่เวอร์ชัน V1.25.0 ฟังก์ชัน SaveAs รองรับพารามิเตอร์ overwriteFile เพื่อเปิดหรือปิดการเขียนทับไฟล์ที่มีอยู่</p><p></code></pre>csharp
    MiniExcel.SaveAs(path, value, overwriteFile: true);
</code>``</p><h3>ข้อจำกัดและข้อควรระวัง</h3></p><ul><li>ขณะนี้ยังไม่รองรับไฟล์ xls และไฟล์ที่ถูกเข้ารหัส</li>
<li>xlsm รองรับเฉพาะ Query</li></p><p></ul><h3>อ้างอิง</h3></p><p><a href="https://github.com/ExcelDataReader/ExcelDataReader" target="_blank" rel="noopener noreferrer">ExcelDataReader</a>  / <a href="https://github.com/ClosedXML/ClosedXML" target="_blank" rel="noopener noreferrer">ClosedXML</a> / <a href="https://github.com/DapperLib/Dapper" target="_blank" rel="noopener noreferrer">Dapper</a> / <a href="https://github.com/andersnm/ExcelNumberFormat" target="_blank" rel="noopener noreferrer">ExcelNumberFormat</a></p><h3>ขอบคุณ</h3></p><p>####  <a href="https://www.jetbrains.com/" target="_blank" rel="noopener noreferrer">Jetbrains</a></p><p><img src="https://user-images.githubusercontent.com/12729184/123997015-8456c180-da02-11eb-829a-aec476fe8e94.png" alt="jetbrains-variant-2"></p><p>ขอขอบคุณสำหรับการสนับสนุน IDE สำหรับผลิตภัณฑ์ทั้งหมดให้ใช้งานฟรีกับโปรเจกต์นี้ (<a href="https://user-images.githubusercontent.com/12729184/123988233-6ab17c00-d9fa-11eb-8739-2a08c6a4a263.png" target="_blank" rel="noopener noreferrer">License</a>)</p><h3>การแบ่งปันเพื่อสนับสนุนโครงการ</h3>
ลิงก์ https://github.com/orgs/mini-software/discussions/754</p><h3>ผู้ร่วมสนับสนุนโครงการ</h3></p><p><img src="https://contrib.rocks/image?repo=mini-software/MiniExcel" alt=""></p><p>

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-10-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/mini-software/MiniExcel/master/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-10-09 
    </div>
    
</body>
</html>