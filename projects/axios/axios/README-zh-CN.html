<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>axios - Read axios documentation in Simplified Chinese. This project has 107145 stars on GitHub.</title>
    <meta name="description" content="Read axios documentation in Simplified Chinese. This project has 107145 stars on GitHub.">
    <meta name="keywords" content="axios, Simplified Chinese, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "axios",
  "description": "Read axios documentation in Simplified Chinese. This project has 107145 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "axios"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 107145
  },
  "url": "https://OpenAiTx.github.io/projects/axios/axios/README-zh-CN.html",
  "sameAs": "https://raw.githubusercontent.com/axios/axios/v1.x/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    axios
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 107145 stars</span>
                <span class="language">Simplified Chinese</span>
                <span>by axios</span>
            </div>
        </div>
        
        <div class="content">
            <p><h3 align="center"> 🥇 金牌赞助商 <br> </h3> <table align="center" width="100%"><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="38px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/stytch_white.png"> <img width="200px" height="38px" src="https://axios-http.com/assets/sponsors/stytch.png" alt="Stytch"/> </picture> </a> <p align="center" title="API-first authentication, authorization, and fraud prevention">API优先的认证、授权和防欺诈</p> <p align="center"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http"><b>官网</b></a> | <a href="https://stytch.com/docs?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;docs-link&amp;utm_campaign&#x3D;axios-http"><b>文档</b></a> | <a href="https://github.com/stytchauth/stytch-node?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;node-sdk&amp;utm_campaign&#x3D;axios-http"><b>Node.js</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="133px" height="43px" src="https://axios-http.com/assets/sponsors/principal.svg" alt="Principal Financial Group"/> </a> <p align="center" title="We’re bound by one common purpose: to give you the financial tools, resources and information you need to live your best life.">我们有一个共同的目标：为您提供实现美好生活所需的金融工具、资源和信息。</p> <p align="center"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.principal.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="85px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buy-instagram-followers-twicsy.png" alt="Buy Instagram Followers Twicsy"/> </a> <p align="center" title="Buy real Instagram followers from Twicsy starting at only $2.97. Twicsy has been voted the best site to buy followers from the likes of US Magazine.">在Twicsy，购买真实Instagram粉丝仅需$2.97起。Twicsy被《US Magazine》等评为最佳粉丝购买网站。</p> <p align="center"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>twicsy.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="52px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/descope_white.png"> <img width="200px" height="52px" src="https://axios-http.com/assets/sponsors/descope.png" alt="Descope"/> </picture> </a> <p align="center" title="Hi, we&#x27;re Descope! We are building something in the authentication space for app developers and can’t wait to place it in your hands.">你好，我们是Descope！我们正在为应用开发者打造认证领域的新产品，期待早日与您见面。</p> <p align="center"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>官网</b></a> | <a href="https://docs.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>文档</b></a> | <a href="https://www.descope.com/community?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>社区</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="62px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buzzoid-buy-instagram-followers.png" alt="Buzzoid - Buy Instagram Followers"/> </a> <p align="center" title="At Buzzoid, you can buy Instagram followers quickly, safely, and easily with just a few clicks. Rated world&#x27;s #1 IG service since 2012.">在Buzzoid，您只需几步即可快速、安全、便捷地购买Instagram粉丝。自2012年以来被评为全球第一Instagram服务。</p> <p align="center"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>buzzoid.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/famety-buy-instagram-followers.png" alt="Famety - Buy Instagram Followers"/> </a> <p align="center" title="At Famety, you can grow your social media following quickly, safely, and easily with just a few clicks. Rated the world’s #1 social media service since 2013.">在Famety，您只需几步即可快速、安全、便捷地增长社交媒体粉丝。自2013年以来被评为全球第一社交媒体服务。</p> <p align="center"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.famety.net</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/instagram-likes.png" alt="Poprey - Buy Instagram Likes"/> </a> <p align="center" title="Buy Instagram Likes">购买Instagram点赞</p> <p align="center"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>poprey.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/youtube-subscribers-ssmarket.png" alt="Buy Youtube Subscribers"/> </a> <p align="center" title="SS Market offers professional social media services that rapidly increase your YouTube subscriber count, elevating your channel to a powerful position.">SS Market 提供专业社交媒体服务，帮助您的YouTube订阅数快速增长，使您的频道更加强大。</p> <p align="center"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>ssmarket.net</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="200px" height="56px" src="https://axios-http.com/assets/sponsors/opencollective/smmpanelserver123.png" alt="smmpanelserver"/> </a> <p align="center" title="smmpanelserver - Best and Cheapest Smm Panel">smmpanelserver - 最优质且最便宜的SMM面板</p> <p align="center"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>smmpanelserver.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成为赞助商</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成为赞助商</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成为赞助商</a>
</td></tr></table></p><p><!--<div>marker</div>-->
<br><br>
<div align="center">
   <a href="https://axios-http.com"><img src="https://axios-http.com/assets/logo.svg" /></a><br>
</div></p><p><p align="center">基于Promise的浏览器和Node.js HTTP客户端</p></p><p><p align="center">
    <a href="https://axios-http.com/"><b>官网</b></a> •
    <a href="https://axios-http.com/docs/intro"><b>文档</b></a>
</p></p><p><div align="center"></p><p><a href="https://www.npmjs.org/package/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/axios.svg?style=flat-square" alt="npm version"></a>
<a href="https://cdnjs.com/libraries/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/cdnjs/v/axios.svg?style=flat-square" alt="CDNJS"></a>
<a href="https://github.com/axios/axios/actions/workflows/ci.yml" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/actions/workflow/status/axios/axios/ci.yml?branch=v1.x&label=CI&logo=github&style=flat-square" alt="Build status"></a>
<a href="https://gitpod.io/#https://github.com/axios/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&style=flat-square" alt="Gitpod Ready-to-Code"></a>
<a href="https://coveralls.io/r/mzabriskie/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" alt="code coverage"></a>
<a href="https://packagephobia.now.sh/result?p=axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/dynamic/json?url=https://packagephobia.com/v2/api.json?p=axios&query=$.install.pretty&label=install%20size&style=flat-square" alt="install size"></a>
<a href="https://bundlephobia.com/package/axios@latest" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/bundlephobia/minzip/axios?style=flat-square" alt="npm bundle size"></a>
<a href="https://npm-stat.com/charts.html?package=axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/dm/axios.svg?style=flat-square" alt="npm downloads"></a>
<a href="https://gitter.im/mzabriskie/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square" alt="gitter chat"></a>
<a href="https://www.codetriage.com/axios/axios" target="_blank" rel="noopener noreferrer"><img src="https://www.codetriage.com/axios/axios/badges/users.svg" alt="code helpers"></a>
<a href="https://snyk.io/test/npm/axios" target="_blank" rel="noopener noreferrer"><img src="https://snyk.io/test/npm/axios/badge.svg" alt="Known Vulnerabilities"></a></p><p>
</div></p><h2>目录</h2></p><ul><li><a href="#features" target="_blank" rel="noopener noreferrer">功能特性</a></li>
  <li><a href="#browser-support" target="_blank" rel="noopener noreferrer">浏览器支持</a></li>
  <li><a href="#installing" target="_blank" rel="noopener noreferrer">安装</a></li>
    <li><a href="#package-manager" target="_blank" rel="noopener noreferrer">包管理器</a></li>
    <li><a href="#cdn" target="_blank" rel="noopener noreferrer">CDN</a></li>
  <li><a href="#example" target="_blank" rel="noopener noreferrer">示例</a></li>
  <li><a href="#axios-api" target="_blank" rel="noopener noreferrer">Axios API</a></li>
  <li><a href="#request-method-aliases" target="_blank" rel="noopener noreferrer">请求方法别名</a></li>
  <li><a href="#concurrency-deprecated" target="_blank" rel="noopener noreferrer">并发 👎</a></li>
  <li><a href="#creating-an-instance" target="_blank" rel="noopener noreferrer">创建实例</a></li>
  <li><a href="#instance-methods" target="_blank" rel="noopener noreferrer">实例方法</a></li>
  <li><a href="#request-config" target="_blank" rel="noopener noreferrer">请求配置</a></li>
  <li><a href="#response-schema" target="_blank" rel="noopener noreferrer">响应结构</a></li>
  <li><a href="#config-defaults" target="_blank" rel="noopener noreferrer">配置默认值</a></li>
    <li><a href="#global-axios-defaults" target="_blank" rel="noopener noreferrer">全局axios默认值</a></li>
    <li><a href="#custom-instance-defaults" target="_blank" rel="noopener noreferrer">自定义实例默认值</a></li>
    <li><a href="#config-order-of-precedence" target="_blank" rel="noopener noreferrer">配置优先级顺序</a></li>
  <li><a href="#interceptors" target="_blank" rel="noopener noreferrer">拦截器</a></li>
    <li><a href="#multiple-interceptors" target="_blank" rel="noopener noreferrer">多重拦截器</a></li>
  <li><a href="#handling-errors" target="_blank" rel="noopener noreferrer">错误处理</a></li>
  <li><a href="#cancellation" target="_blank" rel="noopener noreferrer">取消请求</a></li>
    <li><a href="#abortcontroller" target="_blank" rel="noopener noreferrer">AbortController</a></li>
    <li><a href="#canceltoken-deprecated" target="_blank" rel="noopener noreferrer">CancelToken 👎</a></li>
  <li><a href="#using-applicationx-www-form-urlencoded-format" target="_blank" rel="noopener noreferrer">使用application/x-www-form-urlencoded格式</a></li>
    <li><a href="#urlsearchparams" target="_blank" rel="noopener noreferrer">URLSearchParams</a></li>
    <li><a href="#query-string-older-browsers" target="_blank" rel="noopener noreferrer">查询字符串</a></li>
    <li><a href="#-automatic-serialization-to-urlsearchparams" target="_blank" rel="noopener noreferrer">🆕 自动序列化</a></li>
  <li><a href="#using-multipartform-data-format" target="_blank" rel="noopener noreferrer">使用multipart/form-data格式</a></li>
    <li><a href="#formdata" target="_blank" rel="noopener noreferrer">FormData</a></li>
    <li><a href="#-automatic-serialization-to-formdata" target="_blank" rel="noopener noreferrer">🆕 自动序列化</a></li>
  <li><a href="#files-posting" target="_blank" rel="noopener noreferrer">文件上传</a></li>
  <li><a href="#-html-form-posting-browser" target="_blank" rel="noopener noreferrer">HTML表单提交</a></li>
  <li><a href="#-progress-capturing" target="_blank" rel="noopener noreferrer">🆕 进度捕获</a></li>
  <li><a href="#-progress-capturing" target="_blank" rel="noopener noreferrer">🆕 限速</a></li>
  <li><a href="#-axiosheaders" target="_blank" rel="noopener noreferrer">🆕 AxiosHeaders</a></li>
  <li><a href="#-fetch-adapter" target="_blank" rel="noopener noreferrer">🔥 Fetch适配器</a></li>
  <li><a href="#semver" target="_blank" rel="noopener noreferrer">语义化版本</a></li>
  <li><a href="#promises" target="_blank" rel="noopener noreferrer">Promise</a></li>
  <li><a href="#typescript" target="_blank" rel="noopener noreferrer">TypeScript</a></li>
  <li><a href="#resources" target="_blank" rel="noopener noreferrer">资源</a></li>
  <li><a href="#credits" target="_blank" rel="noopener noreferrer">致谢</a></li>
  <li><a href="#license" target="_blank" rel="noopener noreferrer">许可证</a></li></p><p></ul><h2>功能特性</h2></p><ul><li>在浏览器中发起 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XMLHttpRequests</a></li>
<li>在Node.js中发起 <a href="https://nodejs.org/api/http.html" target="_blank" rel="noopener noreferrer">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li><a href="https://www.json.org/json-en.html" target="_blank" rel="noopener noreferrer">JSON</a> 数据的自动转换</li>
<li>🆕 数据对象自动序列化为 <code>multipart/form-data</code> 和 <code>x-www-form-urlencoded</code> 请求体编码</li>
<li>客户端支持防护 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener noreferrer">XSRF</a> 攻击</li></p><p></ul><h2>浏览器支持</h2></p><p><img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_48x48.png" alt="Chrome"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_48x48.png" alt="Firefox"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_48x48.png" alt="Safari"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/opera/opera_48x48.png" alt="Opera"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_48x48.png" alt="Edge"> |
--- | --- | --- | --- | --- |
最新 ✔ | 最新 ✔ | 最新 ✔ | 最新 ✔ | 最新 ✔ | 11 ✔ |</p><p><a href="https://saucelabs.com/u/axios" target="_blank" rel="noopener noreferrer"><img src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" alt="Browser Matrix"></a></p><h2>安装</h2></p><h3>包管理器</h3></p><p>使用 npm:</p><pre><code class="language-bash">$ npm install axios</code></pre></p><p>使用 bower:</p><pre><code class="language-bash">$ bower install axios</code></pre></p><p>使用 yarn:</p><pre><code class="language-bash">$ yarn add axios</code></pre></p><p>使用 pnpm:</p><pre><code class="language-bash">$ pnpm add axios</code></pre></p><p>使用 bun:</p><pre><code class="language-bash">$ bun add axios</code></pre></p><p>安装包后，你可以使用 <code>import</code> 或 <code>require</code> 的方式导入该库：</p><pre><code class="language-js">import axios, {isCancel, AxiosError} from 'axios';</code></pre></p><p>你也可以使用默认导出，因为具名导出只是 Axios 工厂的再导出：</p><pre><code class="language-js">import axios from 'axios';</p><p>console.log(axios.isCancel('something'));</code></pre></p><p>如果你使用 <code>require</code> 进行导入，<strong>仅支持默认导出</strong>：</p><pre><code class="language-js">const axios = require('axios');</p><p>console.log(axios.isCancel('something'));</code></pre></p><p>对于某些打包工具和某些 ES6 语法检查器，你可能需要如下方式：</p><pre><code class="language-js">import { default as axios } from 'axios';</code></pre></p><p>如果在自定义或遗留环境中导入模块时遇到问题，
你可以尝试直接导入模块包：</p><pre><code class="language-js">const axios = require('axios/dist/browser/axios.cjs'); // 浏览器 commonJS 包（ES2017）
// const axios = require('axios/dist/node/axios.cjs'); // node commonJS 包（ES2017）</code></pre></p><h3>CDN</h3></p><p>使用 jsDelivr CDN（ES5 UMD 浏览器模块）:</p><pre><code class="language-html"><script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script></code></pre></p><p>使用 unpkg CDN:</p><pre><code class="language-html"><script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script></code></pre></p><h2>示例</h2></p><blockquote><strong>注意</strong>: CommonJS 用法  </blockquote>
<blockquote>为了在使用 CommonJS 的 <code>require()</code> 导入方式时获得 TypeScript 类型（用于智能提示/自动补全），请使用以下方式：</blockquote>
<pre><code class="language-js">import axios from 'axios';
//const axios = require('axios'); // 传统方式</p><p>// 为指定 ID 的用户发起请求
axios.get('/user?ID=12345')
  .then(function (response) {
    // 处理成功情况
    console.log(response);
  })
  .catch(function (error) {
    // 处理错误情况
    console.log(error);
  })
  .finally(function () {
    // 总会执行
  });</p><p>// 上述请求也可以这样写
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // 总会执行
  });</p><p>// 想用 async/await？请在外部函数/方法添加 <code>async</code> 关键字。
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}</code></pre></p><blockquote><strong>注意</strong>：<code>async/await</code> 是 ECMAScript 2017 的一部分，不被 Internet Explorer 和旧版浏览器支持，请谨慎使用。</blockquote></p><p>执行 <code>POST</code> 请求</p><pre><code class="language-js">axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });</code></pre></p><p>执行多个并发请求</p><pre><code class="language-js">function getUserAccount() {
  return axios.get('/user/12345');
}</p><p>function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}</p><p>Promise.all([getUserAccount(), getUserPermissions()])
  .then(function (results) {
    const acct = results[0];
    const perm = results[1];
  });</code></pre></p><h2>axios API</h2></p><p>可以通过传递相关配置给 <code>axios</code> 发起请求。</p><p>##### axios(config)</p><pre><code class="language-js">// 发送一个 POST 请求
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});</code></pre></p><pre><code class="language-js">// 在 node.js 中对远程图片发起 GET 请求
axios({
  method: 'get',
  url: 'https://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });</code></pre></p><p>##### axios(url[, config])</p><pre><code class="language-js">// 发送一个 GET 请求（默认方法）
axios('/user/12345');</code></pre></p><h3>请求方法别名</h3></p><p>为了方便，所有常用请求方法都提供了别名。</p><p>##### axios.request(config)
##### axios.get(url[, config])
##### axios.delete(url[, config])
##### axios.head(url[, config])
##### axios.options(url[, config])
##### axios.post(url[, data[, config]])
##### axios.put(url[, data[, config]])
##### axios.patch(url[, data[, config]])</p><p>###### 注意
当使用别名方法时，<code>url</code>、<code>method</code> 和 <code>data</code> 属性无需在 config 中指定。</p><h3>并发请求（已弃用）</h3>
请使用 <code>Promise.all</code> 替代以下功能函数。</p><p>用于处理并发请求的辅助函数。</p><p>axios.all(iterable)
axios.spread(callback)</p><h3>创建实例</h3></p><p>你可以通过自定义配置创建一个新的 axios 实例。</p><p>##### axios.create([config])</p><pre><code class="language-js">const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});</code></pre></p><h3>实例方法</h3></p><p>可用的实例方法如下所列。指定的 config 会与实例的 config 合并。</p><p>##### axios#request(config)
##### axios#get(url[, config])
##### axios#delete(url[, config])
##### axios#head(url[, config])
##### axios#options(url[, config])
##### axios#post(url[, data[, config]])
##### axios#put(url[, data[, config]])
##### axios#patch(url[, data[, config]])
##### axios#getUri([config])</p><h2>请求配置</h2></p><p>以下是可用于发起请求的配置选项。只有 <code>url</code> 是必需的。如果未指定 <code>method</code>，请求默认使用 <code>GET</code>。</p><pre><code class="language-js">{
  // <code>url</code> 是用于请求的服务器 URL
  url: '/user',</p><p>  // <code>method</code> 是请求时使用的 HTTP 方法
  method: 'get', // 默认</p><p>  // <code>baseURL</code> 会被加在 <code>url</code> 前，除非 <code>url</code> 是绝对路径且选项 <code>allowAbsoluteUrls</code> 设置为 true。
  // 为 axios 的实例设置 <code>baseURL</code>，可以方便地传递相对 URL 给该实例的方法。
  baseURL: 'https://some-domain.com/api/',</p><p>  // <code>allowAbsoluteUrls</code> 决定绝对 URL 是否会覆盖已配置的 <code>baseUrl</code>。
  // 设置为 true（默认）时，<code>url</code> 的绝对值会覆盖 <code>baseUrl</code>。
  // 设置为 false 时，<code>url</code> 的绝对值总会被 <code>baseUrl</code> 作为前缀。
  allowAbsoluteUrls: true,</p><p>  // <code>transformRequest</code> 允许在请求发送到服务器之前修改请求数据
  // 仅适用于 'PUT'、'POST'、'PATCH' 和 'DELETE' 方法
  // 数组中的最后一个函数必须返回字符串或 Buffer、ArrayBuffer、
  // FormData 或 Stream 的实例
  // 你可以修改 headers 对象。
  transformRequest: [function (data, headers) {
    // 按需转换数据</code></pre>
<pre><code class="language-markdown">    return data;
  }],</p><p>  // <code>transformResponse</code> 允许在响应数据传递到 then/catch 之前对其进行更改
  transformResponse: [function (data) {
    // 可以对数据进行任意转换</p><p>    return data;
  }],</p><p>  // <code>headers</code> 是要发送的自定义请求头
  headers: {'X-Requested-With': 'XMLHttpRequest'},</p><p>  // <code>params</code> 是随请求一起发送的 URL 参数
  // 必须为普通对象或 URLSearchParams 对象
  params: {
    ID: 12345
  },
  
  // <code>paramsSerializer</code> 是一个可选配置，允许你自定义 <code>params</code> 的序列化方式。
  paramsSerializer: {</p><p>    // 自定义编码器函数，按迭代方式发送键/值对。
    encode?: (param: string): string => { /<em> 在这里进行自定义操作并返回转换后的字符串 </em>/ }, 
    
    // 对整个参数进行自定义序列化的函数。允许用户模拟 1.x 之前的行为。
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    // 配置参数中数组索引的格式化方式。
    indexes: false // 三种可选方式：(1) indexes: null（无括号），(2)（默认）indexes: false（空括号），(3) indexes: true（带索引的括号）。
  },</p><p>  // <code>data</code> 是作为请求体发送的数据
  // 仅适用于 'PUT'、'POST'、'DELETE' 和 'PATCH' 请求方法
  // 当未设置 <code>transformRequest</code> 时，必须为以下类型之一：
  // - 字符串、普通对象、ArrayBuffer、ArrayBufferView、URLSearchParams
  // - 仅浏览器：FormData、File、Blob
  // - 仅 Node：Stream、Buffer、FormData（form-data 包）
  data: {
    firstName: 'Fred'
  },</p><p>  // 发送数据到请求体的语法替代方式
  // post 方法
  // 只发送值，不发送键
  data: 'Country=Brasil&City=Belo Horizonte',</p><p>  // <code>timeout</code> 指定请求超时前的毫秒数
  // 如果请求超出 <code>timeout</code> 时间，请求会被中止
  timeout: 1000, // 默认值为 <code>0</code>（无超时）</p><p>  // <code>withCredentials</code> 指示是否应使用凭证进行跨站点的访问控制请求
  withCredentials: false, // 默认值</p><p>  // <code>adapter</code> 允许自定义请求处理，使测试更加容易。
  // 返回一个 promise 并提供一个有效的响应（参见 lib/adapters/README.md）
  adapter: function (config) {
    /<em> ... </em>/
  },
  // 你也可以设置内置适配器的名称，或者提供一个包含名称的数组
  // 以便在环境中选择第一个可用的
  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']</p><p>  // <code>auth</code> 表示应使用 HTTP Basic 认证，并提供凭据。
  // 这将设置一个 <code>Authorization</code> 请求头，覆盖你通过 <code>headers</code> 设置的任何已有
  // <code>Authorization</code> 自定义请求头。
  // 请注意，通过此参数仅可配置 HTTP Basic 认证。
  // 对于 Bearer 等令牌，请使用 <code>Authorization</code> 自定义请求头。
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },</p><p>  // <code>responseType</code> 指示服务器响应的数据类型
  // 可选项为：'arraybuffer'、'document'、'json'、'text'、'stream'
  //   仅浏览器：'blob'
  responseType: 'json', // 默认值</p><p>  // <code>responseEncoding</code> 指定用于解码响应的编码（仅限 Node.js）
  // 注意：对于 <code>responseType</code> 为 'stream' 或客户端请求时会被忽略
  // 可选项为：'ascii'、'ASCII'、'ansi'、'ANSI'、'binary'、'BINARY'、'base64'、'BASE64'、'base64url'、
  // 'BASE64URL'、'hex'、'HEX'、'latin1'、'LATIN1'、'ucs-2'、'UCS-2'、'ucs2'、'UCS2'、'utf-8'、'UTF-8'、
  // 'utf8'、'UTF8'、'utf16le'、'UTF16LE'
  responseEncoding: 'utf8', // 默认值</p><p>  // <code>xsrfCookieName</code> 用作 xsrf token 值的 cookie 名称
  xsrfCookieName: 'XSRF-TOKEN', // 默认值</p><p>  // <code>xsrfHeaderName</code> 承载 xsrf token 值的 http 头名称
  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值
    
  // <code>undefined</code>（默认）- 仅对同源请求设置 XSRF 头
  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),</p><p>  // <code>onUploadProgress</code> 允许处理上传的进度事件
  // 浏览器 & node.js
  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {</code></pre>
<pre><code class="language-markdown">    // 可以对 Axios 的进度事件执行任何操作
  },</p><p>  // <code>onDownloadProgress</code> 允许处理下载的进度事件
  // 浏览器 & node.js
  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {
    // 可以对 Axios 的进度事件执行任何操作
  },</p><p>  // <code>maxContentLength</code> 定义在 node.js 中允许的 HTTP 响应内容最大字节数
  maxContentLength: 2000,</p><p>  // <code>maxBodyLength</code>（仅 Node 选项）定义在 node.js 中允许的 HTTP 请求内容最大字节数
  maxBodyLength: 2000,</p><p>  // <code>validateStatus</code> 定义是否针对给定的 HTTP 响应状态码 resolve 或 reject promise。
  // 如果 <code>validateStatus</code> 返回 <code>true</code>（或设置为 <code>null</code> 或 <code>undefined</code>），promise 会被 resolve；
  // 否则，promise 会被 reject。
  validateStatus: function (status) {
    return status >= 200 && status < 300; // 默认值
  },</p><p>  // <code>maxRedirects</code> 定义在 node.js 中允许跟随的最大重定向次数。
  // 如果设置为 0，则不跟随重定向。
  maxRedirects: 21, // 默认值</p><p>  // <code>beforeRedirect</code> 定义一个在重定向前调用的函数。
  // 可用于在重定向时调整请求选项，
  // 检查最新的响应头，
  // 或通过抛出错误来取消请求
  // 如果 maxRedirects 设置为 0，则不会使用 <code>beforeRedirect</code>。
  beforeRedirect: (options, { headers }) => {
    if (options.hostname === "example.com") {
      options.auth = "user:password";
    }
  },</p><p>  // <code>socketPath</code> 定义 node.js 中要使用的 UNIX Socket。
  // 例如：'/var/run/docker.sock' 用于向 docker 守护进程发送请求。
  // 只能指定 <code>socketPath</code> 或 <code>proxy</code> 之一。
  // 如果两者都指定，则使用 <code>socketPath</code>。
  socketPath: null, // 默认值
  
  // <code>transport</code> 决定用于发起请求的传输方式。
  // 如果定义了，则会被使用。否则，如果 <code>maxRedirects</code> 为 0，
  // 则会根据 <code>protocol</code> 指定的协议，使用默认的 <code>http</code> 或 <code>https</code> 库。
  // 否则，根据协议，会使用可以处理重定向的 <code>httpFollow</code> 或 <code>httpsFollow</code> 库。
  transport: undefined, // 默认值</p><p>  // <code>httpAgent</code> 和 <code>httpsAgent</code> 定义在 node.js 中执行 http 和 https 请求时使用的自定义 agent。
  // 这允许添加如 <code>keepAlive</code> 等在 Node.js v19.0.0 之前默认未启用的选项。
  // 在 Node.js v19.0.0 之后，不再需要自定义 agent 来启用 <code>keepAlive</code>，
  // 因为 <code>http.globalAgent</code> 默认已启用 <code>keepAlive</code>。
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),</p><p>  // <code>proxy</code> 定义代理服务器的主机名、端口和协议。
  // 你也可以使用常规的 <code>http_proxy</code> 和 <code>https_proxy</code> 环境变量来定义代理。
  // 如果你使用环境变量进行代理配置，也可以定义 <code>no_proxy</code> 环境变量，
  // 其值为不应使用代理的域名（用逗号分隔）。
  // 使用 <code>false</code> 可以禁用代理，忽略环境变量。
  // <code>auth</code> 表示应使用 HTTP Basic 认证连接到代理，并提供凭据。
  // 这将设置 <code>Proxy-Authorization</code> 头，覆盖你通过 <code>headers</code> 设置的任何自定义
  // <code>Proxy-Authorization</code> 头。
  // 如果代理服务器使用 HTTPS，则必须将协议设置为 <code>https</code>。
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    // hostname: '127.0.0.1' // 如果同时定义，则优先使用 'hostname'
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },</p><p>  // <code>cancelToken</code> 指定一个取消令牌，可用于取消请求
  //（详见下文的取消部分）
  cancelToken: new CancelToken(function (cancel) {
  }),</p><p>  // 使用 AbortController 取消 Axios 请求的另一种方式
  signal: new AbortController().signal,</p><p>  // <code>decompress</code> 指示是否自动解压响应体。
  // 如果设置为 <code>true</code>，还会从所有已解压响应的响应对象中移除 'content-encoding' 头
  // - 仅 Node（XHR 无法关闭解压）
  decompress: true, // 默认值</p><p>  // <code>insecureHTTPParser</code> 布尔值。
  // 指示是否使用接受无效 HTTP 头的非安全 HTTP 解析器。
  // 这可能允许与不兼容的 HTTP 实现进行互操作。
  // 应避免使用非安全解析器。
  // 选项详见 https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback</code></pre>
<pre><code class="language-js">  // 另请参见 https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none
  insecureHTTPParser: undefined, // 默认值</p><p>  // 兼容旧版本的过渡选项，可能会在新版本中移除
  transitional: {
    // 静默 JSON 解析模式
    // <code>true</code>  - 忽略 JSON 解析错误，如果解析失败则将 response.data 设为 null（旧行为）
    // <code>false</code> - 如果 JSON 解析失败则抛出 SyntaxError（注意：responseType 必须设置为 'json'）
    silentJSONParsing: true, // 当前 Axios 版本的默认值</p><p>    // 即使 <code>responseType</code> 不是 'json'，也尝试将响应字符串解析为 JSON
    forcedJSONParsing: true,</p><p>    // 在请求超时时抛出 ETIMEDOUT 错误，而不是通用的 ECONNABORTED
    clarifyTimeoutError: false,
  },</p><p>  env: {
    // 用于自动将负载序列化为 FormData 对象的 FormData 类
    FormData: window?.FormData || global?.FormData
  },</p><p>  formSerializer: {
      visitor: (value, key, path, helpers) => {}; // 自定义访问器函数，用于序列化表单值
      dots: boolean; // 使用点号而不是括号格式
      metaTokens: boolean; // 保留参数键中的特殊结尾，如 {}
      indexes: boolean; // 数组索引格式 null - 无括号，false - 空括号，true - 带索引的括号
  },</p><p>  // 仅限 http 适配器（node.js）
  maxRate: [
    100 * 1024, // 100KB/s 上传限速
    100 * 1024  // 100KB/s 下载限速
  ]
}</code></pre></p><h2>响应结构</h2></p><p>请求的响应包含以下信息。</p><pre><code class="language-js">{
  // <code>data</code> 是服务器返回的响应内容
  data: {},</p><p>  // <code>status</code> 是服务器响应的 HTTP 状态码
  status: 200,</p><p>  // <code>statusText</code> 是服务器响应的 HTTP 状态消息
  statusText: 'OK',</p><p>  // <code>headers</code> 是服务器响应的 HTTP 头信息
  // 所有头名称均为小写，可通过括号表示法访问。
  // 示例：<code>response.headers['content-type']</code>
  headers: {},</p><p>  // <code>config</code> 是为该请求提供给 <code>axios</code> 的配置
  config: {},</p><p>  // <code>request</code> 是生成该响应的请求
  // 在 node.js（重定向时）中是最后一个 ClientRequest 实例
  // 在浏览器中是 XMLHttpRequest 实例
  request: {}
}</code></pre></p><p>使用 <code>then</code> 时，你将以如下方式接收响应：</p><pre><code class="language-js">axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });</code></pre></p><p>使用 <code>catch</code>，或将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">拒绝回调</a> 作为 <code>then</code> 的第二个参数传递时，响应将通过 <code>error</code> 对象获取，详见 <a href="#handling-errors" target="_blank" rel="noopener noreferrer">错误处理</a> 部分。</p><h2>配置默认值</h2></p><p>你可以指定将应用于每个请求的配置默认值。</p><h3>全局 axios 默认值</h3></p><pre><code class="language-js">axios.defaults.baseURL = 'https://api.example.com';</p><p>// 重要提示：如果 axios 用于多个域名，AUTH_TOKEN 将会发送到所有域名。
// 参见下方自定义实例默认值的示例。
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;</p><p>axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';</code></pre></p><h3>自定义实例默认值</h3>
<pre><code class="language-">``<code>js
// 创建实例时设置配置默认值
const instance = axios.create({
  baseURL: 'https://api.example.com'
});</p><p>// 在实例创建后修改默认值
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;</code></pre></p><h3>配置优先级顺序</h3></p><p>配置将按照优先级顺序进行合并。顺序为：<a href="https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49" target="_blank" rel="noopener noreferrer">lib/defaults/index.js</a> 中库的默认值，然后是实例的 </code>defaults<code> 属性，最后是请求的 </code>config<code> 参数。后者会覆盖前者。以下是示例。</p><pre><code class="language-js">// 使用库提供的配置默认值创建实例
// 此时超时配置值为 </code>0<code>，这是库的默认值
const instance = axios.create();</p><p>// 覆盖库的超时默认值
// 现在所有使用此实例的请求将在超时前等待 2.5 秒
instance.defaults.timeout = 2500;</p><p>// 为该请求覆盖超时时间，因为已知该请求需要较长时间
instance.get('/longRequest', {
  timeout: 5000
});</code></pre></p><h2>拦截器</h2></p><p>你可以在 </code>then<code> 或 </code>catch<code> 处理请求或响应之前拦截它们。</p><pre><code class="language-js">
const instance = axios.create();</p><p>// 添加请求拦截器
instance.interceptors.request.use(function (config) {
    // 在请求发送之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });</p><p>// 添加响应拦截器
instance.interceptors.response.use(function (response) {
    // 任何 2xx 范围内的状态码都会触发该函数
    // 对响应数据做些什么
    return response;
  }, function (error) {
    // 任何超出 2xx 范围的状态码都会触发该函数
    // 对响应错误做些什么
    return Promise.reject(error);
  });</code></pre></p><p>如果你需要在之后移除拦截器，也可以做到。</p><pre><code class="language-js">const instance = axios.create();
const myInterceptor = instance.interceptors.request.use(function () {/<em>...</em>/});
axios.interceptors.request.eject(myInterceptor);</code></pre></p><p>你也可以清除所有请求或响应的拦截器。
<pre><code class="language-js">const instance = axios.create();
instance.interceptors.request.use(function () {/<em>...</em>/});
instance.interceptors.request.clear(); // 移除请求拦截器
instance.interceptors.response.use(function () {/<em>...</em>/});
instance.interceptors.response.clear(); // 移除响应拦截器</code></pre></p><p>你可以为 axios 的自定义实例添加拦截器。</p><pre><code class="language-js">const instance = axios.create();
instance.interceptors.request.use(function () {/<em>...</em>/});</code></pre></p><p>当你添加请求拦截器时，默认情况下它们被视为异步。这可能会在主线程被阻塞时导致 axios 请求执行延迟（拦截器底层会创建一个 promise，你的请求会被放到调用栈底部）。如果你的请求拦截器是同步的，你可以在选项对象中添加一个标志，告知 axios 以同步方式运行代码，从而避免请求执行的延迟。</p><pre><code class="language-js">axios.interceptors.request.use(function (config) {
  config.headers.test = 'I am only a header!';
  return config;
}, null, { synchronous: true });</code></pre></p><p>如果你想根据运行时检查执行特定拦截器，可以在选项对象中添加 </code>runWhen<code> 函数。<strong>只有当</strong> </code>runWhen<code> 返回 </code>false<code> 时，请求拦截器才不会被执行。该函数会接收 config 对象（你也可以绑定自己的参数）。当你有一个仅在特定时间需要运行的异步请求拦截器时，这非常有用。
<pre><code class="language-"></code>`<code>js
function onGetCall(config) {
  return config.method === 'get';
}
axios.interceptors.request.use(function (config) {
  config.headers.test = 'special get headers';
  return config;
}, null, { runWhen: onGetCall });</code></pre></p><blockquote><strong>注意：</strong> 目前，options 参数（包含 </code>synchronous<code> 和 </code>runWhen<code> 属性）仅支持请求拦截器。</blockquote></p><h3>多个拦截器</h3></p><p>假设你添加了多个响应拦截器，
当响应被成功处理时：
<ul><li>每个拦截器都会被执行</li>
<li>它们按照添加顺序依次执行</li>
<li>只有最后一个拦截器的结果会被返回</li>
<li>每个拦截器都会接收其前一个拦截器的结果</li>
<li>当 fulfillment-interceptor 抛出异常时</li>
    <li>后续的 fulfillment-interceptor 不会被调用</li>
    <li>后续的 rejection-interceptor 会被调用</li>
    <li>一旦被捕获，下一个 fulfill-interceptor 会再次被调用（就像在 promise 链中一样）。</li></p><p></ul>查看<a href="https://raw.githubusercontent.com/axios/axios/v1.x/./test/specs/interceptors.spec.js" target="_blank" rel="noopener noreferrer">拦截器测试代码</a>以了解所有相关实现。</p><h2>错误类型</h2></p><p>axios 可能会出现多种不同的错误信息，这些信息可以为错误的具体原因和调试提供基本信息。</p><p>axios 错误的一般结构如下：
| 属性      | 定义  |
| -------- | ----------  |
| message  | 错误信息的简要摘要以及失败的状态码。 |
| name     | 定义错误的来源。对于 axios，这里始终是 'AxiosError'。 |
| stack    | 提供错误的堆栈追踪。 | 
| config   | 一个 axios 配置对象，包含用户请求时定义的具体实例配置。 |
| code     | 表示 axios 识别的错误。下表列出了 axios 内部错误的具体定义。  |
| status   | HTTP 响应状态码。常见 HTTP 响应状态码的含义见<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener noreferrer">此处</a>。</p><p>以下是 axios 可能识别的错误列表：</p><p>| 代码                      | 定义                                                                                                                                                                                                                                                                                                                                                                                      |
| --- | --- |
| ERR_BAD_OPTION_VALUE      | 在 axios 配置中提供了无效的值。                                                                                                                                                                                                                                                                                                                                                           |
| ERR_BAD_OPTION            | 在 axios 配置中提供了无效的选项。                                                                                                                                                                                                                                                                                                                                                         |
| ERR_NOT_SUPPORT           | 当前 axios 环境下不支持的功能或方法。                                                                                                                                                                                                                                                                                                                                                      |
| ERR_DEPRECATED            | 使用了 axios 已废弃的功能或方法。                                                                                                                                                                                                                                                                                                                                                        |
| ERR_INVALID_URL           | 为 axios 请求提供了无效的 URL。                                                                                                                                                                                                                                                                                                                                                          |
| ECONNABORTED              | 通常表示请求超时（除非设置了 </code>transitional.clarifyTimeoutError<code>），或者被浏览器或其插件中止。                                                                                                                                                                                                                                                      |
| ERR_CANCELED              | 功能或方法被用户通过 AbortSignal（或 CancelToken）显式取消。                                                                                                                                                                                                                                                                                      |
| ETIMEDOUT                 | 请求因超出 axios 默认时间限制而超时。必须将 </code>transitional.clarifyTimeoutError<code> 设置为 </code>true<code>，否则会抛出通用的 </code>ECONNABORTED<code> 错误。                                                                                                                                                                                                               |
| ERR_NETWORK               | 与网络相关的问题。在浏览器中，该错误也可能由 <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/CORS" target="_blank" rel="noopener noreferrer">CORS</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content" target="_blank" rel="noopener noreferrer">混合内容</a> 策略违规引起。浏览器不会允许 JS 代码明确说明由安全问题引起的错误的真实原因，请检查控制台。                      |
| ERR_FR_TOO_MANY_REDIRECTS | 请求重定向次数过多，超过了 axios 配置中指定的最大重定向次数。                                                                                                                                                                                                                                                                                    |
| ERR_BAD_RESPONSE          | 响应无法被正确解析或格式不符合预期。通常与 </code>5xx<code> 状态码的响应相关。                                                                                                                                                                                                                                                                                 |
| ERR_BAD_REQUEST           | 请求格式异常或缺少必要参数。通常与 </code>4xx<code> 状态码的响应相关。                                                                                                                                                                                                                                                                                         |</p><h2>错误处理</h2></p><p>默认行为是拒绝所有返回状态码不在 2xx 范围内的响应，并将其视为错误。</p><pre><code class="language-js">axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // 请求已发出，服务器响应了状态码
      // 状态码超出了 2xx 范围
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // 请求已发出，但没有收到响应
      // </code>error.request<code> 在浏览器中是 XMLHttpRequest 的实例，在 node.js 中是 http.ClientRequest 的实例
      console.log(error.request);
    } else {
      // 请求设置过程中发生错误
      console.log('Error', error.message);
    }
    console.log(error.config);
  });</code></pre></p><p>通过使用 </code>validateStatus<code> 配置选项，你可以覆盖默认条件（status >= 200 && status < 300），自定义哪些 HTTP 状态码会抛出错误。</p><pre><code class="language-js">axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // 只有状态码小于 500 时才会被处理为成功
  }
})</code></pre></p><p>使用 </code>toJSON<code> 可以获得包含更多 HTTP 错误信息的对象。</p><pre><code class="language-js">axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());</code></pre>
<pre><code class="language-">
<h2>取消请求</h2></p><h3>AbortController</h3></p><p>从 </code>v0.22.0<code> 开始，Axios 支持使用 AbortController 以 fetch API 的方式取消请求：
</code></pre>js
const controller = new AbortController();</p><p>axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()
<pre><code class="language-">
<h3>CancelToken </code>👎已弃用<code></h3></p><p>你也可以使用 <em>CancelToken</em> 取消请求。</p><blockquote>axios 的 cancel token API 基于已撤回的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener noreferrer">cancellable promises proposal</a>。</blockquote></p><blockquote>此 API 从 v0.22.0 起已弃用，不建议在新项目中使用</blockquote></p><p>你可以像下面这样使用 </code>CancelToken.source<code> 工厂方法创建一个取消令牌：
</code></pre>js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();</p><p>axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('请求已取消', thrown.message);
  } else {
    // 处理错误
  }
});</p><p>axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})</p><p>// 取消请求（message 参数可选）
source.cancel('用户取消了操作。');
<pre><code class="language-">
你也可以通过向 </code>CancelToken<code> 构造函数传递一个执行器函数来创建取消令牌：
</code></pre>js
const CancelToken = axios.CancelToken;
let cancel;</p><p>axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // 执行器函数接收一个取消函数作为参数
    cancel = c;
  })
});</p><p>// 取消请求
cancel();
<pre><code class="language-">
<blockquote><strong>注意：</strong> 你可以使用相同的取消令牌/abort controller 取消多个请求。</blockquote>
<blockquote>如果在发起 Axios 请求时取消令牌已经处于已取消状态，则请求会立即被取消，不会尝试发起真正的请求。</blockquote></p><blockquote>在过渡期间，你可以同时使用这两种取消 API，甚至用于同一个请求：</blockquote></p><h2>使用 </code>application/x-www-form-urlencoded<code> 格式</h2></p><h3>URLSearchParams</h3></p><p>默认情况下，axios 会将 JavaScript 对象序列化为 </code>JSON<code>。如果你希望以 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener noreferrer"></code>application/x-www-form-urlencoded<code> 格式</a> 发送数据，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener noreferrer"></code>URLSearchParams<code></a> API，该 API 被绝大多数浏览器和 <a href="https://nodejs.org/api/url.html#url_class_urlsearchparams" target="_blank" rel="noopener noreferrer">Node</a>（从 v10，2018 年发布）<a href="http://www.caniuse.com/#feat=urlsearchparams" target="_blank" rel="noopener noreferrer">支持</a>。
</code></pre>js
const params = new URLSearchParams({ foo: 'bar' });
params.append('extraparam', 'value');
axios.post('/foo', params);
<pre><code class="language-">
<h3>查询字符串（老旧浏览器）</h3></p><p>为兼容非常老的浏览器，可以使用 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener noreferrer">polyfill</a>（确保为全局环境引入 polyfill）。</p><p>或者，你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"></code>qs<code></a> 库对数据进行编码：
</code></pre>js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
<pre><code class="language-"></code>`<code>
或者用另一种方式（ES6），
</code></pre>js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
<pre><code class="language-">
<h3>旧版 Node.js</h3></p><p>对于较旧的 Node.js 引擎，你可以按如下方式使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener noreferrer"></code>querystring<code></a> 模块：
</code></pre>js
const querystring = require('querystring');
axios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));
<pre><code class="language-">
你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"></code>qs<code></a> 库。</p><blockquote><strong>注意</strong>：如果你需要对嵌套对象进行字符串化，建议使用 </code>qs<code> 库，因为 </code>querystring<code> 方法在该用例下存在<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener noreferrer">已知问题</a>。</blockquote></p><h3>🆕 自动序列化为 URLSearchParams</h3></p><p>如果 </code>content-type<code> 头被设置为 "application/x-www-form-urlencoded"，Axios 会自动将 data 对象序列化为 urlencoded 格式。
</code></pre>js
const data = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
};</p><p>await axios.postForm('https://postman-echo.com/post', data,
  {headers: {'content-type': 'application/x-www-form-urlencoded'}}
);
<pre><code class="language-">
服务器将会这样处理：
</code></pre>js
  {
    x: '1',
    'arr[]': [ '1', '2', '3' ],
    'arr2[0]': '1',
    'arr2[1][0]': '2',
    'arr2[2]': '3',
    'arr3[]': [ '1', '2', '3' ],
    'users[0][name]': 'Peter',
    'users[0][surname]': 'griffin',
    'users[1][name]': 'Thomas',
    'users[1][surname]': 'Anderson'
  }
</code><pre><code class="language-">
如果你的后端 body-parser（如 <code>express.js</code> 的 <code>body-parser</code>）支持嵌套对象解码，你将在服务端自动获得相同的对象
</code></pre>js
  var app = express();</p><p>  app.use(bodyParser.urlencoded({ extended: true })); // 支持编码的请求体</p><p>  app.post('/', function (req, res, next) {
     // 以 JSON 形式回显请求体
     res.send(JSON.stringify(req.body));
  });</p><p>  server = app.listen(3000);
<pre><code class="language-">
<h2>使用 <code>multipart/form-data</code> 格式</h2></p><h3>FormData</h3></p><p>要以 <code>multipart/formdata</code> 方式发送数据，你需要传递一个 formData 实例作为载荷。
无需手动设置 <code>Content-Type</code> 头，Axios 会根据载荷类型自动判断。
</code></pre>js
const formData = new FormData();
formData.append('foo', 'bar');</p><p>axios.post('https://httpbin.org/post', formData);
<pre><code class="language-">
在 node.js 中，你可以按如下方式使用 <a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"><code>form-data</code></a> 库：
</code></pre>js
const FormData = require('form-data');</p><p>const form = new FormData();
form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
<pre><code class="language-">axios.post('https://example.com', form)</code></pre></p><h3>🆕 自动序列化为 FormData</h3></p><p>从 <code>v0.27.0</code> 开始，如果请求的 <code>Content-Type</code> 头被设置为 <code>multipart/form-data</code>，Axios 支持将对象自动序列化为 FormData 对象。</p><p>以下请求将以 FormData 格式提交数据（适用于浏览器和 Node.js）：</p><pre><code class="language-js">import axios from 'axios';</p><p>axios.post('https://httpbin.org/post', {x: 1}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));</code></pre></p><p>在 <code>node.js</code> 构建中，默认使用 (<a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"><code>form-data</code></a>) polyfill。</p><p>你可以通过设置 <code>env.FormData</code> 配置变量来重载 FormData 类，
但在大多数情况下你可能并不需要这样做：</p><pre><code class="language-js">const axios = require('axios');
var FormData = require('form-data');</p><p>axios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));</code></pre></p><p>Axios 的 FormData 序列化器支持一些特殊后缀以执行以下操作：</p><ul><li><code>{}</code> - 使用 JSON.stringify 序列化该值</li>
<li><code>[]</code> - 以相同的键名将类数组对象解包为多个字段</li></p><p></ul>> <strong>注意</strong>：数组和 FileList 对象默认会使用解包/展开操作</p><p>FormData 序列化器支持通过 <code>config.formSerializer: object</code> 属性传递额外选项，以处理特殊情况：</p><ul><li><code>visitor: Function</code> - 用户自定义的遍历函数，将按照自定义规则递归地将数据对象序列化为 <code>FormData</code> 对象。</li></p><p><li><code>dots: boolean = false</code> - 使用点号表示法而不是括号来序列化数组和对象；</li></p><p><li><code>metaTokens: boolean = true</code> - 在 FormData 的键名中添加特殊后缀（例如 <code>user{}: '{"name": "John"}'</code>）。后端的 body-parser 可能会利用此元信息自动将值解析为 JSON。</li></p><p><li><code>indexes: null|false|true = false</code> - 控制如何为“扁平”类数组对象的解包键添加索引。</li></p><p>    <li><code>null</code> - 不添加括号（<code>arr: 1</code>, <code>arr: 2</code>, <code>arr: 3</code>）</li>
    <li><code>false</code>（默认）- 添加空括号（<code>arr[]: 1</code>, <code>arr[]: 2</code>, <code>arr[]: 3</code>）</li>
    <li><code>true</code> - 添加带索引的括号（<code>arr[0]: 1</code>, <code>arr[1]: 2</code>, <code>arr[2]: 3</code>）</li></p><p></ul>假设我们有如下对象：</p><pre><code class="language-js">const obj = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
  'obj2{}': [{x:1}]
};</code></pre></p><p>Axios 序列化器内部将执行以下步骤：</p><pre><code class="language-js">const formData = new FormData();
formData.append('x', '1');
formData.append('arr[]', '1');
formData.append('arr[]', '2');
formData.append('arr[]', '3');
formData.append('arr2[0]', '1');
formData.append('arr2[1][0]', '2');
formData.append('arr2[2]', '3');
formData.append('users[0][name]', 'Peter');
formData.append('users[0][surname]', 'Griffin');
formData.append('users[1][name]', 'Thomas');
formData.append('users[1][surname]', 'Anderson');
formData.append('obj2{}', '[{"x":1}]');</code></pre></p><p>Axios 支持以下简写方法：<code>postForm</code>、<code>putForm</code>、<code>patchForm</code>，
它们只是对应的 http 方法，并且 <code>Content-Type</code> 头已预设为 <code>multipart/form-data</code>。</p><h2>文件上传</h2></p><p>你可以轻松提交单个文件：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', {
  'myVar' : 'foo',
  'file': document.querySelector('#fileInput').files[0]
});</code></pre></p><p>或以 <code>multipart/form-data</code> 方式上传多个文件：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', {
  'files[]': document.querySelector('#fileInput').files
});</code></pre></p><p>可以直接传递 <code>FileList</code> 对象：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)</code></pre></p><p>所有文件将使用相同的字段名发送：<code>files[]</code>。</p><h2>🆕 HTML 表单提交（浏览器端）</h2></p><p>将 HTML Form 元素作为负载传递，以 <code>multipart/form-data</code> 内容类型提交。</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));</code></pre></p><p>也可以通过显式设置 <code>Content-Type</code> 头为 <code>application/json</code>，将 <code>FormData</code> 和 <code>HTMLForm</code> 对象以 <code>JSON</code> 形式提交：</p><pre><code class="language-js">await axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {
  headers: {
    'Content-Type': 'application/json'
  }
})</code></pre></p><p>例如，表单</p><pre><code class="language-html"><form id="form">
  <input type="text" name="foo" value="1">
  <input type="text" name="deep.prop" value="2">
  <input type="text" name="deep prop spaced" value="3">
  <input type="text" name="baz" value="4">
  <input type="text" name="baz" value="5"></p><p>  <select name="user.age">
    <option value="value1">Value 1</option>
    <option value="value2" selected>Value 2</option>
    <option value="value3">Value 3</option>
  </select></p><p>  <input type="submit" value="保存">
</form></code></pre></p><p>将会被提交为如下 JSON 对象：</p><pre><code class="language-js">{
  "foo": "1",
  "deep": {
    "prop": {
      "spaced": "3"
    }
  },
  "baz": [
    "4",
    "5"
  ],
  "user": {
    "age": "value2"
  }
}</code></pre><code></p><p>当前不支持以 JSON（</code>base64<code>）方式发送 </code>Blobs<code>/</code>Files<code>。</p><h2>🆕 进度捕获</h2></p><p>Axios 支持在浏览器和 node 环境中捕获请求上传/下载进度。
进度事件的频率被强制限制为每秒 </code>3<code> 次。</p><p></code>`<code>js    
await axios.post(url, data, {
  onUploadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number; // 范围在 [0..1] 之间
      bytes: number; // 自上次触发以来已传输的字节数（增量）
      estimated?: number; // 预计剩余时间（秒）
      rate?: number; // 上传速率（字节数）
      upload: true; // 上传标识
    }*/
  },</p><p>  onDownloadProgress: function (axiosProgressEvent) {
    /*{
<pre><code class="language-js">      loaded: number;
      total?: number;
      progress?: number;
      bytes: number; 
      estimated?: number;
      rate?: number; // 下载速度（字节数）
      download: true; // 下载标志
    }*/
  }
});  </code></pre></p><p>你也可以在 node.js 中跟踪流上传/下载进度：</p><pre><code class="language-js">const {data} = await axios.post(SERVER_URL, readableStream, {
   onUploadProgress: ({progress}) => {
     console.log((progress * 100).toFixed(2));
   },
  
   headers: {
    'Content-Length': contentLength
   },</p><p>   maxRedirects: 0 // 避免缓冲整个流
});</code></pre></code></p><blockquote><strong>注意：</strong></blockquote>
<blockquote>目前在 node.js 环境下不支持捕获 FormData 上传进度。</blockquote></p><blockquote><strong>⚠️ 警告</strong></blockquote>
<blockquote>建议在 <strong>node.js</strong> 环境中通过设置 maxRedirects: 0 禁用重定向来上传流，</blockquote>
<blockquote>因为 follow-redirects 包会在内存中缓冲整个流，而不会遵循“背压”算法。</blockquote></p><h2>🆕 限速</h2></p><p>下载和上传速率限制只能为 http 适配器（node.js）设置：</p><pre><code class="language-js">const {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {
  onUploadProgress: ({progress, rate}) => {
    console.log(<code>Upload [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s</code>)
  },
   
  maxRate: [100 * 1024], // 限制为 100KB/s
});</code></pre></p><h2>🆕 AxiosHeaders</h2></p><p>Axios 有自己的 <code>AxiosHeaders</code> 类，使用类似 Map 的 API 操作请求头，保证不区分大小写。
虽然 HTTP 头部不区分大小写，但 Axios 会出于风格考虑保留原始头部的大小写，
并作为某些服务器错误区分头部大小写时的解决方案。
直接操作 headers 对象的旧方式仍然可用，但已弃用，不建议在将来使用。</p><h3>操作请求头</h3></p><p>AxiosHeaders 对象实例可以包含不同类型的内部值，用于控制设置和合并逻辑。
最终带有字符串值的 headers 对象由 Axios 通过调用 <code>toJSON</code> 方法获得。</p><blockquote>注意：此处 JSON 指的是仅包含字符串值、准备用于网络传输的对象。</blockquote></p><p>头部值可以是以下类型之一：
<ul><li><code>string</code> - 将会发送给服务器的普通字符串值</li>
<li><code>null</code> - 渲染为 JSON 时跳过该头部</li>
<li><code>false</code> - 渲染为 JSON 时跳过该头部，此外表示必须使用 <code>rewrite</code> 选项为 <code>true</code> 调用 <code>set</code> 方法才能覆盖此值</li>
  </ul>（Axios 内部使用此方式，允许用户选择不安装某些头部，如 <code>User-Agent</code> 或 <code>Content-Type</code>）
<ul><li><code>undefined</code> - 未设置值</li></p><p></ul>> 注意：只有头部值不等于 undefined 时才视为已设置。</p><p>headers 对象总是在拦截器和转换器中初始化：</p><pre><code class="language-ts">  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {
      request.headers.set('My-header', 'value');</p><p>      request.headers.set({
        "My-set-header1": "my-set-value1",
        "My-set-header2": "my-set-value2"
      });
      
      request.headers.set('User-Agent', false); // 禁止 Axios 后续设置该头部</p><p>      request.headers.setContentType('text/plain');
    
      request.headers['My-set-header2'] = 'newValue' // 直接访问已弃用
    
      return request;
    }
  );</code></pre><code></p><p>你可以使用 </code>for...of<code> 语句遍历 </code>AxiosHeaders<code> 实例：</p><p></code><pre><code class="language-js">const headers = new AxiosHeaders({
  foo: '1',</code></pre><code>
  bar: '2',
  baz: '3'
});</p><p>for(const [header, value] of headers) {
  console.log(header, value);
}</p><p>// foo 1
// bar 2
// baz 3
</code><pre><code class="language-">
<h3>new AxiosHeaders(headers?)</h3></p><p>构造一个新的 <code>AxiosHeaders</code> 实例。
</code></pre>
constructor(headers?: RawAxiosHeaders | AxiosHeaders | string);
<pre><code class="language-">
如果 headers 对象是字符串，则会被解析为原始 HTTP 头部信息。
</code></pre><code>js
const headers = new AxiosHeaders(</code>
Host: www.bing.com
User-Agent: curl/7.54.0
Accept: <em>/</em><code>);</p><p>console.log(headers);</p><p>// Object [AxiosHeaders] {
//   host: 'www.bing.com',
//   'user-agent': 'curl/7.54.0',
//   accept: '<em>/</em>'
// }
</code><pre><code class="language-">
<h3>AxiosHeaders#set</h3>
</code></pre>ts
set(headerName, value: Axios, rewrite?: boolean);
set(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);
set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);
<pre><code class="language-">
<code>rewrite</code> 参数用于控制覆盖行为：
<ul><li><code>false</code> - 如果 header 的值已设置（不为 <code>undefined</code>）则不覆盖</li>
<li><code>undefined</code>（默认）- 除非 header 的值设置为 <code>false</code>，否则覆盖该 header</li>
<li><code>true</code> - 无论如何都覆盖</li></p><p></ul>该选项也可以接受一个用户自定义函数，用于决定是否应覆盖该值。</p><p>返回 <code>this</code>。</p><h3>AxiosHeaders#get(header)</h3>
</code></pre>
  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
  get(headerName: string, parser: RegExp): RegExpExecArray | null;
<code><pre><code class="language-">
返回 header 的内部值。它可以接受一个额外参数，用于用 </code>RegExp.exec<code>、匹配器函数或内部键值解析器解析 header 的值。
</code></pre>ts
const headers = new AxiosHeaders({
  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'
});</p><p>console.log(headers.get('Content-Type')); 
// multipart/form-data; boundary=Asrf456BGe4h</p><p>console.log(headers.get('Content-Type', true)); // 解析用 \s,;= 分隔的字符串中的键值对：
// [Object: null prototype] {
//   'multipart/form-data': undefined,
//    boundary: 'Asrf456BGe4h'
// }</p><p>
console.log(headers.get('Content-Type', (value, name, headers) => {
  return String(value).replace(/a/g, 'ZZZ');
}));
// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h</p><p>console.log(headers.get('Content-Type', /boundary=(\w+)/)?.[0]);
// boundary=Asrf456BGe4h</p><pre><code class="language-">
返回 header 的值。</p><h3>AxiosHeaders#has(header, matcher?)</h3>
</code></pre>
has(header: string, matcher?: AxiosHeaderMatcher): boolean;
<pre><code class="language-">
如果 header 已设置（值不为 </code>undefined<code>），则返回 </code>true<code>。</code></pre></code>
<h3>AxiosHeaders#delete(header, matcher?)</h3></p><pre><code class="language-">delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;</code></pre></p><p>如果至少有一个头被移除，则返回 <code>true</code>。</p><h3>AxiosHeaders#clear(matcher?)</h3></p><pre><code class="language-">clear(matcher?: AxiosHeaderMatcher): boolean;</code></pre></p><p>移除所有头信息。
与 <code>delete</code> 方法的 matcher 不同，这里的可选 matcher 用于匹配头名称而不是值。</p><pre><code class="language-ts">const headers = new AxiosHeaders({
  'foo': '1',
  'x-foo': '2',
  'x-bar': '3',
});</p><p>console.log(headers.clear(/^x-/)); // true</p><p>console.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }</code></pre></p><p>如果至少有一个头被清除，则返回 <code>true</code>。</p><h3>AxiosHeaders#normalize(format);</h3></p><p>如果 headers 对象被直接更改，可能会出现同名但大小写不同的重复项。
此方法通过将重复键合并为一个来规范化 headers 对象。
Axios 在调用每个拦截器后会在内部使用此方法。
将 <code>format</code> 设为 true 可将头名称转换为小写，并将首字母大写（如 <code>cOntEnt-type</code> => <code>Content-Type</code>）</p><pre><code class="language-js">const headers = new AxiosHeaders({
  'foo': '1',
});</p><p>headers.Foo = '2';
headers.FOO = '3';</p><p>console.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }
console.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }
console.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }</code></pre></p><p>返回 <code>this</code>。</p><h3>AxiosHeaders#concat(...targets)</h3></p><pre><code class="language-">concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;</code></pre></p><p>将实例与目标合并为一个新的 <code>AxiosHeaders</code> 实例。如果目标是字符串，则会被解析为原始 HTTP 头。</p><p>返回一个新的 <code>AxiosHeaders</code> 实例。</p><h3>AxiosHeaders#toJSON(asStrings?)</h3></p><p><code><pre><code class="language-">toJSON(asStrings?: boolean): RawAxiosHeaders;</code></pre></code></p><p>将所有内部头信息值解析为一个新的 null 原型对象。
将 <code>asStrings</code> 设为 true 可以将数组解析为用逗号分隔的字符串。</p><h3>AxiosHeaders.from(thing?)</h3></p><p><code><pre><code class="language-">from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;</code></pre></code></p><p>返回由传入的原始 headers 创建的新 <code>AxiosHeaders</code> 实例，
或者如果传入的是 <code>AxiosHeaders</code> 实例，则直接返回该对象。</p><h3>AxiosHeaders.concat(...targets)</h3></p><p><code><pre><code class="language-">concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;</code></pre></code></p><p>返回一个通过合并目标对象创建的新 <code>AxiosHeaders</code> 实例。</p><h3>快捷方式</h3></p><p>提供以下快捷方式：</p><ul><li><code>setContentType</code>，<code>getContentType</code>，<code>hasContentType</code></li></p><p><li><code>setContentLength</code>，<code>getContentLength</code>，<code>hasContentLength</code></li></p><p><li><code>setAccept</code>，<code>getAccept</code>，<code>hasAccept</code></li></p><p><li><code>setUserAgent</code>，<code>getUserAgent</code>，<code>hasUserAgent</code></li></p><p><li><code>setContentEncoding</code>, <code>getContentEncoding</code>, <code>hasContentEncoding</code></li></p><p></ul><h2>🔥 Fetch 适配器</h2></p><p>Fetch 适配器在 <code>v1.7.0</code> 中引入。默认情况下，如果构建中没有 <code>xhr</code> 和 <code>http</code> 适配器，或者环境不支持，将会使用它。
要默认使用它，必须显式选择：</p><pre><code class="language-js">const {data} = axios.get(url, {
  adapter: 'fetch' // 默认顺序 ['xhr', 'http', 'fetch']
})</code></pre></p><p>你可以为此创建一个单独的实例：</p><pre><code class="language-js">const fetchAxios = axios.create({
  adapter: 'fetch'
});</p><p>const {data} = fetchAxios.get(url);</code></pre></p><p>该适配器支持与 <code>xhr</code> 适配器相同的功能，<strong>包括上传和下载进度的捕捉</strong>。
此外，它还支持额外的响应类型，如 <code>stream</code> 和 <code>formdata</code>（如果环境支持）。</p><h2>语义化版本（Semver）</h2></p><p>在 axios 达到 <code>1.0</code> 正式版之前，任何破坏性变更都将通过新的次版本发布。例如，<code>0.5.1</code> 和 <code>0.5.4</code> 将拥有相同的 API，但 <code>0.6.0</code> 会有破坏性变更。</p><h2>Promises</h2></p><p>axios 依赖原生的 ES6 Promise 实现以获得<a href="https://caniuse.com/promises" target="_blank" rel="noopener noreferrer">支持</a>。
如果你的环境不支持 ES6 Promise，你可以使用 <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener noreferrer">polyfill</a>。</p><h2>TypeScript</h2></p><p>axios 包含 <a href="https://typescriptlang.org" target="_blank" rel="noopener noreferrer">TypeScript</a> 类型定义以及 axios 错误的类型保护。</p><pre><code class="language-typescript">let user: User = null;
try {
  const { data } = await axios.get('/user?ID=12345');
  user = data.userDetails;
} catch (error) {
  if (axios.isAxiosError(error)) {
    handleAxiosError(error);
  } else {
    handleUnexpectedError(error);
  }
}</code></pre></p><p>由于 axios 同时以 ESM 默认导出和 CJS 的 <code>module.exports</code> 方式发布，因此有一些注意事项。
推荐的设置是使用 <code>"moduleResolution": "node16"</code>（这在 <code>"module": "node16"</code> 时已隐式设置）。注意，这需要 TypeScript 4.7 或更高版本。
如果使用 ESM，你的设置应该没问题。
如果你将 TypeScript 编译为 CJS 并且无法使用 <code>"moduleResolution": "node16"</code>，你必须启用 <code>esModuleInterop</code>。
如果你使用 TypeScript 对 CJS JavaScript 代码进行类型检查，你唯一的选择是使用 <code>"moduleResolution": "node16"</code>。</p><h2>在线一键设置</h2></p><p>你可以使用 Gitpod，一个在线 IDE（对开源免费），用于贡献代码或在线运行示例。</p><p><a href="https://gitpod.io/#https://github.com/axios/axios/blob/main/examples/server.js" target="_blank" rel="noopener noreferrer"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod"></a></p><h2>资源</h2></p><ul><li><a href="https://github.com/axios/axios/blob/v1.x/CHANGELOG.md" target="_blank" rel="noopener noreferrer">更新日志</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/ECOSYSTEM.md" target="_blank" rel="noopener noreferrer">生态系统</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/CONTRIBUTING.md" target="_blank" rel="noopener noreferrer">贡献指南</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer">行为准则</a></li></p><p></ul><h2>致谢</h2></p><p>axios 深受 <a href="https://angularjs.org/" target="_blank" rel="noopener noreferrer">AngularJS</a> 提供的 <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank" rel="noopener noreferrer">$http 服务</a> 启发。最终，axios 致力于提供一个可在 AngularJS 之外使用的独立 <code>$http</code> 类服务。</p><h2>许可证</h2></p><p><a href="LICENSE" target="_blank" rel="noopener noreferrer">MIT</a></p><p>
---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-30

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/axios/axios/v1.x/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>