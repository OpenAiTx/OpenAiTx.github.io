<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>axios - Read axios documentation in Traditional Chinese. This project has 107145 stars on GitHub.</title>
    <meta name="description" content="Read axios documentation in Traditional Chinese. This project has 107145 stars on GitHub.">
    <meta name="keywords" content="axios, Traditional Chinese, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "axios",
  "description": "Read axios documentation in Traditional Chinese. This project has 107145 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "axios"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 107145
  },
  "url": "https://OpenAiTx.github.io/projects/axios/axios/README-zh-TW.html",
  "sameAs": "https://raw.githubusercontent.com/axios/axios/v1.x/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    axios
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 107145 stars</span>
                <span class="language">Traditional Chinese</span>
                <span>by axios</span>
            </div>
        </div>
        
        <div class="content">
            <p><h3 align="center"> 🥇 金級贊助商 <br> </h3> <table align="center" width="100%"><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="38px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/stytch_white.png"> <img width="200px" height="38px" src="https://axios-http.com/assets/sponsors/stytch.png" alt="Stytch"/> </picture> </a> <p align="center" title="API-first authentication, authorization, and fraud prevention">API 優先的身份驗證、授權和防詐欺防護</p> <p align="center"> <a href="https://stytch.com/?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;website-link&amp;utm_campaign&#x3D;axios-http"><b>官方網站</b></a> | <a href="https://stytch.com/docs?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;docs-link&amp;utm_campaign&#x3D;axios-http"><b>文件</b></a> | <a href="https://github.com/stytchauth/stytch-node?utm_source&#x3D;oss-sponsorship&amp;utm_medium&#x3D;paid_sponsorship&amp;utm_content&#x3D;node-sdk&amp;utm_campaign&#x3D;axios-http"><b>Node.js</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="133px" height="43px" src="https://axios-http.com/assets/sponsors/principal.svg" alt="Principal Financial Group"/> </a> <p align="center" title="We’re bound by one common purpose: to give you the financial tools, resources and information you need to live your best life.">我們懷抱著一個共同目標：為您提供實現美好人生所需的金融工具、資源與資訊。</p> <p align="center"> <a href="https://www.principal.com/about-us?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.principal.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="85px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buy-instagram-followers-twicsy.png" alt="Buy Instagram Followers Twicsy"/> </a> <p align="center" title="Buy real Instagram followers from Twicsy starting at only $2.97. Twicsy has been voted the best site to buy followers from the likes of US Magazine.">在 Twicsy 以 $2.97 起購買真正的 Instagram 粉絲。Twicsy 曾獲 US Magazine 評選為最佳購買粉絲網站。</p> <p align="center"> <a href="https://twicsy.com/buy-instagram-followers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>twicsy.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship" style="padding: 10px; display: inline-block"> <picture> <source width="200px" height="52px" media="(prefers-color-scheme: dark)" srcset="https://axios-http.com/assets/sponsors/descope_white.png"> <img width="200px" height="52px" src="https://axios-http.com/assets/sponsors/descope.png" alt="Descope"/> </picture> </a> <p align="center" title="Hi, we&#x27;re Descope! We are building something in the authentication space for app developers and can’t wait to place it in your hands.">嗨，我們是 Descope！我們正在為應用開發者打造身份驗證相關產品，期待盡快交到你手上。</p> <p align="center"> <a href="https://www.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>官方網站</b></a> | <a href="https://docs.descope.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>文件</b></a> | <a href="https://www.descope.com/community?utm_source&#x3D;axios&amp;utm_medium&#x3D;referral&amp;utm_campaign&#x3D;axios-oss-sponsorship"><b>社群</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="62px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/buzzoid-buy-instagram-followers.png" alt="Buzzoid - Buy Instagram Followers"/> </a> <p align="center" title="At Buzzoid, you can buy Instagram followers quickly, safely, and easily with just a few clicks. Rated world&#x27;s #1 IG service since 2012.">在 Buzzoid，您只需點幾下即可快速、安全、輕鬆購買 Instagram 粉絲。自 2012 年起被評為全球第一 IG 服務。</p> <p align="center"> <a href="https://buzzoid.com/buy-instagram-followers/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>buzzoid.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/famety-buy-instagram-followers.png" alt="Famety - Buy Instagram Followers"/> </a> <p align="center" title="At Famety, you can grow your social media following quickly, safely, and easily with just a few clicks. Rated the world’s #1 social media service since 2013.">在 Famety，您只需點幾下即可快速、安全、輕鬆擴展您的社群媒體粉絲數。自 2013 年以來被評為全球第一社群媒體服務。</p> <p align="center"> <a href="https://www.famety.net/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>www.famety.net</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/instagram-likes.png" alt="Poprey - Buy Instagram Likes"/> </a> <p align="center" title="Buy Instagram Likes">購買 Instagram 按讚數</p> <p align="center"> <a href="https://poprey.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>poprey.com</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="70px" height="70px" src="https://axios-http.com/assets/sponsors/opencollective/youtube-subscribers-ssmarket.png" alt="Buy Youtube Subscribers"/> </a> <p align="center" title="SS Market offers professional social media services that rapidly increase your YouTube subscriber count, elevating your channel to a powerful position.">SS Market 提供專業的社群媒體服務，能迅速提升您的 YouTube 訂閱人數，讓您的頻道快速壯大。</p> <p align="center"> <a href="https://ssmarket.net/buy-youtube-subscribers?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>ssmarket.net</b></a> </p>
</td><td align="center" width="33.333333333333336%"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;sponsorlist&amp;utm_campaign&#x3D;sponsorship" style="padding: 10px; display: inline-block"> <img width="200px" height="56px" src="https://axios-http.com/assets/sponsors/opencollective/smmpanelserver123.png" alt="smmpanelserver"/> </a> <p align="center" title="smmpanelserver - Best and Cheapest Smm Panel">smmpanelserver - 最佳且最便宜的 Smm 面板</p> <p align="center"> <a href="https://smmpanelserver.com/?utm_source&#x3D;axios&amp;utm_medium&#x3D;readme_sponsorlist&amp;utm_campaign&#x3D;sponsorship"><b>smmpanelserver.com</b></a> </p>
</td></tr><tr width="33.333333333333336%"><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成為贊助商</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成為贊助商</a>
</td><td align="center" width="33.333333333333336%"> <a href="https://opencollective.com/axios/contribute">💜 成為贊助商</a>
</td></tr></table></p><p><!--<div>marker</div>-->
<br><br>
<div align="center">
   <a href="https://axios-http.com"><img src="https://axios-http.com/assets/logo.svg" /></a><br>
</div></p><p><p align="center">基於 Promise 的瀏覽器與 Node.js HTTP 客戶端</p></p><p><p align="center">
    <a href="https://axios-http.com/"><b>官方網站</b></a> •
    <a href="https://axios-http.com/docs/intro"><b>文件</b></a>
</p></p><p><div align="center"></p><p><a href="https://www.npmjs.org/package/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/v/axios.svg?style=flat-square" alt="npm 版本"></a>
<a href="https://cdnjs.com/libraries/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/cdnjs/v/axios.svg?style=flat-square" alt="CDNJS"></a>
<a href="https://github.com/axios/axios/actions/workflows/ci.yml" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/actions/workflow/status/axios/axios/ci.yml?branch=v1.x&label=CI&logo=github&style=flat-square" alt="建置狀態"></a>
<a href="https://gitpod.io/#https://github.com/axios/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod&style=flat-square" alt="Gitpod Ready-to-Code"></a>
<a href="https://coveralls.io/r/mzabriskie/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" alt="程式碼覆蓋率"></a>
<a href="https://packagephobia.now.sh/result?p=axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/dynamic/json?url=https://packagephobia.com/v2/api.json?p=axios&query=$.install.pretty&label=install%20size&style=flat-square" alt="安裝大小"></a>
<a href="https://bundlephobia.com/package/axios@latest" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/bundlephobia/minzip/axios?style=flat-square" alt="npm bundle 大小"></a>
<a href="https://npm-stat.com/charts.html?package=axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/npm/dm/axios.svg?style=flat-square" alt="npm 下載量"></a>
<a href="https://gitter.im/mzabriskie/axios" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square" alt="gitter 聊天室"></a>
<a href="https://www.codetriage.com/axios/axios" target="_blank" rel="noopener noreferrer"><img src="https://www.codetriage.com/axios/axios/badges/users.svg" alt="code helpers"></a>
<a href="https://snyk.io/test/npm/axios" target="_blank" rel="noopener noreferrer"><img src="https://snyk.io/test/npm/axios/badge.svg" alt="已知漏洞"></a></p><p>
</div></p><h2>目錄</h2></p><ul><li><a href="#features" target="_blank" rel="noopener noreferrer">功能特點</a></li>
  <li><a href="#browser-support" target="_blank" rel="noopener noreferrer">瀏覽器支援</a></li>
  <li><a href="#installing" target="_blank" rel="noopener noreferrer">安裝</a></li>
    <li><a href="#package-manager" target="_blank" rel="noopener noreferrer">套件管理工具</a></li>
    <li><a href="#cdn" target="_blank" rel="noopener noreferrer">CDN</a></li>
  <li><a href="#example" target="_blank" rel="noopener noreferrer">範例</a></li>
  <li><a href="#axios-api" target="_blank" rel="noopener noreferrer">Axios API</a></li>
  <li><a href="#request-method-aliases" target="_blank" rel="noopener noreferrer">請求方法別名</a></li>
  <li><a href="#concurrency-deprecated" target="_blank" rel="noopener noreferrer">並行 👎</a></li>
  <li><a href="#creating-an-instance" target="_blank" rel="noopener noreferrer">建立實例</a></li>
  <li><a href="#instance-methods" target="_blank" rel="noopener noreferrer">實例方法</a></li>
  <li><a href="#request-config" target="_blank" rel="noopener noreferrer">請求設定</a></li>
  <li><a href="#response-schema" target="_blank" rel="noopener noreferrer">回應結構</a></li>
  <li><a href="#config-defaults" target="_blank" rel="noopener noreferrer">預設設定</a></li>
    <li><a href="#global-axios-defaults" target="_blank" rel="noopener noreferrer">全域 axios 預設值</a></li>
    <li><a href="#custom-instance-defaults" target="_blank" rel="noopener noreferrer">自訂實例預設值</a></li>
    <li><a href="#config-order-of-precedence" target="_blank" rel="noopener noreferrer">設定優先順序</a></li>
  <li><a href="#interceptors" target="_blank" rel="noopener noreferrer">攔截器</a></li>
    <li><a href="#multiple-interceptors" target="_blank" rel="noopener noreferrer">多個攔截器</a></li>
  <li><a href="#handling-errors" target="_blank" rel="noopener noreferrer">錯誤處理</a></li>
  <li><a href="#cancellation" target="_blank" rel="noopener noreferrer">取消請求</a></li>
    <li><a href="#abortcontroller" target="_blank" rel="noopener noreferrer">AbortController</a></li>
    <li><a href="#canceltoken-deprecated" target="_blank" rel="noopener noreferrer">CancelToken 👎</a></li>
  <li><a href="#using-applicationx-www-form-urlencoded-format" target="_blank" rel="noopener noreferrer">使用 application/x-www-form-urlencoded 格式</a></li>
    <li><a href="#urlsearchparams" target="_blank" rel="noopener noreferrer">URLSearchParams</a></li>
    <li><a href="#query-string-older-browsers" target="_blank" rel="noopener noreferrer">查詢字串</a></li>
    <li><a href="#-automatic-serialization-to-urlsearchparams" target="_blank" rel="noopener noreferrer">🆕 自動序列化</a></li>
  <li><a href="#using-multipartform-data-format" target="_blank" rel="noopener noreferrer">使用 multipart/form-data 格式</a></li>
    <li><a href="#formdata" target="_blank" rel="noopener noreferrer">FormData</a></li>
    <li><a href="#-automatic-serialization-to-formdata" target="_blank" rel="noopener noreferrer">🆕 自動序列化</a></li>
  <li><a href="#files-posting" target="_blank" rel="noopener noreferrer">檔案上傳</a></li>
  <li><a href="#-html-form-posting-browser" target="_blank" rel="noopener noreferrer">HTML 表單上傳</a></li>
  <li><a href="#-progress-capturing" target="_blank" rel="noopener noreferrer">🆕 進度監控</a></li>
  <li><a href="#-progress-capturing" target="_blank" rel="noopener noreferrer">🆕 流量限制</a></li>
  <li><a href="#-axiosheaders" target="_blank" rel="noopener noreferrer">🆕 AxiosHeaders</a></li>
  <li><a href="#-fetch-adapter" target="_blank" rel="noopener noreferrer">🔥 Fetch 配接器</a></li>
  <li><a href="#semver" target="_blank" rel="noopener noreferrer">Semver</a></li>
  <li><a href="#promises" target="_blank" rel="noopener noreferrer">Promises</a></li>
  <li><a href="#typescript" target="_blank" rel="noopener noreferrer">TypeScript</a></li>
  <li><a href="#resources" target="_blank" rel="noopener noreferrer">資源</a></li>
  <li><a href="#credits" target="_blank" rel="noopener noreferrer">貢獻者</a></li>
  <li><a href="#license" target="_blank" rel="noopener noreferrer">授權</a></li></p><p></ul><h2>功能特點</h2></p><ul><li>可從瀏覽器發送 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener noreferrer">XMLHttpRequests</a></li>
<li>可從 node.js 發送 <a href="https://nodejs.org/api/http.html" target="_blank" rel="noopener noreferrer">http</a> 請求</li>
<li>支援 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise</a> API</li>
<li>請求與回應攔截</li>
<li>請求與回應資料轉換</li>
<li>請求可取消</li>
<li>自動轉換 <a href="https://www.json.org/json-en.html" target="_blank" rel="noopener noreferrer">JSON</a> 資料</li>
<li>🆕 自動將資料物件序列化為 <code>multipart/form-data</code> 和 <code>x-www-form-urlencoded</code> 主體編碼</li>
<li>支援用戶端防護 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener noreferrer">XSRF</a> 攻擊</li></p><p></ul><h2>瀏覽器支援</h2></p><p><img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/chrome/chrome_48x48.png" alt="Chrome"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/firefox/firefox_48x48.png" alt="Firefox"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/safari/safari_48x48.png" alt="Safari"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/opera/opera_48x48.png" alt="Opera"> | <img src="https://raw.githubusercontent.com/alrra/browser-logos/main/src/edge/edge_48x48.png" alt="Edge"> |
--- | --- | --- | --- | --- |
最新版 ✔ | 最新版 ✔ | 最新版 ✔ | 最新版 ✔ | 最新版 ✔ | 11 ✔ |</p><p><a href="https://saucelabs.com/u/axios" target="_blank" rel="noopener noreferrer"><img src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" alt="Browser Matrix"></a></p><h2>安裝</h2></p><h3>套件管理器</h3></p><p>使用 npm：</p><pre><code class="language-bash">$ npm install axios</code></pre></p><p>使用 bower：</p><pre><code class="language-bash">$ bower install axios</code></pre></p><p>使用 yarn：</p><pre><code class="language-bash">$ yarn add axios</code></pre></p><p>使用 pnpm：</p><pre><code class="language-bash">$ pnpm add axios</code></pre></p><p>使用 bun：</p><pre><code class="language-bash">$ bun add axios</code></pre></p><p>安裝好套件後，你可以用 <code>import</code> 或 <code>require</code> 方式導入這個函式庫：</p><pre><code class="language-js">import axios, {isCancel, AxiosError} from 'axios';</code></pre></p><p>你也可以使用預設匯出，因為命名匯出只是從 Axios 工廠重新匯出：</p><pre><code class="language-js">import axios from 'axios';</p><p>console.log(axios.isCancel('something'));</code></pre></p><p>如果你使用 <code>require</code> 來導入，只能使用<strong>預設匯出</strong>：</p><pre><code class="language-js">const axios = require('axios');</p><p>console.log(axios.isCancel('something'));</code></pre></p><p>對於某些打包工具和 ES6 靜態檢查工具，你可能需要這樣做：</p><pre><code class="language-js">import { default as axios } from 'axios';</code></pre></p><p>如果在自訂或舊環境中導入模組時發生錯誤，可以嘗試直接導入模組套件：</p><pre><code class="language-js">const axios = require('axios/dist/browser/axios.cjs'); // browser commonJS bundle (ES2017)
// const axios = require('axios/dist/node/axios.cjs'); // node commonJS bundle (ES2017)</code></pre></p><h3>CDN</h3></p><p>使用 jsDelivr CDN (ES5 UMD 瀏覽器模組)：</p><pre><code class="language-html"><script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script></code></pre></p><p>使用 unpkg CDN：</p><pre><code class="language-html"><script src="https://unpkg.com/axios@1.6.7/dist/axios.min.js"></script></code></pre></p><h2>範例</h2></p><blockquote><strong>注意</strong>：CommonJS 用法  </blockquote>
<blockquote>若要在使用 CommonJS 的 <code>require()</code> 導入方式下取得 TypeScript 型別（以支援 intellisense / 自動完成），請使用下列方式：</blockquote>
<pre><code class="language-js">import axios from 'axios';
//const axios = require('axios'); // 舊有方式</p><p>// 以給定的 ID 發送用戶請求
axios.get('/user?ID=12345')
  .then(function (response) {
    // 處理成功
    console.log(response);
  })
  .catch(function (error) {
    // 處理錯誤
    console.log(error);
  })
  .finally(function () {
    // 總是執行
  });</p><p>// 上述請求也可以這樣寫
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // 總是執行
  });</p><p>// 想要使用 async/await？在外部函數/方法加上 <code>async</code> 關鍵字。
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}</code></pre></p><blockquote><strong>注意</strong>：<code>async/await</code> 是 ECMAScript 2017 的一部分，並不支援 Internet Explorer 及舊版瀏覽器，請謹慎使用。</blockquote></p><p>執行 <code>POST</code> 請求</p><pre><code class="language-js">axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });</code></pre></p><p>執行多個並行請求</p><pre><code class="language-js">function getUserAccount() {
  return axios.get('/user/12345');
}</p><p>function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}</p><p>Promise.all([getUserAccount(), getUserPermissions()])
  .then(function (results) {
    const acct = results[0];
    const perm = results[1];
  });</code></pre></p><h2>axios API</h2></p><p>可以通過傳遞相關的設定(config)給 <code>axios</code> 來發送請求。</p><p>##### axios(config)</p><pre><code class="language-js">// 發送 POST 請求
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});</code></pre></p><pre><code class="language-js">// 在 node.js 中對遠端圖片發送 GET 請求
axios({
  method: 'get',
  url: 'https://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });</code></pre></p><p>##### axios(url[, config])</p><pre><code class="language-js">// 發送一個 GET 請求（預設方法）
axios('/user/12345');</code></pre></p><h3>請求方法別名</h3></p><p>為了方便，所有常用的請求方法都提供了別名。</p><p>##### axios.request(config)
##### axios.get(url[, config])
##### axios.delete(url[, config])
##### axios.head(url[, config])
##### axios.options(url[, config])
##### axios.post(url[, data[, config]])
##### axios.put(url[, data[, config]])
##### axios.patch(url[, data[, config]])</p><p>###### 注意
使用別名方法時，<code>url</code>、<code>method</code> 和 <code>data</code> 屬性不需要在 config 中指定。</p><h3>併發（已棄用）</h3>
請使用 <code>Promise.all</code> 取代以下函數。</p><p>處理併發請求的輔助函數。</p><p>axios.all(iterable)
axios.spread(callback)</p><h3>建立實例</h3></p><p>你可以用自定義的 config 建立一個新的 axios 實例。</p><p>##### axios.create([config])</p><pre><code class="language-js">const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});</code></pre></p><h3>實例方法</h3></p><p>可用的實例方法如下所列。指定的 config 會與實例的 config 合併。</p><p>##### axios#request(config)
##### axios#get(url[, config])
##### axios#delete(url[, config])
##### axios#head(url[, config])
##### axios#options(url[, config])
##### axios#post(url[, data[, config]])
##### axios#put(url[, data[, config]])
##### axios#patch(url[, data[, config]])
##### axios#getUri([config])</p><h2>請求設定</h2></p><p>這些是可用於發送請求的設定選項。只有 <code>url</code> 是必要的。如果未指定 <code>method</code>，請求預設為 <code>GET</code>。</p><pre><code class="language-js">{
  // <code>url</code> 是本次請求將會使用的伺服器 URL
  url: '/user',</p><p>  // <code>method</code> 是請求時要使用的請求方法
  method: 'get', // 預設值</p><p>  // <code>baseURL</code> 會加在 <code>url</code> 前面，除非 <code>url</code> 是絕對路徑且選項 <code>allowAbsoluteUrls</code> 設為 true。
  // 可以為 axios 實例設定 <code>baseURL</code>，以便傳遞相對 URL 給該實例的方法。
  baseURL: 'https://some-domain.com/api/',</p><p>  // <code>allowAbsoluteUrls</code> 決定絕對 URL 是否會覆蓋已設定的 <code>baseUrl</code>。
  // 當設為 true（預設），<code>url</code> 的絕對值會覆蓋 <code>baseUrl</code>。
  // 當設為 false，<code>url</code> 的絕對值會永遠由 <code>baseUrl</code> 加在前面。
  allowAbsoluteUrls: true,</p><p>  // <code>transformRequest</code> 允許在資料發送到伺服器前修改請求資料
  // 只適用於 'PUT', 'POST', 'PATCH' 和 'DELETE' 方法
  // 陣列中的最後一個函式必須回傳字串或 Buffer、ArrayBuffer、
  // FormData 或 Stream 的實例
  // 你可以修改 headers 物件。
  transformRequest: [function (data, headers) {
    // 可根據需求轉換資料</code></pre>
    return data;
  }],</p><p>  // <code>transformResponse</code> 允許在回傳資料傳遞給 then/catch 前進行變更
  transformResponse: [function (data) {
    // 你可以在這裡對資料進行任何需要的轉換</p><p>    return data;
  }],</p><p>  // <code>headers</code> 是要發送的自訂標頭
  headers: {'X-Requested-With': 'XMLHttpRequest'},</p><p>  // <code>params</code> 是與請求一起發送的 URL 參數
  // 必須是純物件或 URLSearchParams 物件
  params: {
    ID: 12345
  },
  
  // <code>paramsSerializer</code> 是一個可選的設定，允許你自訂序列化 <code>params</code> 的方式。
  paramsSerializer: {</p><p>    // 自訂編碼器函式，以迭代方式傳送 key/value 對。
    encode?: (param: string): string => { /<em> 在這裡自訂操作並回傳轉換後的字串 </em>/ }, 
    
    // 針對整個參數自訂序列化函式。允許使用者模擬 1.x 之前的行為。
    serialize?: (params: Record<string, any>, options?: ParamsSerializerOptions ), 
    
    // 設定陣列索引在參數中的格式。
    indexes: false // 有三種可用選項：(1) indexes: null（不加括號），(2)（預設）indexes: false（空括號），(3) indexes: true（加索引的括號）。
  },</p><p>  // <code>data</code> 是要作為請求主體發送的資料
  // 只適用於 'PUT'、'POST'、'DELETE' 和 'PATCH' 請求方法
  // 當未設定 <code>transformRequest</code> 時，必須是以下其中一種型態：
  // - 字串、純物件、ArrayBuffer、ArrayBufferView、URLSearchParams
  // - 僅限瀏覽器：FormData、File、Blob
  // - 僅限 Node：Stream、Buffer、FormData（form-data 套件）
  data: {
    firstName: 'Fred'
  },</p><p>  // 傳送資料到主體的語法替代方式
  // 方法為 post
  // 只會傳送值，不會傳送鍵
  data: 'Country=Brasil&City=Belo Horizonte',</p><p>  // <code>timeout</code> 指定請求逾時前的毫秒數。
  // 如果請求超過 <code>timeout</code>，請求會被中止。
  timeout: 1000, // 預設為 <code>0</code>（無逾時）</p><p>  // <code>withCredentials</code> 指示是否應使用認證進行跨站存取控制請求
  withCredentials: false, // 預設值</p><p>  // <code>adapter</code> 允許自訂請求處理，方便測試。
  // 回傳一個 promise 並提供有效的回應（請參閱 lib/adapters/README.md）
  adapter: function (config) {
    /<em> ... </em>/
  },
  // 你也可以設定內建 adapter 的名稱，或提供一個名稱陣列
  // 以選擇在環境中可用的第一個
  adapter: 'xhr', // 'fetch' | 'http' | ['xhr', 'http', 'fetch']</p><p>  // <code>auth</code> 表示要使用 HTTP Basic 認證，並提供認證資訊。
  // 這會設定一個 <code>Authorization</code> 標頭，會覆蓋你用 <code>headers</code> 設定的任何現有
  // <code>Authorization</code> 自訂標頭。
  // 請注意，只有 HTTP Basic 認證可透過此參數設定。
  // 若需 Bearer token 等，請改用 <code>Authorization</code> 自訂標頭。
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },</p><p>  // <code>responseType</code> 表示伺服器將回應的資料型態
  // 選項有：'arraybuffer'、'document'、'json'、'text'、'stream'
  //   僅瀏覽器：'blob'
  responseType: 'json', // 預設值</p><p>  // <code>responseEncoding</code> 表示解碼回應時要使用的編碼（僅限 Node.js）
  // 注意：對於 'stream' 的 <code>responseType</code> 或用戶端請求將被忽略
  // 選項有：'ascii'、'ASCII'、'ansi'、'ANSI'、'binary'、'BINARY'、'base64'、'BASE64'、'base64url'、
  // 'BASE64URL'、'hex'、'HEX'、'latin1'、'LATIN1'、'ucs-2'、'UCS-2'、'ucs2'、'UCS2'、'utf-8'、'UTF-8'、
  // 'utf8'、'UTF8'、'utf16le'、'UTF16LE'
  responseEncoding: 'utf8', // 預設值</p><p>  // <code>xsrfCookieName</code> 是要作為 xsrf token 值使用的 cookie 名稱
  xsrfCookieName: 'XSRF-TOKEN', // 預設值</p><p>  // <code>xsrfHeaderName</code> 是攜帶 xsrf token 值的 http 標頭名稱
  xsrfHeaderName: 'X-XSRF-TOKEN', // 預設值
    
  // <code>undefined</code>（預設）- 僅對同源請求設置 XSRF 標頭
  withXSRFToken: boolean | undefined | ((config: InternalAxiosRequestConfig) => boolean | undefined),</p><p>  // <code>onUploadProgress</code> 允許上傳時處理進度事件
  // 瀏覽器與 node.js
  onUploadProgress: function ({loaded, total, progress, bytes, estimated, rate, upload = true}) {
<pre><code class="language-markdown">    // 你可以隨意處理 Axios 的進度事件
  },</p><p>  // <code>onDownloadProgress</code> 允許處理下載的進度事件
  // 瀏覽器 & node.js
  onDownloadProgress: function ({loaded, total, progress, bytes, estimated, rate, download = true}) {
    // 你可以隨意處理 Axios 的進度事件
  },</p><p>  // <code>maxContentLength</code> 定義在 node.js 中允許的 HTTP 回應內容最大大小（位元組）
  maxContentLength: 2000,</p><p>  // <code>maxBodyLength</code>（僅限 Node 選項）定義在 node.js 中允許的 HTTP 請求內容最大大小（位元組）
  maxBodyLength: 2000,</p><p>  // <code>validateStatus</code> 定義是否針對給定的 HTTP 回應狀態碼解析或拒絕 promise。
  // 如果 <code>validateStatus</code> 回傳 <code>true</code>（或設為 <code>null</code> 或 <code>undefined</code>），promise 會被解析；
  // 否則 promise 會被拒絕。
  validateStatus: function (status) {
    return status >= 200 && status < 300; // 預設值
  },</p><p>  // <code>maxRedirects</code> 定義在 node.js 中允許跟隨的最大重導次數。
  // 如果設為 0，則不跟隨任何重導。
  maxRedirects: 21, // 預設值</p><p>  // <code>beforeRedirect</code> 定義一個在重導前會被呼叫的函式。
  // 使用此函式可在重導時調整請求選項，
  // 檢查最新的回應標頭，
  // 或透過拋出錯誤取消請求
  // 如果 maxRedirects 設為 0，則不會使用 <code>beforeRedirect</code>。
  beforeRedirect: (options, { headers }) => {
    if (options.hostname === "example.com") {
      options.auth = "user:password";
    }
  },</p><p>  // <code>socketPath</code> 定義在 node.js 中要使用的 UNIX Socket。
  // 例如 '/var/run/docker.sock' 可傳送請求到 docker daemon。
  // 只能指定 <code>socketPath</code> 或 <code>proxy</code> 其中之一。
  // 如果兩者都指定，則會使用 <code>socketPath</code>。
  socketPath: null, // 預設值
  
  // <code>transport</code> 決定請求所使用的傳輸方式。
  // 如果已定義，則會使用它。否則，如果 <code>maxRedirects</code> 為 0，
  // 則會依據 <code>protocol</code> 指定的協議預設使用 <code>http</code> 或 <code>https</code> 函式庫。
  // 否則，會依據協議使用 <code>httpFollow</code> 或 <code>httpsFollow</code> 函式庫，
  // 這些函式庫可以處理重導。
  transport: undefined, // 預設值</p><p>  // <code>httpAgent</code> 和 <code>httpsAgent</code> 定義在 node.js 中進行 http 和 https 請求時要使用的自訂 agent。
  // 這允許加入如 <code>keepAlive</code> 等選項，在 Node.js v19.0.0 之前預設未啟用。
  // 在 Node.js v19.0.0 之後，不需自訂 agent 也能啟用 <code>keepAlive</code>，
  // 因為 <code>http.globalAgent</code> 預設已啟用 <code>keepAlive</code>。
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),</p><p>  // <code>proxy</code> 定義代理伺服器的主機名稱、埠號與協議。
  // 你也可以透過傳統的 <code>http_proxy</code> 和 <code>https_proxy</code> 環境變數定義代理。
  // 如果使用環境變數進行代理設定，也可以定義 <code>no_proxy</code> 環境變數，
  // 其值為不應代理的網域（以逗號分隔的清單）。
  // 使用 <code>false</code> 可停用代理，並忽略環境變數。
  // <code>auth</code> 表示應使用 HTTP Basic 認證連接代理，並提供認證資訊。
  // 這會設定 <code>Proxy-Authorization</code> 標頭，覆蓋你透過 <code>headers</code> 設定的任何現有
  // <code>Proxy-Authorization</code> 自訂標頭。
  // 如果代理伺服器使用 HTTPS，必須將 protocol 設為 <code>https</code>。
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    // hostname: '127.0.0.1' // 如果同時定義，優先使用 'hostname'
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },</p><p>  // <code>cancelToken</code> 指定可用於取消請求的取消權杖
  //（詳見下方「取消」章節）
  cancelToken: new CancelToken(function (cancel) {
  }),</p><p>  // 另一種使用 AbortController 取消 Axios 請求的方法
  signal: new AbortController().signal,</p><p>  // <code>decompress</code> 指示是否要自動解壓回應主體。
  // 如果設為 <code>true</code>，也會從所有已解壓回應的 response 物件中移除 'content-encoding' 標頭
  // - 僅適用於 Node（XHR 無法關閉解壓縮）
  decompress: true, // 預設值</p><p>  // <code>insecureHTTPParser</code> 布林值。
  // 指示是否使用可接受無效 HTTP 標頭的不安全 HTTP 解析器。
  // 這可能允許與不符合標準的 HTTP 實作互通。
  // 應避免使用不安全的解析器。
  // 參見選項 https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback</code></pre>
<pre><code class="language-">// 另請參閱 https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none
  insecureHTTPParser: undefined, // 預設值</p><p>  // 舊版本向下相容的過渡選項，未來版本可能會移除
  transitional: {
    // 靜默 JSON 解析模式
    // <code>true</code>  - 忽略 JSON 解析錯誤，解析失敗時將 response.data 設為 null（舊行為）
    // <code>false</code> - 若 JSON 解析失敗則拋出 SyntaxError（注意：responseType 必須設為 'json'）
    silentJSONParsing: true, // 目前 Axios 版本的預設值</p><p>    // 即使 <code>responseType</code> 不是 'json'，也嘗試將回應字串解析為 JSON
    forcedJSONParsing: true,</p><p>    // 請求逾時時，拋出 ETIMEDOUT 錯誤而非一般 ECONNABORTED
    clarifyTimeoutError: false,
  },</p><p>  env: {
    // 用於自動將有效負載序列化成 FormData 物件的 FormData 類別
    FormData: window?.FormData || global?.FormData
  },</p><p>  formSerializer: {
      visitor: (value, key, path, helpers) => {}, // 自定義 visitor 函式用於序列化表單數值
      dots: boolean, // 使用點號格式而非中括號格式
      metaTokens: boolean, // 保留參數 key 的特殊結尾如 {}
      indexes: boolean, // 陣列索引格式 null - 無括號, false - 空括號, true - 有索引的括號
  },</p><p>  // 僅限 http adapter（node.js）
  maxRate: [
    100 * 1024, // 上傳限制 100KB/s,
    100 * 1024  // 下載限制 100KB/s
  ]
}</code></pre></p><h2>回應結構（Response Schema）</h2></p><p>一個請求的回應包含以下資訊。</p><pre><code class="language-js">{
  // <code>data</code> 是伺服器提供的回應內容
  data: {},</p><p>  // <code>status</code> 是伺服器回應的 HTTP 狀態碼
  status: 200,</p><p>  // <code>statusText</code> 是伺服器回應的 HTTP 狀態訊息
  statusText: 'OK',</p><p>  // <code>headers</code> 是伺服器回應的 HTTP 標頭
  // 所有標頭名稱皆為小寫，可用方括號語法存取。
  // 範例：<code>response.headers['content-type']</code>
  headers: {},</p><p>  // <code>config</code> 是傳遞給 <code>axios</code> 的請求設定
  config: {},</p><p>  // <code>request</code> 是產生此回應的請求
  // 在 node.js（重定向時）為最後一個 ClientRequest 實例
  // 在瀏覽器中則為 XMLHttpRequest 實例
  request: {}
}</code></pre></p><p>當使用 <code>then</code> 時，你會收到如下的回應：</p><pre><code class="language-js">axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });</code></pre></p><p>當使用 <code>catch</code>，或在 <code>then</code> 的第二個參數傳入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">拒絕回呼函式（rejection callback）</a> 時，回應將可透過 <code>error</code> 物件取得，詳見<a href="#handling-errors" target="_blank" rel="noopener noreferrer">錯誤處理</a>章節。</p><h2>設定預設值（Config Defaults）</h2></p><p>你可以指定套用於每個請求的預設設定。</p><h3>全域 axios 預設值</h3></p><pre><code class="language-js">axios.defaults.baseURL = 'https://api.example.com';</p><p>// 重要：如果 axios 用於多個網域，AUTH_TOKEN 會被發送到所有網域。
// 如需僅對特定網域發送，請參考下方自訂實例預設值的範例。
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;</p><p>axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';</code></pre></p><h3>自訂實例預設值</h3>
<pre><code class="language-">``<code>js
// 建立實例時設定預設組態
const instance = axios.create({
  baseURL: 'https://api.example.com'
});</p><p>// 在建立實例後修改預設值
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;</code></pre></p><h3>組態優先順序</h3></p><p>組態會依照優先順序進行合併。順序為：在 <a href="https://github.com/axios/axios/blob/main/lib/defaults/index.js#L49" target="_blank" rel="noopener noreferrer">lib/defaults/index.js</a> 中定義的函式庫預設值，然後是實例的 </code>defaults<code> 屬性，最後是請求的 </code>config<code> 參數。後者會覆蓋前者。以下是一個範例。</p><pre><code class="language-js">// 使用函式庫提供的預設組態建立實例
// 此時，timeout 組態值為 </code>0<code>，這是函式庫的預設值
const instance = axios.create();</p><p>// 覆蓋函式庫的 timeout 預設值
// 現在所有使用此實例的請求都會等候 2.5 秒才會逾時
instance.defaults.timeout = 2500;</p><p>// 由於這個請求預期會花較長時間，因此單獨覆蓋 timeout
instance.get('/longRequest', {
  timeout: 5000
});</code></pre></p><h2>攔截器</h2></p><p>你可以在 </code>then<code> 或 </code>catch<code> 處理之前，攔截請求或回應。</p><pre><code class="language-js">
const instance = axios.create();</p><p>// 新增請求攔截器
instance.interceptors.request.use(function (config) {
    // 在請求發送前做些處理
    return config;
  }, function (error) {
    // 處理請求錯誤
    return Promise.reject(error);
  });</p><p>// 新增回應攔截器
instance.interceptors.response.use(function (response) {
    // 任何 2xx 範圍內的狀態碼都會觸發此函式
    // 處理回應資料
    return response;
  }, function (error) {
    // 任何不在 2xx 範圍內的狀態碼都會觸發此函式
    // 處理回應錯誤
    return Promise.reject(error);
  });</code></pre></p><p>如果你需要之後移除攔截器，可以這麼做。</p><pre><code class="language-js">const instance = axios.create();
const myInterceptor = instance.interceptors.request.use(function () {/<em>...</em>/});
axios.interceptors.request.eject(myInterceptor);</code></pre></p><p>你也可以清除所有請求或回應的攔截器。
<pre><code class="language-js">const instance = axios.create();
instance.interceptors.request.use(function () {/<em>...</em>/});
instance.interceptors.request.clear(); // 移除所有請求攔截器
instance.interceptors.response.use(function () {/<em>...</em>/});
instance.interceptors.response.clear(); // 移除所有回應攔截器</code></pre></p><p>你可以將攔截器加到自訂的 axios 實例上。</p><pre><code class="language-js">const instance = axios.create();
instance.interceptors.request.use(function () {/<em>...</em>/});</code></pre></p><p>當你新增請求攔截器時，預設會被視為非同步。這可能會導致當主執行緒被阻塞時，
axios 請求執行有延遲（攔截器底層會建立一個 promise，請求會被放到底部的呼叫堆疊）。如果你的請求攔截器是同步的，可以在選項物件中加入一個旗標，
讓 axios 以同步方式執行程式碼，避免請求執行延遲。</p><pre><code class="language-js">axios.interceptors.request.use(function (config) {
  config.headers.test = 'I am only a header!';
  return config;
}, null, { synchronous: true });</code></pre></p><p>如果你想根據執行階段檢查來執行特定攔截器，
可以在選項物件中加入 </code>runWhen<code> 函式。當且僅當 </code>runWhen<code> 的回傳值為 </code>false<code> 時，該請求攔截器才不會被執行。此函式會接收 config
物件作為參數（你也可以繫結自己的參數）。這在你有非同步請求攔截器只需在特定時機執行時會很方便。
<pre><code class="language-"></code>`<code>js
function onGetCall(config) {
  return config.method === 'get';
}
axios.interceptors.request.use(function (config) {
  config.headers.test = 'special get headers';
  return config;
}, null, { runWhen: onGetCall });</code></pre></p><blockquote><strong>注意：</strong> options 參數（包含 </code>synchronous<code> 和 </code>runWhen<code> 屬性）目前僅支援請求攔截器。</blockquote></p><h3>多重攔截器</h3></p><p>假設你添加多個回應攔截器，
當回應被 fulfill 時
<ul><li>每個攔截器都會被執行</li>
<li>它們按照被添加的順序執行</li>
<li>只有最後一個攔截器的結果會被回傳</li>
<li>每個攔截器都會收到其前一個攔截器的結果</li>
<li>當 fulfillment-interceptor 拋出異常時</li>
    <li>之後的 fulfillment-interceptor 不會被呼叫</li>
    <li>之後的 rejection-interceptor 會被呼叫</li>
    <li>一旦被捕獲，接下來的 fulfill-interceptor 會再次被呼叫（就像 promise 鏈那樣）。</li></p><p></ul>閱讀 <a href="https://raw.githubusercontent.com/axios/axios/v1.x/./test/specs/interceptors.spec.js" target="_blank" rel="noopener noreferrer">攔截器測試</a> 可查看所有相關程式碼。</p><h2>錯誤類型</h2></p><p>Axios 可能出現多種不同的錯誤訊息，這些訊息可提供關於錯誤細節的基本資訊，並指引除錯方向。</p><p>Axios 錯誤的一般結構如下：
| 屬性      | 定義  |
| -------- | ----------  |
| message  | 錯誤訊息的簡要摘要以及失敗時的狀態。 |
| name     | 定義錯誤來源。對於 axios 來說，總是 'AxiosError'。 |
| stack    | 提供錯誤的堆疊追蹤。 | 
| config   | 一個 axios config 物件，包含用戶在發出請求時設定的特定實例組態 |
| code     | 表示由 axios 辨識的錯誤。下表列出了 axios 內部錯誤的具體定義。 |
| status   | HTTP 回應狀態碼。常見 HTTP 回應狀態碼含義請參考<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener noreferrer">這裡</a>。</p><p>以下是可能由 axios 識別的錯誤列表：</p><p>| 代碼                      | 定義                                                                                                                                                                                                                                                                                                                                                                                     |
| --- | --- |
| ERR_BAD_OPTION_VALUE      | 在 axios 配置中提供了無效的值。                                                                                                                                                                                                                                                                                                                                                 |
| ERR_BAD_OPTION            | 在 axios 配置中提供了無效的選項。                                                                                                                                                                                                                                                                                                                                                |
| ERR_NOT_SUPPORT           | 目前 axios 環境不支援該功能或方法。                                                                                                                                                                                                                                                                                                                              |
| ERR_DEPRECATED            | 使用了已棄用的功能或方法。                                                                                                                                                                                                                                                                                                                                                    |
| ERR_INVALID_URL           | 為 axios 請求提供了無效的 URL。                                                                                                                                                                                                                                                                                                                                                        |
| ECONNABORTED              | 通常表示請求已逾時（除非設置了 </code>transitional.clarifyTimeoutError<code>）或被瀏覽器或其外掛中止。                                                                                                                                                                                                                                            |
| ERR_CANCELED              | 該功能或方法被用戶透過 AbortSignal（或 CancelToken）明確取消。                                                                                                                                                                                                                                                                                                  |
| ETIMEDOUT                 | 請求因超出預設 axios 時間限制而逾時。必須將 </code>transitional.clarifyTimeoutError<code> 設為 </code>true<code>，否則會拋出一般的 </code>ECONNABORTED<code> 錯誤。                                                                                                                                                                                                         |
| ERR_NETWORK               | 網路相關問題。在瀏覽器中，也可能因 <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/CORS" target="_blank" rel="noopener noreferrer">CORS</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content" target="_blank" rel="noopener noreferrer">混合內容</a> 政策違規導致。由於瀏覽器不允許 JS 程式碼明確指出安全問題的實際原因，請檢查主控台。 |
| ERR_FR_TOO_MANY_REDIRECTS | 請求被重導次數過多；超過 axios 配置中指定的最大重導次數。                                                                                                                                                                                                                                                                                                  |
| ERR_BAD_RESPONSE          | 回應無法正確解析或格式異常。通常與 </code>5xx<code> 狀態碼的回應有關。                                                                                                                                                                                                                                                                          |
| ERR_BAD_REQUEST           | 請求格式異常或缺少必要參數。通常與 </code>4xx<code> 狀態碼的回應有關。                                                                                                                                                                                                                                                                    |</p><h2>處理錯誤</h2></p><p>預設行為是對所有狀態碼不在 2xx 範圍內的回應都視為錯誤並拒絕。</p><pre><code class="language-js">axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // 請求已發出，且伺服器有回應狀態碼
      // 且狀態碼不在 2xx 範圍內
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // 請求已發出但沒有收到回應
      // </code>error.request<code> 在瀏覽器中是 XMLHttpRequest 實例，在 node.js 中是 http.ClientRequest 實例
      console.log(error.request);
    } else {
      // 設定請求時發生異常
      console.log('Error', error.message);
    }
    console.log(error.config);
  });</code></pre></p><p>使用 </code>validateStatus<code> 配置選項，可以覆寫預設條件（status >= 200 && status < 300），自訂哪些 HTTP 狀態碼應拋出錯誤。</p><pre><code class="language-js">axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // 只要狀態碼小於 500 就解決（resolve）
  }
})</code></pre></p><p>使用 </code>toJSON<code> 可取得包含更多 HTTP 錯誤資訊的物件。</p><pre><code class="language-js">axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());</code></pre>
<pre><code class="language-">
<h2>取消請求</h2></p><h3>AbortController</h3></p><p>從 </code>v0.22.0<code> 開始，Axios 支援使用 AbortController 以 fetch API 的方式取消請求：
</code></pre>js
const controller = new AbortController();</p><p>axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消請求
controller.abort()
<pre><code class="language-">
<h3>CancelToken </code>👎已棄用<code></h3></p><p>你也可以使用 <em>CancelToken</em> 來取消請求。</p><blockquote>axios 的 cancel token API 基於已撤回的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener noreferrer">cancellable promises proposal</a>。</blockquote></p><blockquote>此 API 自 v0.22.0 起已被棄用，不應在新專案中使用</blockquote></p><p>你可以像下面這樣使用 </code>CancelToken.source<code> 工廠方法來建立一個 cancel token：
</code></pre>js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();</p><p>axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // 處理錯誤
  }
});</p><p>axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})</p><p>// 取消請求（message 參數為可選）
source.cancel('Operation canceled by the user.');
<pre><code class="language-">
你也可以將 executor 函數傳給 </code>CancelToken<code> 建構子來建立 cancel token：
</code></pre>js
const CancelToken = axios.CancelToken;
let cancel;</p><p>axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函數會收到 cancel 函數作為參數
    cancel = c;
  })
});</p><p>// 取消請求
cancel();
<pre><code class="language-">
<blockquote><strong>注意：</strong>你可以使用相同的 cancel token/abort controller 來取消多個請求。</blockquote>
<blockquote>如果在發起 Axios 請求時取消 token 已經被取消，則該請求會立即被取消，不會嘗試進行實際請求。</blockquote></p><blockquote>在過渡期間，你可以同時使用這兩種取消 API，甚至用於同一個請求：</blockquote></p><h2>使用 </code>application/x-www-form-urlencoded<code> 格式</h2></p><h3>URLSearchParams</h3></p><p>預設情況下，axios 會將 JavaScript 物件序列化為 </code>JSON<code>。若要改為以 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener noreferrer"></code>application/x-www-form-urlencoded<code> 格式</a> 傳送資料，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener noreferrer"></code>URLSearchParams<code></a> API，該 API 在絕大多數瀏覽器中都已<a href="http://www.caniuse.com/#feat=urlsearchparams" target="_blank" rel="noopener noreferrer">支援</a>，且 <a href="https://nodejs.org/api/url.html#url_class_urlsearchparams" target="_blank" rel="noopener noreferrer">Node</a> 自 v10（2018 年發布）起也支援。
</code></pre>js
const params = new URLSearchParams({ foo: 'bar' });
params.append('extraparam', 'value');
axios.post('/foo', params);
<pre><code class="language-">
<h3>查詢字串（舊版瀏覽器）</h3></p><p>為了相容非常舊的瀏覽器，你可以使用 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener noreferrer">polyfill</a>（請確保全域環境已加載 polyfill）。</p><p>或者，你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"></code>qs<code></a> 函式庫進行編碼：
</code></pre>js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
<pre><code class="language-"></code>`<code>
或者用另一種方式（ES6），
</code></pre>js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
<pre><code class="language-">
<h3>舊版 Node.js</h3></p><p>對於較舊的 Node.js 引擎，你可以這樣使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener noreferrer"></code>querystring<code></a> 模組：
</code></pre>js
const querystring = require('querystring');
axios.post('https://something.com/', querystring.stringify({ foo: 'bar' }));
<pre><code class="language-">
你也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"></code>qs<code></a> 函式庫。</p><blockquote><strong>注意</strong>：如果你需要對巢狀物件進行字串化，建議使用 </code>qs<code> 函式庫，因為 </code>querystring<code> 方法在這種用例下有<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener noreferrer">已知問題</a>。</blockquote></p><h3>🆕 自動序列化為 URLSearchParams</h3></p><p>當 content-type 標頭設為 "application/x-www-form-urlencoded" 時，Axios 會自動將 data 物件序列化為 urlencoded 格式。
</code></pre>js
const data = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
};</p><p>await axios.postForm('https://postman-echo.com/post', data,
  {headers: {'content-type': 'application/x-www-form-urlencoded'}}
);
<pre><code class="language-">
伺服器將會將其處理為：
</code></pre>js
  {
    x: '1',
    'arr[]': [ '1', '2', '3' ],
    'arr2[0]': '1',
    'arr2[1][0]': '2',
    'arr2[2]': '3',
    'arr3[]': [ '1', '2', '3' ],
    'users[0][name]': 'Peter',
    'users[0][surname]': 'griffin',
    'users[1][name]': 'Thomas',
    'users[1][surname]': 'Anderson'
  }
<pre><code class="language-">
如果你的後端 body-parser（如 </code>express.js<code> 的 </code>body-parser<code>）支援巢狀物件解碼，你會在伺服器端自動獲得相同的物件
</code></pre>js
  var app = express();</p><p>  app.use(bodyParser.urlencoded({ extended: true })); // 支援編碼主體</p><p>  app.post('/', function (req, res, next) {
     // 以 JSON 回傳 body
     res.send(JSON.stringify(req.body));
  });</p><p>  server = app.listen(3000);
<pre><code class="language-">
<h2>使用 </code>multipart/form-data<code> 格式</h2></p><h3>FormData</h3></p><p>若要將資料以 </code>multipart/formdata<code> 發送，你需要傳遞一個 formData 實例作為負載。
不需要手動設置 </code>Content-Type<code> 標頭，Axios 會根據負載型別自動判斷。
</code></pre>js
const formData = new FormData();
formData.append('foo', 'bar');</p><p>axios.post('https://httpbin.org/post', formData);
<pre><code class="language-">
在 node.js 中，你可以這樣使用 <a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"></code>form-data<code></a> 函式庫：
</code></pre>js
const FormData = require('form-data');</p><p>const form = new FormData();
form.append('my_field', 'my value');
form.append('my_buffer', new Buffer(10));
form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
<pre><code class="language-">axios.post('https://example.com', form)</code></pre></p><h3>🆕 自動序列化為 FormData</h3></p><p>從 </code>v0.27.0<code> 開始，若請求的 </code>Content-Type<code> 標頭設為 </code>multipart/form-data<code>，Axios 支援自動將物件序列化為 FormData 物件。</p><p>以下請求將以 FormData 格式提交資料（瀏覽器 & Node.js）：</p><pre><code class="language-js">import axios from 'axios';</p><p>axios.post('https://httpbin.org/post', {x: 1}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));</code></pre></p><p>在 </code>node.js<code> 版本中，預設會使用 (<a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"></code>form-data<code></a>) polyfill。</p><p>你可以透過設定 </code>env.FormData<code> 配置變數來覆寫 FormData 類別，
但大多數情況下你可能不需要這麼做：</p><pre><code class="language-js">const axios = require('axios');
var FormData = require('form-data');</p><p>axios.post('https://httpbin.org/post', {x: 1, buf: new Buffer(10)}, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}).then(({data}) => console.log(data));</code></pre></p><p>Axios FormData 序列化器支援一些特殊結尾以執行以下操作：</p><ul><li></code>{}<code> - 使用 JSON.stringify 將值序列化</li>
<li></code>[]<code> - 將類陣列物件解包為具有相同鍵名的多個欄位</li></p><p></ul>> <strong>注意</strong>：對於陣列和 FileList 物件，預設會使用解包/展開操作</p><p>FormData 序列化器支援通過 </code>config.formSerializer: object<code> 屬性提供額外選項以處理少見情境：</p><ul><li></code>visitor: Function<code> - 使用者自訂的 visitor 函式，將根據自訂規則遞迴將資料物件序列化為 </code>FormData<code> 物件。</li></p><p><li></code>dots: boolean = false<code> - 使用點號表示法而非中括號來序列化陣列和物件；</li></p><p><li></code>metaTokens: boolean = true<code> - 在 FormData 的鍵中添加特殊結尾（例如 </code>user{}: '{"name": "John"}'<code>）。</li>
</ul>後端 body-parser 可以利用這個中繼資訊自動將值解析為 JSON。</p><ul><li></code>indexes: null|false|true = false<code> - 控制對 </code>flat<code> 類陣列物件解包鍵時索引的添加方式。</li></p><p>    <li></code>null<code> - 不加中括號（</code>arr: 1<code>, </code>arr: 2<code>, </code>arr: 3<code>）</li>
    <li></code>false<code>(預設) - 加空中括號（</code>arr[]: 1<code>, </code>arr[]: 2<code>, </code>arr[]: 3<code>）</li>
    <li></code>true<code> - 加帶索引的中括號（</code>arr[0]: 1<code>, </code>arr[1]: 2<code>, </code>arr[2]: 3<code>）</li></p><p></ul>假設我們有如下物件：</p><pre><code class="language-js">const obj = {
  x: 1,
  arr: [1, 2, 3],
  arr2: [1, [2], 3],
  users: [{name: 'Peter', surname: 'Griffin'}, {name: 'Thomas', surname: 'Anderson'}],
  'obj2{}': [{x:1}]
};</code></pre></p><p>以下步驟將由 Axios 的序列化器在內部執行：</p><pre><code class="language-js">const formData = new FormData();
formData.append('x', '1');
formData.append('arr[]', '1');
formData.append('arr[]', '2');
formData.append('arr[]', '3');
formData.append('arr2[0]', '1');
formData.append('arr2[1][0]', '2');
formData.append('arr2[2]', '3');
formData.append('users[0][name]', 'Peter');
formData.append('users[0][surname]', 'Griffin');
formData.append('users[1][name]', 'Thomas');
formData.append('users[1][surname]', 'Anderson');
formData.append('obj2{}', '[{"x":1}]');</code></pre></p><p>Axios 支援以下快捷方法：</code>postForm<code>、</code>putForm<code>、</code>patchForm<code>
這些方法僅是對應的 http 方法，且預設已設置 </code>Content-Type<code> 標頭為 </code>multipart/form-data<code>。</p><h2>檔案上傳</h2></p><p>你可以輕鬆提交單一檔案：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', {
  'myVar' : 'foo',
  'file': document.querySelector('#fileInput').files[0]
});</code></pre></p><p>或多個檔案作為 </code>multipart/form-data<code> 上傳：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', {
  'files[]': document.querySelector('#fileInput').files
});</code></pre></p><p>可以直接傳遞 </code>FileList<code> 物件：</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', document.querySelector('#fileInput').files)</code></pre></p><p>所有檔案都將使用相同的欄位名稱傳送：</code>files[]<code>。</p><h2>🆕 HTML 表單提交（瀏覽器）</h2></p><p>傳遞 HTML 表單元素作為載荷，可以將其作為 </code>multipart/form-data<code> 內容提交。</p><pre><code class="language-js">await axios.postForm('https://httpbin.org/post', document.querySelector('#htmlForm'));</code></pre></p><p></code>FormData<code> 和 </code>HTMLForm<code> 物件也可以透過明確設定 </code>Content-Type<code> 標頭為 </code>application/json<code>，作為 </code>JSON<code> 提交：</p><pre><code class="language-js">await axios.post('https://httpbin.org/post', document.querySelector('#htmlForm'), {
  headers: {
    'Content-Type': 'application/json'
  }
})</code></pre></p><p>例如，以下表單</p><pre><code class="language-html"><form id="form">
  <input type="text" name="foo" value="1">
  <input type="text" name="deep.prop" value="2">
  <input type="text" name="deep prop spaced" value="3">
  <input type="text" name="baz" value="4">
  <input type="text" name="baz" value="5"></p><p>  <select name="user.age">
    <option value="value1">Value 1</option>
    <option value="value2" selected>Value 2</option>
    <option value="value3">Value 3</option>
  </select></p><p>  <input type="submit" value="Save">
</form></code></pre></p><p>將會被提交為以下 JSON 物件：</p><pre><code class="language-js">{
  "foo": "1",
  "deep": {
    "prop": {
      "spaced": "3"
    }
  },
  "baz": [
    "4",
    "5"
  ],
  "user": {
    "age": "value2"
  }
}</code></pre></code></p><p>目前不支援將 <code>Blobs</code>/<code>Files</code> 作為 JSON（<code>base64</code>）傳送。</p><h2>🆕 進度捕捉</h2></p><p>Axios 支援在瀏覽器和 Node 環境中捕捉請求的上傳/下載進度。
進度事件的頻率會被強制限制為每秒 <code>3</code> 次。</p><p>``<code>js    
await axios.post(url, data, {
  onUploadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number; // 範圍 [0..1]
      bytes: number; // 自上次觸發以來已傳輸的位元組數（增量）
      estimated?: number; // 預估剩餘秒數
      rate?: number; // 上傳速度（位元組/秒）
      upload: true; // 上傳標誌
    }*/
  },</p><p>  onDownloadProgress: function (axiosProgressEvent) {
    /*{
      loaded: number;
      total?: number;
      progress?: number;
      bytes: number; 
      estimated?: number;
      rate?: number; // 下載速度（以位元組為單位）
      download: true; // 下載標誌
    }*/
  }
});  
<pre><code class="language-">
你也可以在 node.js 中追蹤串流的上傳/下載進度：
</code></pre>js
const {data} = await axios.post(SERVER_URL, readableStream, {
   onUploadProgress: ({progress}) => {
     console.log((progress * 100).toFixed(2));
   },
  
   headers: {
    'Content-Length': contentLength
   },</p><p>   maxRedirects: 0 // 避免將整個串流緩衝到記憶體
});
</code><pre><code class="language-">
<blockquote><strong>注意：</strong></blockquote>
<blockquote>目前在 node.js 環境下尚不支援捕捉 FormData 上傳進度。</blockquote></p><blockquote><strong>⚠️ 警告</strong></blockquote>
<blockquote>建議在 <strong>node.js</strong> 環境中將 maxRedirects 設為 0 來禁用重導向，</blockquote>
<blockquote>因為 follow-redirects 套件會將整個串流緩衝到記憶體中，無法遵循「背壓」演算法。</blockquote></p><h2>🆕 速率限制</h2></p><p>下載與上傳速率限制僅能於 http adapter（node.js）中設定：
</code></pre>js
const {data} = await axios.post(LOCAL_SERVER_URL, myBuffer, {
  onUploadProgress: ({progress, rate}) => {
    console.log(<code>上傳 [${(progress*100).toFixed(2)}%]: ${(rate / 1024).toFixed(2)}KB/s</code>)
  },
   
  maxRate: [100 * 1024], // 100KB/s 限速
});
<pre><code class="language-">
<h2>🆕 AxiosHeaders</h2></p><p>Axios 有自己的 <code>AxiosHeaders</code> 類別，可以使用類似 Map 的 API 操作標頭，保證不分大小寫的運作。
雖然 HTTP 標頭本身不區分大小寫，Axios 為了風格及因應某些伺服器錯誤地區分大小寫的情況，會保留原始標頭的大小寫。
直接操作 headers 物件的舊方式仍然可用，但已被棄用，不建議未來繼續使用。</p><h3>操作 headers</h3></p><p>AxiosHeaders 物件實例可以包含不同類型的內部值，這些值控制設定與合併的邏輯。
最終只含字串值的 headers 物件，會透過 Axios 調用 <code>toJSON</code> 方法取得。</p><blockquote>注意：這裡的 JSON 是指一個只包含字串值、用於網路傳輸的物件。</blockquote></p><p>標頭值可以是下列其中之一：
<ul><li><code>string</code> - 正常的字串值，會傳送到伺服器</li>
<li><code>null</code> - 渲染成 JSON 時略過此標頭</li>
<li><code>false</code> - 渲染成 JSON 時略過此標頭，並且表示必須使用 <code>rewrite</code> 選項呼叫 <code>set</code> 方法覆寫此值（Axios 內部用於讓使用者選擇不安裝如 <code>User-Agent</code> 或 <code>Content-Type</code> 等特定標頭）</li>
<li><code>undefined</code> - 尚未設定值</li></p><p></ul>> 注意：只要標頭值不等於 undefined，就被視為已設定。</p><p>headers 物件會在攔截器與轉換器內部初始化：
</code></pre>ts
  axios.interceptors.request.use((request: InternalAxiosRequestConfig) => {
      request.headers.set('My-header', 'value');</p><p>      request.headers.set({
        "My-set-header1": "my-set-value1",
        "My-set-header2": "my-set-value2"
      });
      
      request.headers.set('User-Agent', false); // 禁止 Axios 後續設定此標頭</p><p>      request.headers.setContentType('text/plain');
    
      request.headers['My-set-header2'] = 'newValue' // 直接存取已被棄用
    
      return request;
    }
  );
<code><pre><code class="language-">
你可以用 </code>for...of<code> 迴圈遍歷 </code>AxiosHeaders<code> 實例：
</code></pre></code>js
const headers = new AxiosHeaders({
  foo: '1',
<pre><code class="language-js">  bar: '2',
  baz: '3'
});</p><p>for(const [header, value] of headers) {
  console.log(header, value);
}</p><p>// foo 1
// bar 2
// baz 3</code></pre><code></p><h3>new AxiosHeaders(headers?)</h3></p><p>建立一個新的 </code>AxiosHeaders<code> 實例。</p><pre><code class="language-">constructor(headers?: RawAxiosHeaders | AxiosHeaders | string);</code></pre></p><p>如果 headers 物件是一個字串，將會被解析為 RAW HTTP 標頭。</p><p></code><pre><code class="language-js">const headers = new AxiosHeaders(<code>
Host: www.bing.com
User-Agent: curl/7.54.0
Accept: <em>/</em></code>);</p><p>console.log(headers);</p><p>// Object [AxiosHeaders] {
//   host: 'www.bing.com',
//   'user-agent': 'curl/7.54.0',
//   accept: '<em>/</em>'
// }</code></pre><code></p><h3>AxiosHeaders#set</h3></p><pre><code class="language-ts">set(headerName, value: Axios, rewrite?: boolean);
set(headerName, value, rewrite?: (this: AxiosHeaders, value: string, name: string, headers: RawAxiosHeaders) => boolean);
set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean);</code></pre></p><p></code>rewrite<code> 參數用於控制覆寫行為：
<ul><li></code>false<code> - 如果標頭的值已設置（不是 </code>undefined<code>），則不覆寫</li>
<li></code>undefined<code>（預設）- 除非其值設為 </code>false<code>，否則覆寫標頭</li>
<li></code>true<code> - 無論如何都覆寫</li></p><p></ul>這個選項也可以接受一個自定義函式，決定是否應該覆寫該值。</p><p>回傳 </code>this<code>。</p><h3>AxiosHeaders#get(header)</h3></p><pre><code class="language-">  get(headerName: string, matcher?: true | AxiosHeaderMatcher): AxiosHeaderValue;
  get(headerName: string, parser: RegExp): RegExpExecArray | null;</code></pre></code></p><p>回傳標頭的內部值。它可以接受額外參數，使用 <code>RegExp.exec</code>、匹配函式或內部 key-value 解析器解析標頭的值。</p><pre><code class="language-ts">const headers = new AxiosHeaders({
  'Content-Type': 'multipart/form-data; boundary=Asrf456BGe4h'
});</p><p>console.log(headers.get('Content-Type')); 
// multipart/form-data; boundary=Asrf456BGe4h</p><p>console.log(headers.get('Content-Type', true)); // 解析以 \s,;= 分隔的字串中的 key-value 對：
// [Object: null prototype] {
//   'multipart/form-data': undefined,
//    boundary: 'Asrf456BGe4h'
// }</p><p>
console.log(headers.get('Content-Type', (value, name, headers) => {
  return String(value).replace(/a/g, 'ZZZ');
}));
// multipZZZrt/form-dZZZtZZZ; boundZZZry=Asrf456BGe4h</p><p>console.log(headers.get('Content-Type', /boundary=(\w+)/)?.[0]);
// boundary=Asrf456BGe4h
</code></pre></p><p>回傳標頭的值。</p><h3>AxiosHeaders#has(header, matcher?)</h3></p><pre><code class="language-">has(header: string, matcher?: AxiosHeaderMatcher): boolean;</code></pre></p><p>如果標頭已設定（值不是 <code>undefined</code>），則回傳 <code>true</code>。
<pre><code class="language-">### AxiosHeaders#delete(header, matcher?)
</code></pre>
delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;
<pre><code class="language-">
如果至少有一個標頭被移除，則回傳 <code>true</code>。</p><h3>AxiosHeaders#clear(matcher?)</h3>
</code></pre>
clear(matcher?: AxiosHeaderMatcher): boolean;
<pre><code class="language-">
移除所有標頭。
與 <code>delete</code> 方法的 matcher 不同，此可選的 matcher 會用來比對標頭名稱而非值。
</code></pre>ts
const headers = new AxiosHeaders({
  'foo': '1',
  'x-foo': '2',
  'x-bar': '3',
});</p><p>console.log(headers.clear(/^x-/)); // true</p><p>console.log(headers.toJSON()); // [Object: null prototype] { foo: '1' }
<pre><code class="language-">
如果至少有一個標頭被清除，則回傳 <code>true</code>。</p><h3>AxiosHeaders#normalize(format);</h3></p><p>如果 headers 物件被直接修改，可能會有名稱相同但大小寫不同的重複項。
此方法會將 headers 物件標準化，將重複的鍵合併為一個。
Axios 在呼叫每個攔截器後會在內部使用此方法。
將 <code>format</code> 設為 true 時，會將標頭名稱轉為小寫並將首字母大寫（如 <code>cOntEnt-type</code> => <code>Content-Type</code>）
</code></pre>js
const headers = new AxiosHeaders({
  'foo': '1',
});</p><p>headers.Foo = '2';
headers.FOO = '3';</p><p>console.log(headers.toJSON()); // [Object: null prototype] { foo: '1', Foo: '2', FOO: '3' }
console.log(headers.normalize().toJSON()); // [Object: null prototype] { foo: '3' }
console.log(headers.normalize(true).toJSON()); // [Object: null prototype] { Foo: '3' }
<pre><code class="language-">
回傳 <code>this</code>。</p><h3>AxiosHeaders#concat(...targets)</h3>
</code></pre>
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
<pre><code class="language-">
將當前實例與目標合併為新的 <code>AxiosHeaders</code> 實例。如果目標是字串，則會解析為 RAW HTTP 標頭。</p><p>回傳新的 <code>AxiosHeaders</code> 實例。</p><h3>AxiosHeaders#toJSON(asStrings?)</h3>
</code></pre><code>
toJSON(asStrings?: boolean): RawAxiosHeaders;
</code><pre><code class="language-">
將所有內部標頭值解析為新的 null prototype 物件。
將 <code>asStrings</code> 設為 true 時，陣列會轉為用逗號分隔的字串。</p><h3>AxiosHeaders.from(thing?)</h3>
</code></pre><code>
from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;
</code><pre><code class="language-">
回傳從傳入的原始標頭建立的新 <code>AxiosHeaders</code> 實例，
或如果傳入的是 <code>AxiosHeaders</code> 實例則直接回傳該物件。</p><h3>AxiosHeaders.concat(...targets)</h3>
</code></pre><code>
concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;
</code><pre><code class="language-">
回傳由合併目標物件所建立的新 <code>AxiosHeaders</code> 實例。</p><h3>快捷方法</h3></p><p>可用的快捷方法如下：</p><ul><li><code>setContentType</code>, <code>getContentType</code>, <code>hasContentType</code></li></p><p><li><code>setContentLength</code>, <code>getContentLength</code>, <code>hasContentLength</code></li></p><p><li><code>setAccept</code>, <code>getAccept</code>, <code>hasAccept</code></li></p><p><li><code>setUserAgent</code>, <code>getUserAgent</code>, <code>hasUserAgent</code></li>
<li><code>setContentEncoding</code>、<code>getContentEncoding</code>、<code>hasContentEncoding</code></li></p><p></ul><h2>🔥 Fetch 適配器</h2></p><p>Fetch 適配器於 <code>v1.7.0</code> 中引入。預設情況下，若建構中未提供 <code>xhr</code> 和 <code>http</code> 適配器，或環境不支援，則將使用它。
若要預設使用，必須明確選擇：
</code></pre>js
const {data} = axios.get(url, {
  adapter: 'fetch' // 預設為 ['xhr', 'http', 'fetch']
})
<pre><code class="language-">
你也可以為此建立一個獨立的實例：
</code></pre>js
const fetchAxios = axios.create({
  adapter: 'fetch'
});</p><p>const {data} = fetchAxios.get(url);
<pre><code class="language-">
此適配器支援與 <code>xhr</code> 適配器相同的功能，<strong>包括上傳及下載進度監控</strong>。
此外，還支援額外的回應類型，如 <code>stream</code> 和 <code>formdata</code>（若環境支援）。</p><h2>Semver</h2></p><p>在 axios 發布 <code>1.0</code> 版本之前，所有重大變更都會以新次要版本發布。例如 <code>0.5.1</code> 和 <code>0.5.4</code> 會有相同的 API，但 <code>0.6.0</code> 則會有重大變更。</p><h2>Promises</h2></p><p>axios 依賴於原生 ES6 Promise 實作來獲得<a href="https://caniuse.com/promises" target="_blank" rel="noopener noreferrer">支援</a>。
若你的環境不支援 ES6 Promises，你可以<a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener noreferrer">使用 polyfill</a>。</p><h2>TypeScript</h2></p><p>axios 內建 <a href="https://typescriptlang.org" target="_blank" rel="noopener noreferrer">TypeScript</a> 型別定義以及 axios 錯誤的型別守衛。
</code></pre>typescript
let user: User = null;
try {
  const { data } = await axios.get('/user?ID=12345');
  user = data.userDetails;
} catch (error) {
  if (axios.isAxiosError(error)) {
    handleAxiosError(error);
  } else {
    handleUnexpectedError(error);
  }
}
``<code></p><p>由於 axios 同時以 ESM 預設匯出和 CJS 的 </code>module.exports<code> 發布，因此有些注意事項。
建議設定 </code>"moduleResolution": "node16"<code>（這也由 </code>"module": "node16"<code> 隱含）。請注意，這需要 TypeScript 4.7 或以上版本。
如果使用 ESM，你的設定應該沒問題。
如果你將 TypeScript 編譯為 CJS 而不能使用 </code>"moduleResolution": "node16"<code>，則必須啟用 </code>esModuleInterop<code>。
若你用 TypeScript 來型別檢查 CJS JavaScript 程式碼，你唯一選擇就是使用 </code>"moduleResolution": "node16"<code>。</p><h2>線上一鍵設置</h2></p><p>你可以使用 Gitpod，一個線上 IDE（對於開源專案免費），來貢獻或在線上運行範例。</p><p><a href="https://gitpod.io/#https://github.com/axios/axios/blob/main/examples/server.js" target="_blank" rel="noopener noreferrer"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod"></a></p><h2>資源</h2></p><ul><li><a href="https://github.com/axios/axios/blob/v1.x/CHANGELOG.md" target="_blank" rel="noopener noreferrer">Changelog</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/ECOSYSTEM.md" target="_blank" rel="noopener noreferrer">Ecosystem</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/CONTRIBUTING.md" target="_blank" rel="noopener noreferrer">Contributing Guide</a></li>
<li><a href="https://github.com/axios/axios/blob/v1.x/CODE_OF_CONDUCT.md" target="_blank" rel="noopener noreferrer">Code of Conduct</a></li></p><p></ul><h2>鳴謝</h2></p><p>axios 深受 <a href="https://angularjs.org/" target="_blank" rel="noopener noreferrer">AngularJS</a> 所提供的 <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank" rel="noopener noreferrer">$http 服務</a> 啟發。最終，axios 致力於提供一個獨立於 AngularJS 之外可用的 </code>$http` 類服務。</p><h2>授權</h2></p><p><a href="LICENSE" target="_blank" rel="noopener noreferrer">MIT</a></p><p>
---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-30

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/axios/axios/v1.x/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>