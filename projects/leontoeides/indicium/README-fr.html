<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>indicium - Une recherche simple en m&#233;moire pour les collections et les magasins cl&#233;-valeur.</title>
    <meta name="description" content="Une recherche simple en m&#233;moire pour les collections et les magasins cl&#233;-valeur.">
    <meta name="keywords" content="indicium, French, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "indicium",
  "description": "Une recherche simple en mémoire pour les collections et les magasins clé-valeur.",
  "author": {
    "@type": "Person",
    "name": "leontoeides"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 80
  },
  "url": "https://OpenAiTx.github.io/projects/leontoeides/indicium/README-fr.html",
  "sameAs": "https://raw.githubusercontent.com/leontoeides/indicium/main/README.md",
  "datePublished": "2026-01-06",
  "dateModified": "2026-01-06"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/leontoeides/indicium" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    indicium
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 80 stars</span>
                <span class="language">French</span>
                <span>by leontoeides</span>
            </div>
        </div>
        
        <div class="content">
            <h1>indicium</h1>
<img src="https://img.shields.io/crates/v/indicium" alt="Crates.io Version">
<img src="https://img.shields.io/crates/msrv/indicium" alt="Crates.io MSRV">
<img src="https://img.shields.io/crates/l/indicium" alt="Crates.io License">
<img src="https://img.shields.io/crates/d/indicium" alt="Crates.io Total Downloads"></p><p>Une recherche simple en mémoire pour des collections (<code>Vec</code>, <code>HashMap</code>, <code>BTreeMap</code>, etc.)
et des magasins clé-valeur. Offre la complétion automatique et la correspondance approximative.</p><p>Il existe de nombreux moteurs de recherche incroyables disponibles pour Rust. Beaucoup semblent
nécessiter la compilation d’un binaire serveur séparé. Je voulais quelque chose de simple et
léger - une crate facile à utiliser qui pourrait rechercher commodément des structures et
collections dans mon propre binaire. Alors, j’ai créé <code>indicium</code>.</p><p><img src="https://www.arkiteq.io/crates/indicium/banner.jpg" alt="Indicium: A Simple In-Memory Search for Rust" width="400"/></p><p>Bien que <code>indicium</code> ait été conçu pour les applications web, c’est une recherche en mémoire et
elle ne s’adapte pas indéfiniment ni à l’échelle du cloud (c’est-à-dire à l’échelle de Facebook ou Google).
Même dans un tel environnement, ce serait toujours un moyen pratique de rechercher
de grandes listes (comme des devises, langues, pays, etc.) C’est aussi idéal pour
des applications où une limite d’échelle est prévue (c’est-à-dire la recherche dans une liste
d’actifs d’entreprise, liste d’utilisateurs dans un intranet d’entreprise, etc.)</p><p>Indicium peut facilement gérer des millions d’enregistrements sans sourciller grâce
au <a href="https://cglab.ca/~abeinges/blah/rust-btree-case/" target="_blank" rel="noopener noreferrer">BTreeMap</a> de Rust. Cette
crate est principalement limitée par la mémoire disponible. Cependant, selon la nature
de votre jeu de données et s’il y a des mots-clés répétés de nombreuses fois,
les performances peuvent commencer à se dégrader à un certain point.</p><h1>Installation</h1></p><p>Configurez les dépendances dans le fichier <code>Cargo.toml</code> de votre projet :</p><pre><code class="language-toml">[dependencies]
indicium = "0.6"</code></pre></p><h1>Notes de version</h1></p><ul><li>Les notes de version sont disponibles sur</li>
  </ul><a href="https://github.com/leontoeides/indicium/releases" target="_blank" rel="noopener noreferrer">GitHub</a>.</p><ul><li>Le <a href="https://github.com/leontoeides/indicium/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">journal des modifications</a> complet est</li>
  </ul>disponible sur GitHub.</p><h1>Guide de démarrage rapide</h1></p><p>Pour notre exemple de <strong>Guide de démarrage rapide</strong>, nous allons effectuer une recherche à l’intérieur de la
<code>struct</code> suivante :</p><pre><code class="language-rust">struct MyStruct {
    title: String,
    year: u16,
    body: String,
}</code></pre></p><h2>1. Implémentation de Indexable</h2></p><p>Pour commencer, nous devons rendre notre enregistrement indexable. Nous allons le faire en implémentant le
trait <code>Indexable</code> pour notre <code>struct</code>. L'idée est de retourner une <code>String</code> pour chaque
champ que nous souhaitons indexer. Exemple :</p><pre><code class="language-rust">use indicium::simple::Indexable;</p><p>impl Indexable for MyStruct {
    fn strings(&self) -> Vec<String> {
        vec![
            self.title.clone(),
            self.year.to_string(),
            self.body.clone(),
        ]
    }
}</code></pre></p><p>N'oubliez pas que vous pouvez rendre les nombres, identifiants numériques, énumérations et autres
types dans votre <code>struct</code> (ou autres types complexes) indexables en les convertissant en
<code>String</code> et en les incluant dans le <code>Vec<String></code> retourné.</p><h2>2. Indexation d'une collection</h2></p><p>Pour indexer une collection existante, nous pouvons itérer sur la collection. Pour chaque
enregistrement, nous l'insérerons dans l'index de recherche. Cela devrait ressembler à
ces deux exemples :</p><p>#### Vec</p><pre><code class="language-rust">use indicium::simple::SearchIndex;</p><p>let my_vec: Vec<MyStruct> = Vec::new();</p><p>// In the case of a <code>Vec</code> collection, we use the index as our key. A
// <code>Vec</code> index is a <code>usize</code> type. Therefore we will instantiate
// <code>SearchIndex</code> as <code>SearchIndex<usize></code>.</p><p>let mut search_index: SearchIndex<usize> = SearchIndex::default();</p><p>my_vec
    .iter()
    .enumerate()
    .for_each(|(index, element)|
        search_index.insert(&index, element)
    );</code></pre></p><p>#### HashMap</p><pre><code class="language-rust">use std::collections::HashMap;
use indicium::simple::SearchIndex;</p><p>let my_hash_map: HashMap<String, MyStruct> = HashMap::new();</p><p>// In the case of a <code>HashMap</code> collection, we use the hash map's key as
// the <code>SearchIndex</code> key. In our hypothetical example, we will use
// MyStruct's <code>title</code> as a the key which is a <code>String</code> type. Therefore
// we will instantiate <code>HashMap<K, V></code> as HashMap<String, MyStruct> and
// <code>SearchIndex<K></code> as <code>SearchIndex<String></code>.</p><p>let mut search_index: SearchIndex<String> = SearchIndex::default();</p><p>my_hash_map
    .iter()
    .for_each(|(key, value)|
        search_index.insert(key, value)
    );</code></pre></p><p>Tant que le trait <code>Indexable</code> a été implémenté pour votre type de valeur, les exemples ci-dessus
indexeront un <code>Vec</code> ou un <code>HashMap</code> préalablement rempli. Cependant,
la méthode préférée pour les grandes collections est de <code>insert</code> dans le <code>SearchIndex</code> au fur et à mesure
que vous insérez dans votre collection (Vec, HashMap, etc.)</p><p>Il est recommandé d'encapsuler votre collection cible (votre <code>Vec</code>, <code>HashMap</code>, etc.)
et ce <code>SearchIndex</code> ensemble dans un nouveau type <code>struct</code>. Ensuite, implémentez les
méthodes <code>insert</code>, <code>replace</code>, <code>remove</code>, etc. pour ce nouveau type <code>struct</code> qui
mettront à jour à la fois la collection et l'index de recherche. Cela garantira que votre
collection et l'index sont toujours synchronisés.</p><p>Une fois l'index peuplé, vous pouvez utiliser les méthodes <code>search</code> et <code>autocomplete</code>.</p><h2>3. Recherche</h2></p><p>La méthode <code>search</code> renverra des clés comme résultats de recherche. Chaque clé résultante
peut ensuite être utilisée pour récupérer l'enregistrement complet dans sa collection.</p><p>Utilisation basique :</p><pre><code class="language-rust">let mut search_index: SearchIndex<usize> = SearchIndex::default();</p><p>search_index.insert(&0, &"Harold Godwinson");
search_index.insert(&1, &"Edgar Ætheling");
search_index.insert(&2, &"William the Conqueror");
search_index.insert(&3, &"William Rufus");
search_index.insert(&4, &"Henry Beauclerc");</p><p>let resulting_keys: Vec<&usize> = search_index.search("William");</p><p>assert_eq!(resulting_keys, vec![&2, &3]);</p><p>// Demonstrating fuzzy matching:</p><p>let resulting_keys: Vec<&usize> = search_index.search("Harry");</p><p>assert_eq!(resulting_keys, vec![&0]);</code></pre></p><p>La recherche ne prend en charge que les correspondances exactes de mots-clés. Pour les recherches <code>Live</code>, la correspondance approximative
n'est appliquée qu'au dernier mot-clé. Envisagez de fournir la fonctionnalité <code>autocomplete</code>
à vos utilisateurs pour les aider à construire leur recherche au fur et à mesure de la frappe.</p><h2>4. Autocomplétion</h2></p><p>La méthode <code>autocomplete</code> fournira plusieurs options d'autocomplétion pour le
dernier mot-clé dans la chaîne fournie.</p><p>Utilisation basique :</p><pre><code class="language-rust">let mut search_index: SearchIndex<usize> =
    SearchIndexBuilder::default()
        .autocomplete_type(&AutocompleteType::Global)
        .build();</p><p>search_index.insert(&0, &"apple");
search_index.insert(&1, &"ball");
search_index.insert(&3, &"bird");
search_index.insert(&4, &"birthday");
search_index.insert(&5, &"red");</p><p>let autocomplete_options: Vec<String> =
    search_index.autocomplete("a very big bi");</p><p>assert_eq!(
    autocomplete_options,
    vec!["a very big bird", "a very big birthday"]
);</p><p>// Demonstrating fuzzy matching:</p><p>let autocomplete_options: Vec<String> =
    search_index.autocomplete("a very big birf");</p><p>assert_eq!(
    autocomplete_options,
    vec!["a very big bird", "a very big birthday"]
);</code></pre></p><h1>Points Bonus</h1></p><h2>5. Ordre Personnalisé des Résultats</h2></p><p>À l'exception de <code>SearchType::Or</code> qui utilise le score de pertinence, les résultats
de recherche sont retournés dans l'ordre défini par l'implémentation <code>Ord</code>
de votre type de clé. Cela signifie que vous pouvez contrôler l'ordre des résultats
en utilisant un type de clé personnalisé au lieu de simples entiers ou chaînes.</p><p>Par exemple, si vous souhaitez que les éléments populaires apparaissent en premier
dans les résultats de recherche, vous pouvez créer une clé qui trie par popularité :</p><pre><code class="language-rust">use std::cmp::Ordering;
use std::hash::{Hash, Hasher};</p><p>/// A search key that sorts results by popularity (highest first).
#[derive(Debug, Clone)]
pub struct RankedKey {
    pub id: String,
    pub popularity: u32,
}</p><p>impl Ord for RankedKey {
    fn cmp(&self, other: &Self) -> Ordering {
        // Higher popularity comes first
        other.popularity.cmp(&self.popularity)
    }
}</p><p>impl PartialOrd for RankedKey {
    fn partial_cmp(&self, other: &Self) -> Option {
        Some(self.cmp(other))
    }
}</p><p>// For equality and lookups, we only compare the id, not popularity. This lets
// us find records in a HashMap using just the id.</p><p>impl PartialEq for RankedKey {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}</p><p>impl Eq for RankedKey {}</p><p>impl Hash for RankedKey {
    fn hash(&self, state: &mut H) {
        self.id.hash(state);
    }
}</code></pre></p><p>Maintenant, lorsque vous effectuez une recherche, les résultats reviennent automatiquement triés par popularité. Aucune
étape de tri supplémentaire n'est nécessaire.</p><p>Ce modèle fonctionne pour tout signal de classement : récence, scores de pertinence, ordre de tri manuel, etc. Il suffit de changer ce que <code>Ord</code> compare.</p><h3>Utilisation des clés pour les recherches</h3></p><p>Après la recherche, vous récupérez généralement l'enregistrement complet de votre collection :</p><pre><code class="language-rust">let results = search_index.search("dawn");</p><p>for key in results {
    if let Some(record) = my_records.get(key) {
        println!("{:?}", record);
    }
}</code></pre>
Parce que les traits <code>Eq</code> et <code>Hash</code> que nous avons implémentés dans l'exemple ne regardent que le champ <code>id</code> (pas <code>popularity</code>), vous pouvez toujours utiliser directement les clés des résultats de recherche pour les recherches dans <code>HashMap</code>.</p><h1>État du Crate</h1></p><p>Ce crate est maintenu de manière passive. Ce crate fait ce qu'on attend de lui et
le fait assez bien, à mon avis. Des mises à jour fréquentes ne sont pas prévues.</p><p>
---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2026-01-06

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/leontoeides/indicium/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2026-01-06 
    </div>
    
</body>
</html>