<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>indicium - Una b&#250;squeda sencilla en memoria para colecciones y almacenes clave-valor.</title>
    <meta name="description" content="Una b&#250;squeda sencilla en memoria para colecciones y almacenes clave-valor.">
    <meta name="keywords" content="indicium, Spanish, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "indicium",
  "description": "Una búsqueda sencilla en memoria para colecciones y almacenes clave-valor.",
  "author": {
    "@type": "Person",
    "name": "leontoeides"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 80
  },
  "url": "https://OpenAiTx.github.io/projects/leontoeides/indicium/README-es.html",
  "sameAs": "https://raw.githubusercontent.com/leontoeides/indicium/main/README.md",
  "datePublished": "2026-01-06",
  "dateModified": "2026-01-06"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/leontoeides/indicium" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    indicium
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 80 stars</span>
                <span class="language">Spanish</span>
                <span>by leontoeides</span>
            </div>
        </div>
        
        <div class="content">
            <h1>indicium</h1>
<img src="https://img.shields.io/crates/v/indicium" alt="Versión en Crates.io">
<img src="https://img.shields.io/crates/msrv/indicium" alt="MSRV en Crates.io">
<img src="https://img.shields.io/crates/l/indicium" alt="Licencia en Crates.io">
<img src="https://img.shields.io/crates/d/indicium" alt="Descargas Totales en Crates.io"></p><p>Una búsqueda simple en memoria para colecciones (<code>Vec</code>, <code>HashMap</code>, <code>BTreeMap</code>, etc.)  
y almacenes clave-valor. Incluye autocompletado y coincidencia difusa.</p><p>Existen muchos motores de búsqueda increíbles disponibles para Rust. Muchos parecen  
requerir compilar un binario servidor separado. Quería algo simple y  
ligero: un crate fácil de usar que pudiera buscar cómodamente estructuras y  
colecciones dentro de mi propio binario. Así que creé <code>indicium</code>.</p><p><img src="https://www.arkiteq.io/crates/indicium/banner.jpg" alt="Indicium: Una Búsqueda Simple en Memoria para Rust" width="400"/></p><p>Aunque <code>indicium</code> fue hecho pensando en aplicaciones web, es una búsqueda en memoria y  
no escala indefinidamente ni a tamaño nube (es decir, tamaño Facebook o Google).  
Incluso en un entorno así, seguiría siendo una forma conveniente de buscar  
listas grandes (como monedas, idiomas, países, etc.) También es ideal para  
aplicaciones donde se anticipa un límite de escala (es decir, buscar en una lista de  
activos de una empresa, lista de usuarios en una intranet corporativa, etc.)</p><p>Indicium puede manejar fácilmente millones de registros sin sudar gracias  
a <a href="https://cglab.ca/~abeinges/blah/rust-btree-case/" target="_blank" rel="noopener noreferrer">BTreeMap</a> de Rust. Este  
crate está principalmente limitado por la memoria disponible. Sin embargo, dependiendo  
de la naturaleza de su conjunto de datos y si hay palabras clave que se repiten muchas veces,  
el rendimiento puede comenzar a degradarse en algún punto.</p><h1>Instalación</h1></p><p>Configure las dependencias en el archivo <code>Cargo.toml</code> de su proyecto:</p><pre><code class="language-toml">[dependencies]
indicium = "0.6"</code></pre></p><h1>Notas de la Versión</h1></p><ul><li>Las notas de la versión están disponibles en</li>
  </ul><a href="https://github.com/leontoeides/indicium/releases" target="_blank" rel="noopener noreferrer">GitHub</a>.</p><ul><li>El <a href="https://github.com/leontoeides/indicium/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">registro de cambios</a> completo está</li>
  </ul>disponible en GitHub.</p><h1>Guía de Inicio Rápido</h1></p><p>Para nuestro ejemplo de <strong>Guía de Inicio Rápido</strong>, buscaremos dentro de la
siguiente <code>struct</code>:</p><pre><code class="language-rust">struct MyStruct {
    title: String,
    year: u16,
    body: String,
}</code></pre></p><h2>1. Implementando Indexable</h2></p><p>Para comenzar, debemos hacer que nuestro registro sea indexable. Lo haremos implementando el
rasgo <code>Indexable</code> para nuestra <code>struct</code>. La idea es devolver un <code>String</code> para cada
campo que queramos indexar. Ejemplo:</p><pre><code class="language-rust">use indicium::simple::Indexable;</p><p>impl Indexable for MyStruct {
    fn strings(&self) -> Vec<String> {
        vec![
            self.title.clone(),
            self.year.to_string(),
            self.body.clone(),
        ]
    }
}</code></pre></p><p>No olvides que puedes hacer que los números, identificadores numéricos, enumeraciones y otros
tipos en tu <code>struct</code> (u otros tipos complejos) sean indexables convirtiéndolos a
un <code>String</code> e incluyéndolos en el <code>Vec<String></code> que se devuelve.</p><h2>2. Indexación de una Colección</h2></p><p>Para indexar una colección existente, podemos iterar sobre la colección. Para cada
registro, lo insertaremos en el índice de búsqueda. Esto debería verse algo
como estos dos ejemplos:</p><p>#### Vec</p><pre><code class="language-rust">use indicium::simple::SearchIndex;</p><p>let my_vec: Vec<MyStruct> = Vec::new();</p><p>// In the case of a <code>Vec</code> collection, we use the index as our key. A
// <code>Vec</code> index is a <code>usize</code> type. Therefore we will instantiate
// <code>SearchIndex</code> as <code>SearchIndex<usize></code>.</p><p>let mut search_index: SearchIndex<usize> = SearchIndex::default();</p><p>my_vec
    .iter()
    .enumerate()
    .for_each(|(index, element)|
        search_index.insert(&index, element)
    );</code></pre></p><p>#### HashMap</p><pre><code class="language-rust">use std::collections::HashMap;
use indicium::simple::SearchIndex;</p><p>let my_hash_map: HashMap<String, MyStruct> = HashMap::new();</p><p>// In the case of a <code>HashMap</code> collection, we use the hash map's key as
// the <code>SearchIndex</code> key. In our hypothetical example, we will use
// MyStruct's <code>title</code> as a the key which is a <code>String</code> type. Therefore
// we will instantiate <code>HashMap<K, V></code> as HashMap<String, MyStruct> and
// <code>SearchIndex<K></code> as <code>SearchIndex<String></code>.</p><p>let mut search_index: SearchIndex<String> = SearchIndex::default();</p><p>my_hash_map
    .iter()
    .for_each(|(key, value)|
        search_index.insert(key, value)
    );</code></pre></p><p>Mientras que el rasgo <code>Indexable</code> esté implementado para tu tipo de valor, los ejemplos anteriores
indexarán un <code>Vec</code> o <code>HashMap</code> previamente poblado. Sin embargo, el
método preferido para colecciones grandes es <code>insertar</code> en el <code>SearchIndex</code> conforme
inserta en tu colección (Vec, HashMap, etc.)</p><p>Se recomienda envolver tu colección objetivo (tu <code>Vec</code>, <code>HashMap</code>, etc.)
y este <code>SearchIndex</code> juntos en un nuevo tipo de <code>struct</code>. Luego, implementa los
métodos <code>insert</code>, <code>replace</code>, <code>remove</code>, etc. para este nuevo tipo de <code>struct</code> que
actualizará tanto la colección como el índice de búsqueda. Esto asegurará que tanto tu
colección como el índice estén siempre sincronizados.</p><p>Una vez que el índice ha sido poblado, puedes usar los métodos <code>search</code> y <code>autocomplete</code>.</p><h2>3. Búsqueda</h2></p><p>El método <code>search</code> devolverá claves como resultados de la búsqueda. Cada clave resultante
puede usarse para recuperar el registro completo de su colección.</p><p>Uso básico:</p><pre><code class="language-rust">let mut search_index: SearchIndex<usize> = SearchIndex::default();</p><p>search_index.insert(&0, &"Harold Godwinson");
search_index.insert(&1, &"Edgar Ætheling");
search_index.insert(&2, &"William the Conqueror");
search_index.insert(&3, &"William Rufus");
search_index.insert(&4, &"Henry Beauclerc");</p><p>let resulting_keys: Vec<&usize> = search_index.search("William");</p><p>assert_eq!(resulting_keys, vec![&2, &3]);</p><p>// Demonstrating fuzzy matching:</p><p>let resulting_keys: Vec<&usize> = search_index.search("Harry");</p><p>assert_eq!(resulting_keys, vec![&0]);</code></pre></p><p>La búsqueda solo admite coincidencias exactas de palabras clave. Para búsquedas <code>en vivo</code>, la coincidencia aproximada
solo se aplica a la última palabra clave. Considere proporcionar la función de <code>autocompletar</code>
a sus usuarios para ayudarlos a construir su búsqueda mientras escriben.</p><h2>4. Autocompletado</h2></p><p>El método <code>autocomplete</code> proporcionará varias opciones de autocompletado para la
última palabra clave en la cadena proporcionada.</p><p>Uso básico:</p><pre><code class="language-rust">let mut search_index: SearchIndex<usize> =
    SearchIndexBuilder::default()
        .autocomplete_type(&AutocompleteType::Global)
        .build();</p><p>search_index.insert(&0, &"apple");
search_index.insert(&1, &"ball");
search_index.insert(&3, &"bird");
search_index.insert(&4, &"birthday");
search_index.insert(&5, &"red");</p><p>let autocomplete_options: Vec<String> =
    search_index.autocomplete("a very big bi");</p><p>assert_eq!(
    autocomplete_options,
    vec!["a very big bird", "a very big birthday"]
);</p><p>// Demonstrating fuzzy matching:</p><p>let autocomplete_options: Vec<String> =
    search_index.autocomplete("a very big birf");</p><p>assert_eq!(
    autocomplete_options,
    vec!["a very big bird", "a very big birthday"]
);</code></pre></p><h1>Puntos Extra</h1></p><h2>5. Ordenación Personalizada de Resultados</h2></p><p>Con la excepción de <code>SearchType::Or</code>, que utiliza puntuación de relevancia, los resultados de búsqueda se devuelven en el orden definido por la implementación de <code>Ord</code> de tu tipo de clave.  
Esto significa que puedes controlar el orden de los resultados usando un tipo de clave personalizado en lugar de enteros o cadenas simples.</p><p>Por ejemplo, si quieres que los elementos populares aparezcan primero en los resultados de búsqueda,  
puedes crear una clave que ordene por popularidad:</p><pre><code class="language-rust">use std::cmp::Ordering;
use std::hash::{Hash, Hasher};</p><p>/// A search key that sorts results by popularity (highest first).
#[derive(Debug, Clone)]
pub struct RankedKey {
    pub id: String,
    pub popularity: u32,
}</p><p>impl Ord for RankedKey {
    fn cmp(&self, other: &Self) -> Ordering {
        // Higher popularity comes first
        other.popularity.cmp(&self.popularity)
    }
}</p><p>impl PartialOrd for RankedKey {
    fn partial_cmp(&self, other: &Self) -> Option {
        Some(self.cmp(other))
    }
}</p><p>// For equality and lookups, we only compare the id, not popularity. This lets
// us find records in a HashMap using just the id.</p><p>impl PartialEq for RankedKey {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}</p><p>impl Eq for RankedKey {}</p><p>impl Hash for RankedKey {
    fn hash(&self, state: &mut H) {
        self.id.hash(state);
    }
}</code></pre></p><p>Ahora, cuando buscas, los resultados se devuelven automáticamente ordenados por popularidad. No
se necesita un paso adicional de ordenamiento.</p><p>Este patrón funciona para cualquier señal de clasificación: actualidad, puntuaciones de relevancia, orden
manual, etc. Solo cambia lo que <code>Ord</code> compara.</p><h3>Uso de Claves para Búsquedas</h3></p><p>Después de buscar, normalmente obtendrás el registro completo de tu colección:</p><pre><code class="language-rust">let results = search_index.search("dawn");</p><p>for key in results {
    if let Some(record) = my_records.get(key) {
        println!("{:?}", record);
    }
}</code></pre></p><p>Debido a que los traits <code>Eq</code> y <code>Hash</code> que implementamos en el ejemplo solo consideran
el campo <code>id</code> (no <code>popularity</code>), aún puedes usar las claves de resultados de búsqueda
directamente para búsquedas en <code>HashMap</code>.</p><h1>Estado del Crate</h1></p><p>Este crate se mantiene de forma pasiva. Este crate hace lo que se espera que haga y
lo hace bastante bien, en mi opinión. No se esperan actualizaciones frecuentes.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2026-01-06

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/leontoeides/indicium/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2026-01-06 
    </div>
    
</body>
</html>