<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Thai. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Thai. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Thai, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Thai. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-th.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-09-16",
  "dateModified": "2025-09-16"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Thai</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>ตัวซีเรียไลเซอร์ข้อมูลไบนารีประสิทธิภาพสูงแบบ zero encoding สำหรับ C# และ Unity</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>เปรียบเทียบกับ <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. วัดผลด้วย .NET 7 / Ryzen 9 5950X เครื่อง. ซีเรียไลเซอร์เหล่านี้มีเมธอด <code>IBufferWriter<byte></code>, ซีเรียไลซ์ด้วย <code>ArrayBufferWriter<byte></code> และนำกลับมาใช้ซ้ำเพื่อหลีกเลี่ยงการวัดการคัดลอกบัฟเฟอร์.</blockquote></p><p>สำหรับอ็อบเจ็กต์มาตรฐาน MemoryPack เร็วกว่า x10 และเร็วกว่า binary serializers อื่น ๆ x2 ~ x5 สำหรับ struct array, MemoryPack ทรงพลังยิ่งขึ้น โดยเร็วกว่าซีเรียไลเซอร์อื่นถึง x50 ~ x200</p><p>MemoryPack คือซีเรียไลเซอร์ตัวที่ 4 ที่ผมสร้างมาก่อนหน้านี้ ได้แก่ ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. เหตุผลที่ MemoryPack รวดเร็ว เพราะใช้ฟอร์แมตไบนารีที่ออกแบบมาเฉพาะและปรับแต่งสำหรับ C# อย่างดี และอิมพลีเมนเทชั่นที่ปรับจูนมาจากประสบการณ์เดิม นอกจากนี้ยังเป็นดีไซน์ใหม่หมดที่ใช้ .NET 7 และ C# 11 รวมถึง Incremental Source Generator (รองรับ .NET Standard 2.1 (.NET 5, 6) และ Unity ด้วย)</p><p>ซีเรียไลเซอร์อื่นจะมีขั้นตอน encoding หลายอย่าง เช่น VarInt encoding, tag, string ฯลฯ แต่ MemoryPack ใช้ดีไซน์ zero-encoding ที่คัดลอกหน่วยความจำของ C# ได้มากที่สุดเท่าที่ทำได้ แนวคิด zero-encoding คล้าย FlatBuffers แต่ไม่ต้องใช้ชนิดพิเศษ โดย MemoryPack สามารถซีเรียไลซ์ POCO ได้เลย</p><p>นอกจากประสิทธิภาพแล้ว MemoryPack ยังมีฟีเจอร์เหล่านี้</p><ul><li>รองรับ I/O APIs สมัยใหม่ (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>การสร้างโค้ดโดย Source Generator ที่เป็นมิตรกับ Native AOT, ไม่ใช้ Dynamic CodeGen (IL.Emit)</li>
<li>API ที่ไม่ใช้ Reflection และไม่ต้องใช้เจนเนอริก</li>
<li>Deserialize ลงในอินสแตนซ์ที่มีอยู่แล้ว</li>
<li>ซีเรียไลซ์แบบ Polymorphism (Union)</li>
<li>รองรับ version-tolerant แบบจำกัด (fast/default) และแบบเต็ม</li>
<li>รองรับ Circular reference serialization</li>
<li>รองรับ PipeWriter/Reader สำหรับ serialization แบบสตรีม</li>
<li>การสร้างโค้ด TypeScript และ ASP.NET Core Formatter</li>
<li>รองรับ Unity (2021.3) IL2CPP ผ่าน .NET Source Generator</li></p><p></ul>การติดตั้ง
<hr>
ไลบรารีนี้เผยแพร่ผ่าน NuGet สำหรับประสิทธิภาพสูงสุด แนะนำให้ใช้ <code>.NET 7</code> ข้อกำหนดขั้นต่ำคือ <code>.NET Standard 2.1</code></p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>และตัวแก้ไขโค้ดต้องรองรับ Roslyn 4.3.1 เช่น Visual Studio 2022 เวอร์ชัน 17.3, .NET SDK 6.0.401 รายละเอียดดูที่ <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a></p><p>สำหรับ Unity ข้อกำหนดและขั้นตอนติดตั้งจะแตกต่างกันโดยสิ้นเชิง ดูรายละเอียดในหัวข้อ <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a></p><p>เริ่มต้นใช้งานอย่างรวดเร็ว
<hr>
กำหนด struct หรือ class ที่ต้องการซีเรียไลซ์และใส่ attribute <code>[MemoryPackable]</code> พร้อมกับใช้ keyword <code>partial</code></p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>โค้ดสำหรับ serialization จะถูกสร้างโดยฟีเจอร์ C# source generator ซึ่งจะ implements อินเตอร์เฟซ <code>IMemoryPackable<T></code> ใน Visual Studio สามารถดูโค้ดที่สร้างขึ้นได้โดยใช้คีย์ลัด <code>Ctrl+K, R</code> ที่ชื่อคลาสและเลือก <code>*.MemoryPackFormatter.g.cs</code></p><p>เรียกใช้ <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> เพื่อซีเรียไลซ์/ดีซีเรียไลซ์อินสแตนซ์ของอ็อบเจ็กต์</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>เมธอด <code>Serialize</code> รองรับทั้งการคืนค่าเป็น <code>byte[]</code> รวมถึงสามารถซีเรียไลซ์ไปยัง <code>IBufferWriter<byte></code> หรือ <code>Stream</code> ได้ เมธอด <code>Deserialize</code> รองรับ <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> และ <code>Stream</code> รวมถึงมีเวอร์ชันที่ไม่ใช้เจนเนอริกด้วย</p><p>ประเภทที่รองรับในตัว
<hr>
ประเภทเหล่านี้สามารถซีเรียไลซ์ได้โดยตรง:</p><ul><li>.NET primitives (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code> ฯลฯ)</li>
<li>Unmanaged types (เช่น <code>enum</code> ใดๆ, <code>struct</code> ที่ผู้ใช้กำหนดเองซึ่งไม่มี reference types)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Immutable collections (<code>ImmutableList<></code> ฯลฯ) และ interfaces (<code>IImmutableList<></code> ฯลฯ)</li></p><p></ul>การกำหนด <code>[MemoryPackable]</code> ให้กับ <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> สามารถใช้กับ <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> และ <code>interface</code> ใดๆ หากชนิดเป็น <code>struct</code> หรือ <code>record struct</code> ที่ไม่มี reference types (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>) จะไม่ใช้ annotation อื่นใด (ignore, include, constructor, callbacks) โดยจะซีเรียไลซ์/ดีซีเรียไลซ์ตรงจากเมมโมรี</p><p>ในกรณีอื่น <code>[MemoryPackable]</code> จะซีเรียไลซ์ property หรือ field สาธารณะโดยอัตโนมัติ สามารถใช้ <code>[MemoryPackIgnore]</code> เพื่อลบออกจาก serialization target หรือ <code>[MemoryPackInclude]</code> เพื่อโปรโมตสมาชิก private ให้ซีเรียไลซ์ได้</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // สมาชิกเหล่านี้จะถูกซีเรียไลซ์โดยอัตโนมัติ
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // สมาชิกเหล่านี้จะไม่ถูกซีเรียไลซ์โดยอัตโนมัติ
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // ใช้ [MemoryPackIgnore] เพื่อลบ public member ออกจาก target
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // ใช้ [MemoryPackInclude] เพื่อโปรโมตสมาชิก private ให้ซีเรียไลซ์ได้
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>ตัว generator ของ <code>MemoryPack</code> จะเพิ่มข้อมูลว่าสมาชิกตัวไหนถูกซีเรียไลซ์ลงในส่วน <code><remarks /></code> ซึ่งสามารถดูได้โดยเอาเมาส์ชี้ที่ชนิดนั้นใน Intellisense</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>สมาชิกทั้งหมดต้องสามารถซีเรียไลซ์ด้วย memorypack ได้ หากไม่เป็นไปตามนั้น code generator จะส่ง error</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack มี diagnostic rule ทั้งหมด 35 ข้อ (<code>MEMPACK001</code> ถึง <code>MEMPACK035</code>) เพื่อให้กำหนดได้อย่างมั่นใจ</p><p>หากชนิดเป้าหมายมีการกำหนด MemoryPack serialization ภายนอกและมีการลงทะเบียนแล้ว สามารถใช้ <code>[MemoryPackAllowSerialize]</code> เพื่อปิด diagnostic ได้</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>ลำดับของสมาชิก <strong>สำคัญมาก</strong> MemoryPack จะไม่ซีเรียไลซ์ชื่อสมาชิกหรือข้อมูลอื่น ๆ แต่จะซีเรียไลซ์ฟิลด์ตามลำดับที่ประกาศ ถ้าชนิดมีการสืบทอด จะซีเรียไลซ์ตามลำดับ parent → child ลำดับสมาชิกต้องไม่เปลี่ยนสำหรับการดีซีเรียไลซ์ ในกรณี schema evolution ดูในหัวข้อ <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a></p><p>ลำดับปกติจะเป็นไปตามลำดับประกาศ แต่สามารถเลือก explicit layout ได้ด้วย <code>[MemoryPackable(SerializeLayout.Explicit)]</code> และ <code>[MemoryPackOrder()]</code></p><pre><code class="language-csharp">// ซีเรียไลซ์ Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>การเลือก Constructor</h3></p><p>MemoryPack รองรับทั้ง parameterized และ parameterless constructor กติกาการเลือก constructor มีดังนี้ (ใช้กับทั้ง class และ struct):</p><ul><li>หากมี <code>[MemoryPackConstructor]</code> จะใช้ตัวนั้น</li>
<li>หากไม่มี constructor (รวมถึง private) จะใช้ parameterless</li>
<li>หากมี constructor แบบ parameterless/parameterized เพียงหนึ่งตัว (รวมถึง private) จะใช้ตัวนั้น</li>
<li>หากมี constructor หลายตัว ต้องใส่ attribute <code>[MemoryPackConstructor]</code> ให้กับ constructor ที่ต้องการ (generator จะไม่เลือกให้เอง) มิฉะนั้น generator จะส่ง error</li>
<li>หากใช้ parameterized constructor ชื่อ parameter ทั้งหมดต้องตรงกับชื่อสมาชิก (case-insensitive)</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // สามารถใช้ parameterized constructor ได้ - ชื่อ parameter ต้องตรงกับชื่อสมาชิก (case-insensitive)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// รองรับ record primary constructor ด้วย
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// หากมี constructor หลายตัว จะต้องใช้ [MemoryPackConstructor]
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>การเรียก callback ระหว่างการ serialization</h3></p><p>เมื่อทำการ serialize/deserialize, MemoryPack สามารถเรียกใช้งาน event ก่อน/หลัง ได้โดยใช้ attribute <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> สามารถใส่ annotation ได้ทั้ง method แบบ static และ instance (ไม่ใช่ static) และทั้ง method ที่เป็น public และ private</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // ลำดับการเรียก method คือ static -> instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // รองรับ method แบบ private ด้วย
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // หมายเหตุ: instance method ที่มี MemoryPackOnDeserializing จะไม่ถูกเรียกถ้า instance ไม่ถูกส่งแบบ <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>Callback รองรับ method ที่ไม่มี parameter และแบบ <code>ref reader/writer, ref T value</code> ด้วย ตัวอย่างเช่น callback แบบ ref สามารถเขียน/อ่าน header แบบ custom ก่อนเริ่มกระบวนการ serialization</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, ใช้ where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // เขียน GUID ที่ header
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // อ่าน custom header ก่อน deserialize
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>หากกำหนดค่าให้กับ <code>ref value</code> จะสามารถเปลี่ยนแปลงค่าที่ใช้ในการ serialize/deserialize ได้ เช่น การสร้าง instance จาก ServiceProvider</p><pre><code class="language-csharp">// ก่อนใช้ formatter นี้ ให้ตั้งค่า ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>การกำหนด collection แบบ custom
<hr>
โดยปกติแล้ว type ที่มี annotation <code>[MemoryPackObject]</code> จะพยายาม serialize สมาชิกของตนเอง อย่างไรก็ตาม หาก type นั้นเป็น collection (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>) ให้ใช้ <code>GenerateType.Collection</code> เพื่อให้ serialize ได้อย่างถูกต้อง</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Static constructor
<hr>
คลาส MemoryPackable ไม่สามารถกำหนด static constructor ได้เพราะ partial class ที่ถูก generate จะใช้งานมันอยู่แล้ว ให้กำหนดเป็น <code>static partial void StaticConstructor()</code> แทนเพื่อให้ได้ผลลัพธ์แบบเดียวกัน</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Polymorphism (Union)
<hr>
MemoryPack รองรับการ serialize อ็อบเจ็กต์ที่เป็น interface และ abstract class สำหรับการ serialize แบบ polymorphism โดยใน MemoryPack คุณสมบัตินี้เรียกว่า Union โดยจะอนุญาตให้เฉพาะ interface และ abstract class เท่านั้นที่ใช้ attribute <code>[MemoryPackUnion]</code> ได้ ต้องกำหนด tag ของ union ให้ไม่ซ้ำกัน</p><pre><code class="language-csharp">// ใส่ [MemoryPackable] และ type ที่สืบทอดด้วย [MemoryPackUnion]
// Union รองรับ abstract class ด้วย
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Serialize เป็น type ของ interface
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Deserialize เป็น type ของ interface
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> รองรับค่าตั้งแต่ <code>0</code> ถึง <code>65535</code> และมีประสิทธิภาพสูงเป็นพิเศษสำหรับค่าต่ำกว่า <code>250</code>
หากอินเทอร์เฟซและไทป์ที่สืบทอดอยู่ใน Assembly ที่ต่างกัน คุณสามารถใช้ <code>MemoryPackUnionFormatterAttribute</code> แทนได้ Formatter จะถูกสร้างขึ้นโดยอัตโนมัติและลงทะเบียนผ่าน <code>ModuleInitializer</code> ใน C# 9.0 ขึ้นไป</p><blockquote>หมายเหตุว่า <code>ModuleInitializer</code> ไม่รองรับใน Unity ดังนั้น Formatter จะต้องลงทะเบียนด้วยตนเอง ในการลงทะเบียน union formatter ของคุณ ให้เรียกใช้ <code>{name of your union formatter}Initializer.RegisterFormatter()</code> ด้วยตนเองใน Startup ตัวอย่างเช่น <code>UnionSampleFormatterInitializer.RegisterFormatter()</code></blockquote></p><pre><code class="language-csharp">// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB กำหนด definition นอกเหนือจาก type เป้าหมาย
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}</code></pre></p><p>Union สามารถรวมกันในโค้ดได้ผ่าน <code>DynamicUnionFormatter<T></code></p><pre><code class="language-csharp">// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);</code></pre></p><p>Serialize API
<hr>
<code>Serialize</code> มีทั้งหมดสาม overload</p><pre><code class="language-csharp">// Non generic API ก็มีเช่นกัน เวอร์ชันนี้ argument แรกเป็น Type และ value เป็น object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)</code></pre></p><p>เพื่อประสิทธิภาพที่ดี API ที่แนะนำคือการใช้ <code>BufferWriter</code> ซึ่งจะ serialize ตรงเข้า buffer สามารถใช้กับ <code>PipeWriter</code> จาก <code>System.IO.Pipelines</code>, <code>BodyWriter</code> ใน ASP .NET Core ฯลฯ</p><p>หากต้องการ <code>byte[]</code> (เช่น <code>RedisValue</code> ใน <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>) การคืนค่า API แบบ <code>byte[]</code> ก็ใช้งานง่ายและเร็วเกือบเท่ากัน</p><p>โปรดทราบว่า <code>SerializeAsync</code> สำหรับ <code>Stream</code> จะเป็นแบบ asynchronous เฉพาะตอน Flush; โดยจะ serialize ทั้งหมดลง MemoryPack internal pool buffer แล้วจึงเขียนด้วย <code>WriteAsync</code> ดังนั้น overload แบบ <code>BufferWriter</code> ที่แยกและควบคุม buffer กับ flush ได้จะดีกว่า</p><p>หากคุณต้องการทำ streaming write แบบสมบูรณ์ โปรดดูหัวข้อ <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a></p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> ใช้ตั้งค่าว่าจะ serialize string เป็น UTF16 หรือ UTF8 โดยสามารถตั้งค่าได้โดยส่ง <code>MemoryPackSerializerOptions.Utf8</code> สำหรับ encoding แบบ UTF8, <code>MemoryPackSerializerOptions.Utf16</code> สำหรับ UTF16 หรือ <code>MemoryPackSerializerOptions.Default</code> ซึ่งตั้งค่าเริ่มต้นเป็น UTF8 หากส่ง null หรือใช้ parameter default จะเป็น UTF8</p><p>เนื่องจาก string ใน C# จะเป็น UTF16 อยู่แล้ว การใช้ UTF16 จะเร็วกว่า แต่ขนาด payload จะใหญ่กว่า; ใน UTF8 string ASCII จะใช้ 1 byte, แต่ใน UTF16 จะใช้ 2 byte เนื่องจากความแตกต่างของขนาด payload นี้จึงตั้งค่า default เป็น UTF8</p><p>หากข้อมูลเป็น non-ASCII (เช่น ญี่ปุ่น ที่อาจเกิน 3 byte และ UTF8 ใหญ่กว่า) หรือหากคุณต้องบีบอัดแยกต่างหาก การใช้ UTF16 อาจให้ผลลัพธ์ที่ดีกว่า</p><p>แม้จะเลือก UTF8 หรือ UTF16 ตอน serialize ได้ แต่ขณะ deserialize ไม่จำเป็นต้องระบุ จะตรวจจับและแปลงกลับโดยอัตโนมัติ</p><p>นอกจากนี้คุณยังสามารถ get/set <code>IServiceProvider? ServiceProvider { get; init; }</code> จาก options ได้ด้วย ใช้กับกรณีต้องการ DI object (เช่น <code>ILogger<T></code>) จากกระบวนการ serialization (<code>MemoryPackReader/MemoryPackWriter</code> มี .Options property)</p><p>Deserialize API
<hr>
<code>Deserialize</code> มี overload สำหรับ <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>, <code>Stream</code> และรองรับ <code>ref</code></p><pre><code class="language-csharp">T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)</code></pre></p><p>overload แบบ <code>ref</code> จะ overwrite instance ที่มีอยู่ รายละเอียดดูหัวข้อ <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a></p><p><code>DeserializeAsync(Stream)</code> ไม่ได้เป็นการอ่าน stream แบบ streaming เต็มรูปแบบ โดยจะอ่านเข้า internal pool ของ MemoryPack จนจบ stream แล้วจึง deserialize</p><p>หากคุณต้องการทำ streaming read แบบสมบูรณ์ โปรดดูหัวข้อ <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a></p><p>Overwrite
<hr>
เพื่อช่วยลด allocation, MemoryPack รองรับการ deserialize ทับ instance เดิม โดยใช้ overload <code>Deserialize(ref T? value)</code></p><pre><code class="language-csharp">var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// overwrite ข้อมูลลง instance เดิม
MemoryPackSerializer.Deserialize(bin, ref person);</code></pre></p><p>MemoryPack จะพยายาม overwrite ให้มากที่สุดเท่าที่จะทำได้ แต่หากมีเงื่อนไขดังต่อไปนี้ไม่ตรง จะสร้าง instance ใหม่ (เหมือนการ deserialize ปกติ)</p><ul><li>ref value (รวมสมาชิกใน object graph) เป็น null, จะ set instance ใหม่</li>
<li>อนุญาตเฉพาะ constructor แบบไม่มี parameter ถ้าใช้ parameterized constructor จะสร้าง instance ใหม่</li>
<li>หาก value เป็น <code>T[]</code> จะ reuse เฉพาะกรณี length เท่ากัน, ไม่เช่นนั้นสร้าง instance ใหม่</li>
<li>หาก value เป็น collection ที่มี <code>.Clear()</code> เช่น (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) จะเรียก Clear() และ reuse, ไม่เช่นนั้นสร้าง instance ใหม่</li></p><p></ul>Version tolerant
<hr>
โดยค่าเริ่มต้น (<code>GenerateType.Object</code>), MemoryPack รองรับ schema evolution แบบจำกัด</p><ul><li>struct แบบ unmanaged ไม่สามารถเปลี่ยนแปลงได้อีก</li>
<li>สามารถเพิ่มสมาชิกได้ แต่ลบออกไม่ได้</li>
<li>เปลี่ยนชื่อสมาชิกได้</li>
<li>เปลี่ยนลำดับสมาชิกไม่ได้</li>
<li>เปลี่ยนชนิดสมาชิกไม่ได้</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Add ได้
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Remove ไม่ได้
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// เปลี่ยนลำดับไม่ได้
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}</code></pre></p><p>สำหรับ use-case ที่เก็บข้อมูลเก่า (ไฟล์, redis, ฯลฯ) แล้วอ่านด้วย schema ใหม่ สามารถทำได้เสมอ ในกรณี RPC schema จะมีทั้งฝั่ง client และ server โดย client ต้องอัปเดตให้ใหม่ก่อน server client ที่อัปเดตแล้วจะเชื่อมต่อกับ server เก่าได้ แต่ client เก่าเชื่อมต่อกับ server ใหม่ไม่ได้</p><p>โดยปกติเมื่ออ่านข้อมูลเก่าเข้า schema ใหม่ สมาชิกที่ไม่มีในฝั่งข้อมูลจะถูกกำหนดค่าเป็น <code>default</code> เสมอ
หากต้องการหลีกเลี่ยงและใช้ค่าเริ่มต้นของ field/property สามารถใช้ <code>[SuppressDefaultInitialization]</code></p><pre><code class="language-cs">[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < ถ้าข้อมูลเก่าขาด จะ set เป็น <code>111</code>
    
    public int Prop3 { get; set; } = 222; // < ถ้าข้อมูลเก่าขาด จะ set เป็น <code>default</code>
}</code></pre></p><p> <code>[SuppressDefaultInitialization]</code> มีข้อจำกัดดังนี้:
<ul><li>ใช้กับ readonly, init-only และ required modifier ไม่ได้</li></p><p></ul>หัวข้อถัดไป <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> จะแสดงวิธีเช็ค schema change เช่น โดย CI เพื่อป้องกันข้อผิดพลาด</p><p>เมื่อใช้ <code>GenerateType.VersionTolerant</code> จะรองรับ version-tolerant อย่างสมบูรณ์</p><ul><li>struct แบบ unmanaged ไม่สามารถเปลี่ยนแปลงได้อีก</li>
<li>ต้องเพิ่ม <code>[MemoryPackOrder]</code> ให้ทุกสมาชิก (ยกเว้น annotate <code>SerializeLayout.Sequential</code>)</li>
<li>สามารถเพิ่มหรือลบสมาชิกได้ แต่ห้าม reuse order (ใช้ order ที่ขาดได้)</li>
<li>เปลี่ยนชื่อสมาชิกได้</li>
<li>เปลี่ยนลำดับสมาชิกไม่ได้</li>
<li>เปลี่ยนชนิดสมาชิกไม่ได้</li></p><p></ul><pre><code class="language-csharp">// Ok ทั้ง serialize/deserialize จาก 
// VersionTolerantObject1 -> VersionTolerantObject2 และ 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{</code></pre>csharp
[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// deleted
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// added
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}
<pre><code class="language-"></code></pre>csharp
// ถ้ากำหนด SerializeLayout.Sequential โดยตรง จะสามารถจัดลำดับอัตโนมัติได้
// แต่จะไม่สามารถลบสมาชิกใด ๆ สำหรับการรองรับเวอร์ชันได้
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}
<pre><code class="language-">
<code>GenerateType.VersionTolerant</code> จะช้ากว่า <code>GenerateType.Object</code> ในการซีเรียลไลซ์ และขนาดของ payload จะใหญ่กว่าเล็กน้อย</p><p>ข้อมูลการซีเรียลไลซ์
----
คุณสามารถตรวจสอบ IntelliSense ใน type ว่าสมาชิกใดถูกซีเรียลไลซ์ มีตัวเลือกสำหรับเขียนข้อมูลนี้ลงไฟล์ขณะ compile ตั้งค่า <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> ดังนี้
</code></pre>xml
<!-- ส่งออกข้อมูลการซีเรียลไลซ์ memorypack ไปที่ไดเรกทอรี -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
ข้อมูลต่อไปนี้จะถูกเขียนลงไฟล์</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>ถ้าประเภทเป็น unmanaged จะแสดง <code>unmanaged</code> ก่อนชื่อประเภท
</code></pre>txt
unmanaged FooStruct
<hr>
int x
int y
<pre><code class="language-">
โดยการตรวจสอบความแตกต่างในไฟล์นี้ สามารถป้องกันการเปลี่ยนแปลง schema ที่อันตรายได้ ตัวอย่างเช่น คุณอาจต้องการใช้ CI เพื่อตรวจจับกฎต่อไปนี้</p><ul><li>แก้ไข unmanaged type</li>
<li>การเปลี่ยนลำดับสมาชิก</li>
<li>การลบสมาชิก</li></p><p></ul>Circular Reference
<hr>
MemoryPack รองรับ circular reference ด้วยเช่นกัน สิ่งนี้ทำให้สามารถซีเรียลไลซ์อ็อบเจกต์แบบต้นไม้ได้ตามจริง
</code></pre>csharp
// เพื่อเปิดใช้งาน circular-reference ให้ใช้ GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}
<pre><code class="language-">
ตัวอย่างเช่น <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> โค้ดจะเป็นดังนี้
</code></pre>csharp
// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}
<pre><code class="language-">
<code>GenerateType.CircularReference</code> มีลักษณะเช่นเดียวกับ version-tolerant แต่มีข้อจำกัดเพิ่มเติม คือต้องมีคอนสตรัคเตอร์แบบไม่มีพารามิเตอร์เท่านั้น และจะมีการติดตาม object reference เฉพาะกับอ็อบเจกต์ที่กำกับด้วย <code>GenerateType.CircularReference</code> เท่านั้น หากต้องการติดตามอ็อบเจกต์อื่น ให้ห่อมันไว้</p><p>CustomFormatter
<hr>
หาก implements <code>MemoryPackCustomFormatterAttribute<T></code> หรือ <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (มีประสิทธิภาพมากกว่าแต่ซับซ้อนกว่า) คุณสามารถกำหนด custom formatter ให้กับสมาชิกของ MemoryPackObject ได้
</code></pre>csharp
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}
<pre><code class="language-">
MemoryPack มี attribute สำหรับ formatting ดังต่อไปนี้: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    // ซีเรียลไลซ์สมาชิกนี้เป็น UTF16 String มีประสิทธิภาพมากกว่า UTF8 แต่ใน ASCII ขนาดใหญ่กว่า (แต่ non ASCII บางครั้งเล็กกว่า)
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // ตอน deserialize Dictionary จะถูก initialize ด้วย StringComparer.OrdinalIgnoreCase
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // ตอน deserialize string ทั้งหมดจะถูก interned (ดู: String.Intern) ถ้ามีค่าคล้ายกันซ้ำ ๆ จะช่วยประหยัดหน่วยความจำ
    [InternStringFormatter]
    public string? Flag { get; set; }
}
<pre><code class="language-">
หากต้องการกำหนด equality comparer สำหรับ set/dictionary ฟอร์แมตเตอร์ทั้งหมดที่มีในระบบจะมี constructor overload สำหรับ comparer ให้คุณสามารถสร้าง custom equality-comparer formatter ได้ง่าย
</code></pre>csharp
public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}
<pre><code class="language-">
<code>BitPackFormatter</code> บีบอัดเฉพาะประเภท <code>bool[]</code> เท่านั้น โดยปกติ <code>bool[]</code> จะซีเรียลไลซ์เป็น 1 ไบต์ต่อค่า boolean แต่ <code>BitPackFormatter</code> จะซีเรียลไลซ์ <code>bool[]</code> แบบเดียวกับ <code>BitArray</code> โดยแต่ละค่า bool จะเก็บเป็น 1 บิต การใช้ <code>BitPackFormatter</code> จะทำให้ 8 ค่า bool เก็บใน 1 ไบต์ซึ่งปกติจะเป็น 8 ไบต์ ส่งผลให้ขนาดลดลง 8 เท่า
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}
<pre><code class="language-">
<code>BrotliFormatter</code> ใช้สำหรับ <code>byte[]</code> ตัวอย่างเช่น คุณสามารถบีบอัด payload ขนาดใหญ่ด้วย Brotli
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
<pre><code class="language-">
<code>BrotliStringFormatter</code> สำหรับ <code>string</code> ซีเรียลไลซ์ string ที่ถูกบีบอัด (UTF16) ด้วย Brotli
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}
<pre><code class="language-">``<code>
</code>BrotliFormatter<T><code> เหมาะสำหรับใช้กับทุกชนิดข้อมูล ข้อมูลที่ถูกซีเรียลไลซ์จะถูกบีบอัดด้วย Brotli หากชนิดข้อมูลเป็น </code>byte[]<code> หรือ </code>string<code> ควรใช้ </code>BrotliFormatter<code> หรือ </code>BrotliStringFormatter<code> เพื่อประสิทธิภาพที่ดีกว่า
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}
<pre><code class="language-">
การถอดรหัสแบบ array pooling
<hr>
เพื่อถอดรหัสอาร์เรย์ขนาดใหญ่ (ชนิดใด ๆ </code>T<code>) MemoryPack มีวิธี pooling ที่มีประสิทธิภาพหลายรูปแบบ วิธีที่มีประสิทธิภาพสูงสุดคือการใช้ฟังก์ชัน <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a> โดยเฉพาะ </code>List<T><code> จะถูกนำกลับมาใช้ซ้ำเสมอ
</code></pre>csharp
[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> ถูกนำกลับมาใช้ซ้ำ ไม่มีการจัดสรรหน่วยความจำใหม่ขณะถอดรหัส
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// เพื่อให้ทำงานได้อย่างมีประสิทธิภาพ สามารถแปลงเป็น Span<T> ได้โดยใช้ CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);
<pre><code class="language-">
อีกวิธีที่สะดวกคือถอดรหัสลงใน ArrayPool ระหว่างการถอดรหัส MemoryPack มี </code>MemoryPoolFormatter<T><code> และ </code>ReadOnlyMemoryPoolFormatter<T><code> ให้ใช้งาน
</code></pre>csharp
[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // ต้องเขียนโค้ดสำหรับคืนหน่วยความจำเอง ตัวอย่างโค้ด</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // ทำงานใด ๆ ...
}   // คืนหน่วยความจำให้ ArrayPool
<pre><code class="language-">
ประสิทธิภาพ
<hr>
ดูบทความของผู้เขียน <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>ขนาด Payload และการบีบอัด
<hr>
ขนาด payload จะขึ้นอยู่กับข้อมูลเป้าหมาย; ไม่เหมือน JSON ที่มี key และเป็นฟอร์แมตแบบ text แต่ MemoryPack เป็นไบนารี ดังนั้นขนาด payload มักจะเล็กกว่า JSON</p><p>สำหรับฟอร์แมตที่ใช้ varint encoding เช่น MessagePack และ Protobuf ในกรณีที่ใช้งาน int จำนวนมาก MemoryPack อาจมีขนาดใหญ่กว่า (ใน MemoryPack, int จะถูกเข้ารหัสขนาดคงที่ 4 ไบต์เสมอ ในขณะที่ MessagePack จะใช้ 1~5 ไบต์)</p><p>float และ double ใน MemoryPack จะใช้ 4 ไบต์ และ 8 ไบต์ ตามลำดับ แต่ใน MessagePack จะใช้ 5 ไบต์ และ 9 ไบต์ ดังนั้น MemoryPack จะเล็กกว่า เช่นในอาร์เรย์ Vector3 (float, float, float)</p><p>String จะเป็น UTF8 โดยดีฟอลต์ คล้ายกับ serializer อื่น ๆ แต่ถ้าเลือกตัวเลือก UTF16 จะมีลักษณะแตกต่างกัน</p><p>ในทุกกรณี ถ้าขนาด payload ใหญ่ ควรพิจารณาบีบอัดข้อมูล แนะนำให้ใช้ LZ4, ZStandard และ Brotli</p><h3>การบีบอัด (Compression)</h3></p><p>MemoryPack มี helper ที่มีประสิทธิภาพสำหรับการบีบอัด <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> ผ่าน <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> และ <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a> โดย </code>BrotliCompressor<code> และ </code>BrotliDecompressor<code> ของ MemoryPack ได้รับการปรับแต่งสำหรับการทำงานร่วมกับ MemoryPack โดยเฉพาะ
</code></pre>csharp
using MemoryPack.Compression;</p><p>// การบีบอัด (ต้องใช้ using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// ได้ byte[] ที่ถูกบีบอัด
var compressedBytes = compressor.ToArray();</p><p>// หรือเขียนไปยัง IBufferWriter<byte> อื่น ๆ (เช่น PipeWriter)
compressor.CopyTo(response.BodyWriter);
<pre><code class="language-"></code></pre>csharp
using MemoryPack.Compression;</p><p>// การคลายบีบอัด (ต้องใช้ using)
using var decompressor = new BrotliDecompressor();</p><p>// ได้ ReadOnlySequence<byte> ที่คลายบีบอัดแล้ว จาก ReadOnlySpan<byte> หรือ ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);
<pre><code class="language-">
ทั้ง </code>BrotliCompressor<code> และ </code>BrotliDecompressor<code> เป็น struct ไม่มีการจัดสรรหน่วยความจำบน heap ข้อมูลที่ถูกบีบอัด/คลายบีบอัดจะถูกเก็บใน memory pool ภายในระหว่าง Serialize/Deserialize ดังนั้นจำเป็นต้องคืนหน่วยความจำ อย่าลืมใช้ </code>using<code></p><p>ระดับการบีบอัด (Compression level) มีความสำคัญมาก โดยดีฟอลต์จะตั้งไว้ที่ quality-1 (CompressionLevel.Fastest) ซึ่งแตกต่างจากดีฟอลต์ของ .NET (CompressionLevel.Optimal, quality-4)</p><p>Fastest (quality-1) จะมีความเร็วใกล้เคียงกับ <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a> แต่ quality-4 จะช้ากว่ามาก การเลือกนี้สำคัญมากสำหรับการใช้งาน serializer โปรดระวังเมื่อใช้ </code>BrotliStream<code> มาตรฐาน (quality-4 เป็นดีฟอลต์) ทั้งนี้ ความเร็วและขนาดของการบีบอัด/คลายบีบอัดจะต่างกันมากตามข้อมูลที่ใช้ ควรเตรียมข้อมูลให้เหมาะสมกับแอปพลิเคชันของคุณและทดสอบเอง</p><p>โปรดทราบว่ามีค่าเสียเวลาแบบหลายเท่าระหว่างการซีเรียลไลซ์แบบไม่บีบอัดของ MemoryPack กับการเพิ่มการบีบอัดของ Brotli</p><p>Brotli ยังรองรับใน custom formatter ด้วย </code>BrotliFormatter<code> สามารถบีบอัดเฉพาะสมาชิกที่ต้องการได้
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
<pre><code class="language-">
ซีเรียลไลซ์ชนิดข้อมูลภายนอก
<hr>
หากต้องการซีเรียลไลซ์ชนิดข้อมูลภายนอก สามารถสร้าง custom formatter และลงทะเบียนกับ provider ดูรายละเอียดที่ <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> อย่างไรก็ตาม การสร้าง custom formatter ทำได้ยาก จึงแนะนำให้สร้าง type wrapper ตัวอย่างเช่น หากต้องการซีเรียลไลซ์ชนิดข้อมูลภายนอกชื่อว่า </code>AnimationCurve<code>
</code></pre>csharp
// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}
<pre><code class="language-">
ชนิดข้อมูลที่ต้องการ wrap ต้องเป็น public แต่ไม่ถูกซีเรียลไลซ์ (</code>MemoryPackIgnore<code>) ส่วน property ที่ต้องการซีเรียลไลซ์แม้เป็น private สามารถใช้ (</code>MemoryPackInclude<code>) ได้ ควรเตรียม constructor สองแบบ โดย constructor ที่ serializer ใช้งานควรเป็นแบบ private</p><p>แต่การ wrap ทุกครั้งอาจไม่สะดวก และ struct wrapper ไม่สามารถแทนค่า null ได้ ดังนั้นควรสร้าง custom formatter
</code></pre>csharp
public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity ไม่รองรับ scoped และ TBufferWriter จึงเปลี่ยน signature เป็น </code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)<code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)
<pre><code class="language-csharp">{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
}</code></pre></p><p>สุดท้าย ให้ทำการลงทะเบียน formatter ในขั้นตอนเริ่มต้นของโปรแกรม</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());</code></pre>
<blockquote>หมายเหตุ: AnimationCurve ของ Unity สามารถซีเรียลไลซ์ได้โดยค่าเริ่มต้น ดังนั้นจึงไม่จำเป็นต้องใช้ custom formatter สำหรับ AnimationCurve</blockquote></p><p>Packages
<hr>
MemoryPack มีแพ็กเกจดังต่อไปนี้</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul></code>MemoryPack<code> คือไลบรารีหลัก ซึ่งให้การสนับสนุนเต็มรูปแบบสำหรับการซีเรียลไลซ์และดีซีเรียลไลซ์วัตถุแบบไบนารีที่มีประสิทธิภาพสูง โดยขึ้นกับ </code>MemoryPack.Core<code> สำหรับไลบรารีพื้นฐานหลัก และ </code>MemoryPack.Generator<code> สำหรับการสร้างโค้ด </code>MemoryPack.Streaming<code> เพิ่มส่วนขยายสำหรับ <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>  </code>MemoryPack.AspNetCoreMvcFormatter<code> เพิ่ม input/output formatter สำหรับ ASP.NET Core </code>MemoryPack.UnityShims<code> เพิ่ม Unity shim types และ formatter สำหรับแชร์ type ระหว่าง .NET และ Unity</p><p>TypeScript และ ASP.NET Core Formatter
<hr>
MemoryPack รองรับการสร้างโค้ด TypeScript โดยจะสร้าง class และโค้ดซีเรียลไลซ์จาก C# กล่าวอีกนัยหนึ่ง คุณสามารถแชร์ type กับฝั่ง Browser ได้โดยไม่ต้องใช้ OpenAPI, proto ฯลฯ</p><p>การสร้างโค้ดจะถูกรวมอยู่กับ Source Generator โดยตัวเลือกต่อไปนี้ (</code>MemoryPackGenerator_TypeScriptOutputDirectory<code>) เป็นการกำหนดไดเรกทอรีเอาต์พุตสำหรับโค้ด TypeScript โค้ด runtime จะถูกสร้างพร้อมกัน ดังนั้นไม่ต้องการ dependency เพิ่มเติม</p><pre><code class="language-xml"><!-- output memorypack TypeScript code ไปยังไดเรกทอรี -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup></code></pre></p><p>Type ที่เป็น MemoryPackable ของ C# ต้องประกาศ annotation ด้วย </code>[GenerateTypeScript]<code></p><pre><code class="language-csharp">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}</code></pre></p><p>โค้ด runtime และ type ของ TypeScript จะถูกสร้างไว้ในไดเรกทอรีเป้าหมาย</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>โค้ดที่ถูกสร้างจะเป็นดังนี้ โดยมีฟิลด์แบบง่ายและเมธอดแบบ static สำหรับ serialize/serializeArray และ deserialize/deserializeArray</p><pre><code class="language-typescript">import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}</code></pre></p><p>คุณสามารถใช้งาน type นี้ได้ตามตัวอย่างต่อไปนี้</p><pre><code class="language-typescript">let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// serialize เป็น Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// deserialize จาก ArrayBuffer 
let person2 = Person.deserialize(buffer);</code></pre></p><p>แพ็กเกจ </code>MemoryPack.AspNetCoreMvcFormatter<code> จะเพิ่ม input และ output formatter ของ </code>MemoryPack<code> สำหรับ ASP.NET Core MVC คุณสามารถเพิ่ม </code>MemoryPackInputFormatter<code>, </code>MemoryPackOutputFormatter<code> ให้กับ ASP.NET Core MVC ด้วยโค้ดต่อไปนี้</p><pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // หาก checkContentType: true จะสามารถ output ได้หลาย format (JSON/MemoryPack ฯลฯ) ค่าเริ่มต้นคือ false
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});</code></pre></p><p>ถ้าคุณเรียกใช้งานจาก HttpClient สามารถตั้งค่า </code>application/x-memorypack<code> ไปที่ content-header ได้</p><pre><code class="language-csharp">var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");</code></pre></p><h3>การแมป Type ของ TypeScript</h3></p><p>มีข้อจำกัดบางประการเกี่ยวกับ type ที่สามารถสร้างได้ ในหมู่ primitive นั้น </code>char<code> และ </code>decimal<code> ไม่รองรับ และ OpenGenerics type ไม่สามารถใช้งานได้</p><p>|  C#  |  TypeScript  | คำอธิบาย |
| ---- | ---- | ---- |
| </code>bool<code> |  </code>boolean<code>  |
| </code>byte<code> |  </code>number<code>  |
| </code>sbyte<code> |  </code>number<code>  |
| </code>int<code> |  </code>number<code> |
| </code>uint<code> |  </code>number<code> |
| </code>short<code> |  </code>number<code> |
| </code>ushort<code> |  </code>number<code> |
| </code>long<code> |  </code>bigint<code> |
| </code>ulong<code> |  </code>bigint<code> |
| </code>float<code> |  </code>number<code> |
| </code>double<code> |  </code>number<code> |
| </code>string<code> |  </code>string \| null<code>  | 
| </code>Guid<code> |  </code>string<code>  | ใน TypeScript จะแทนเป็น string แต่ serialize/deserialize เป็นไบนารี 16 ไบต์
| </code>DateTime<code> | </code>Date<code> | DateTimeKind จะถูกละเว้น
| </code>enum<code> | </code>const enum<code> | </code>long<code> และ </code>ulong<code> เป็น underlying type ไม่รองรับ
| </code>T?<code> | </code>T \| null<code> |
| </code>T[]<code> | </code>T[] \| null<code> |
| </code>byte[]<code> | </code>Uint8Array \| null<code> |
| </code>: ICollection<T><code> | </code>T[] \| null<code> | รองรับทุก type ที่ implement </code>ICollection<T><code> เช่น </code>List<T><code>
| </code>: ISet<T><code> | </code>Set<T> \| null<code> | รองรับทุก type ที่ implement </code>ISet<T><code> เช่น </code>HashSet<T><code>
| </code>: IDictionary<K,V><code> | </code>Map<K, V> \| null<code> | รองรับทุก type ที่ implement </code>IDictionary<K,V><code> เช่น </code>Dictionary<K,V><code>.
| </code>[MemoryPackable]<code> | </code>class<code> | รองรับเฉพาะ class เท่านั้น
| </code>[MemoryPackUnion]<code> | </code>abstract class<code> |</p><p></code>[GenerateTypeScript]<code> สามารถใช้ได้เฉพาะกับ class และปัจจุบันยังไม่รองรับ struct</p><h3>กำหนดนามสกุลไฟล์ import และรูปแบบชื่อสมาชิก</h3></p><p>โดยค่าเริ่มต้น MemoryPack จะสร้างนามสกุลไฟล์เป็น </code>.js<code> เช่น </code>import { MemoryPackWriter } from "./MemoryPackWriter.js";<code> หากคุณต้องการเปลี่ยนนามสกุลอื่นหรือเว้นว่างไว้ ให้ใช้ </code>MemoryPackGenerator_TypeScriptImportExtension<code> เพื่อกำหนดค่า
นอกจากนี้ ชื่อสมาชิกจะถูกแปลงเป็น camelCase โดยอัตโนมัติ หากคุณต้องการใช้ชื่อเดิม ให้ตั้งค่า </code>MemoryPackGenerator_TypeScriptConvertPropertyName<code> เป็น </code>false<code></p><pre><code class="language-xml"><ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- allows empty -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- default is true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- default is false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup></code></pre></p><p></code>MemoryPackGenerator_TypeScriptEnableNullableTypes<code> ช่วยให้ annotation nullable ของ C# สะท้อนในโค้ด TypeScript ได้ ค่าเริ่มต้นคือ false ซึ่งจะทำให้ทุกอย่าง nullable</p><p>การทำ Streaming Serialization
<hr>
</code>MemoryPack.Streaming<code> มี </code>MemoryPackStreamingSerializer<code> ซึ่งเพิ่มการรองรับเพิ่มเติมสำหรับการ serialize และ deserialize คอลเลกชันด้วย stream</p><pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}</code></pre></p><p>Formatter/Provider API
<hr>
หากคุณต้องการ implement formatter ด้วยตนเอง ให้สืบทอด </code>MemoryPackFormatter<T><code> และ override เมธอด </code>Serialize<code> และ </code>Deserialize<code></p><pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // ใช้เมธอด writer
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // ใช้เมธอด reader
    }
}</code></pre>
Formatter ที่สร้างขึ้นจะต้องลงทะเบียนกับ </code>MemoryPackFormatterProvider<code></p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());</code></pre></p><p>หมายเหตุ: </code>unmanaged struct<code> (คือ struct ที่ไม่มี reference type ภายใน) ไม่สามารถใช้ custom formatter ได้ จะ serialize memory layout ตาม native เสมอ</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
การสร้าง </code>MemoryPackWriter<code>/</code>MemoryPackReader<code> ต้องใช้ OptionalState ซึ่งเป็น wrapper ของ </code>MemoryPackSerializerOptions<code> สามารถสร้างได้จาก </code>MemoryPackWriterOptionalStatePool<code></p><pre><code class="language-csharp">// เมื่อ dispose แล้ว OptionalState จะคืนกลับไปยัง pool
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// สำหรับ Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}</code></pre></p><p>การขึ้นกับ target framework
<hr>
MemoryPack มีทั้ง </code>netstandard2.1<code> และ </code>net7.0<code> แต่ทั้งสองไม่สามารถใช้แทนกันได้ ตัวอย่างเช่น หากใช้ MemoryPackable types ในโปรเจกต์ </code>netstandard2.1<code> และนำไปใช้กับโปรเจกต์ </code>net7.0<code> จะเกิด runtime exception เช่นนี้</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>เนื่องจาก net7.0 ใช้ static abstract member (</code>Virtual static method<code>) ซึ่งไม่รองรับใน netstandard2.1 ดังนั้นพฤติกรรมนี้เป็นไปตามสเปค</p><p>โปรเจกต์ .NET 7 ไม่ควรใช้ dll ของ netstandard 2.1 กล่าวอีกนัยหนึ่ง หาก Application เป็น .NET 7 โปรเจกต์ ทุก dependency ที่ใช้ MemoryPack จะต้องรองรับ .NET 7 ด้วย ดังนั้นหากนักพัฒนาไลบรารีมี dependency กับ MemoryPack คุณต้องตั้งค่า dual target framework</p><pre><code class="language-xml"><TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks></code></pre></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> คือ grpc-dotnet แบบ code-first ที่ใช้ MessagePack แทน protobuf ตอนนี้ MagicOnion รองรับ MemoryPack เป็น serialization layer ผ่านแพ็กเกจ </code>MagicOnion.Serialization.MemoryPack<code> (preview) ดูรายละเอียด: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>Unity เวอร์ชันต่ำสุดที่รองรับคือ </code>2022.3.12f1<code></p><p>แพ็กเกจหลัก </code>MemoryPack<code> มีให้ใน NuGet และสามารถใช้กับ Unity ได้ หากต้องการรองรับ type เฉพาะของ Unity ให้ใช้ MemoryPack.Unity extension เพิ่มเติม</p><ul><li>ติดตั้ง </code>MemoryPack<code> จาก NuGet โดยใช้ <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>เปิดเมนู Window -> Manage NuGet Packages, ค้นหา "MemoryPack" แล้วกด Install</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>หากพบข้อผิดพลาด version conflicts ให้ปิดการตรวจสอบ version validation ที่ Player Settings (Edit -> Project Settings -> Player -> เลื่อนลงแล้วขยาย "Other Settings" จากนั้นยกเลิกเลือก "Assembly Version Validation" ในส่วน "Configuration")</li></p><p><li>ติดตั้งแพ็กเกจ </code>MemoryPack.Unity<code> โดยอ้างอิง git URL</li></p><p><li></code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity<code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack ใช้ tag เวอร์ชันรูปแบบ <em>.</em>.* คุณสามารถระบุเวอร์ชันได้ เช่น #1.0.0 ตัวอย่าง: </code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0<code></p><p>
เหมือนเวอร์ชัน .NET โค้ดจะถูกสร้างโดย code generator (</code>MemoryPack.Generator.dll<code>) การ implement แบบไม่ใช้ Reflection ก็ช่วยให้ performance ดีที่สุดใน IL2CPP</p><p>ดูข้อมูลเพิ่มเติมเกี่ยวกับ Unity และ Source Generator ได้ที่ <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">เอกสาร Unity</a></p><p>Source Generator ได้ถูกใช้โดย Unity อย่างเป็นทางการใน <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> และ <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a> กล่าวคือ มาตรฐานการสร้างโค้ดใน Unity ยุคใหม่</p><p>คุณสามารถ serialize ทุก unmanaged type ได้ (เช่น </code>Vector3<code>, </code>Rect<code>, ฯลฯ) และ class บางตัว (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>) หากต้องการ serialize type เฉพาะของ Unity อื่นๆ ดูที่หัวข้อ <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a></p><p>ด้าน performance ใน Unity, MemoryPack เร็วกว่า JsonUtility ประมาณ x3~x10 เท่า</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>หากโค้ดที่แชร์มี type ของ Unity (</code>Vector2<code> ฯลฯ) MemoryPack มีแพ็กเกจ </code>MemoryPack.UnityShims<code> ให้ใน NuGet</p><p>แพ็กเกจ </code>MemoryPack.UnityShims<code> ให้ shims สำหรับ struct มาตรฐานของ Unity (</code>Vector2<code>, </code>Vector3<code>, </code>Vector4<code>, </code>Quaternion<code>, </code>Color<code>, </code>Bounds<code>, </code>Rect<code>, </code>Keyframe<code>, </code>WrapMode<code>, </code>Matrix4x4<code>, </code>GradientColorKey<code>, </code>GradientAlphaKey<code>, </code>GradientMode<code>, </code>Color32<code>, </code>LayerMask<code>, </code>Vector2Int<code>, </code>Vector3Int<code>, </code>RangeInt<code>, </code>RectInt<code>, </code>BoundsInt<code>) และ class บางตัว (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>)</p><blockquote>[!WARNING]</blockquote>
<blockquote>ขณะนี้ยังมีข้อจำกัดต่อไปนี้สำหรับการใช้งานใน Unity</blockquote></p><ul><li>เวอร์ชัน Unity ยังไม่รองรับ CustomFormatter</li>
<li>หากใช้ .NET7 ขึ้นไป รูปแบบ binary ของ MemoryPack อาจไม่เข้ากันกับ Unity อย่างสมบูรณ์</li>
    <li>ปัญหานี้จะเกิดกับ value type ที่ระบุ </code>[StructLayout(LayoutKind.Auto)]<code> ไว้ชัดเจน (default ของ struct คือ </code>LayoutKind.Sequential<code>) สำหรับ type เหล่านี้ binary ที่ serialize ใน .NET จะไม่สามารถ deserialize ได้ใน Unity และในทางกลับกัน</li>
    <li>ประเภทที่ได้รับผลกระทบมักจะเป็น</li>
        <li></code>DateTimeOffset<code></li>
        <li></code>ValueTuple<code></li>
    <li>ปัจจุบันวิธีแก้ไขง่ายที่สุดคือไม่ใช้ type เหล่านี้</li></p><p></ul>Native AOT
<hr>
น่าเสียดายที่ .NET 7 Native AOT จะ crash (</code>Generic virtual method pointer lookup failure<code>) เมื่อใช้ MemoryPack เนื่องจากบั๊กใน runtime ซึ่งจะถูกแก้ไขใน .NET 8 หากใช้ </code><code>Microsoft.DotNet.ILCompiler</code><code> เวอร์ชัน preview จะสามารถแก้ไขใน .NET 7 ได้ โปรดดู <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">คอมเมนต์ใน issue</a> สำหรับวิธีการตั้งค่า</p><p>สเปค Binary wire format
<hr>
ชนิดของ </code>T<code> ที่กำหนดใน </code>Serialize<T><code> และ </code>Deserialize<T><code> เรียกว่า C# schema ฟอร์แมต MemoryPack ไม่ใช่ฟอร์แมตแบบ self-described ดังนั้น deserialize จะต้องใช้ C# schema ที่ตรงกัน ชนิดเหล่านี้จะอยู่ใน binary เป็น internal representation แต่ไม่สามารถระบุชนิดได้หากไม่มี C# schema</p><p>Endian ต้องเป็น </code>Little Endian<code> อย่างไรก็ตาม implementation ของ C# ที่ใช้เป็น reference ไม่สน endianness ดังนั้นจึงไม่สามารถใช้กับเครื่อง big-endian ได้ แต่คอมพิวเตอร์ยุคใหม่โดยปกติจะเป็น little-endian</p><p>มีฟอร์แมตอยู่ 8 ประเภท</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>วัตถุอ้างอิงแบบวนรอบ (Circular Reference Object)</li>
<li>ทูเพิล (Tuple)</li>
<li>คอลเลกชัน (Collection)</li>
<li>สตริง (String)</li>
<li>ยูเนียน (Union)</li></p><p></ul><h3>โครงสร้างที่ไม่จัดการ (Unmanaged struct)</h3></p><p>โครงสร้างที่ไม่จัดการ คือ struct ของ C# ที่ไม่มีชนิดอ้างอิง (reference types) ภายใน มีข้อจำกัดคล้ายกับ <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a> การซีเรียลไลซ์จะเก็บข้อมูลตาม layout ของ struct รวมถึงช่องว่าง (padding)</p><h3>วัตถุ (Object)</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Object มี header เป็น unsigned byte ขนาด 1 ไบต์ แทนจำนวนสมาชิก (</code>memberCount<code>) ซึ่งสามารถมีค่าได้ตั้งแต่ </code>0<code> ถึง </code>249<code> โดย </code>255<code> หมายถึง object นี้เป็น </code>null<code> ค่า values จะเก็บข้อมูล memorypack ตามจำนวนสมาชิก</p><h3>วัตถุที่ทนต่อเวอร์ชัน (Version Tolerant Object)</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Version Tolerant Object จะคล้ายกับ Object แต่มีการเก็บความยาวของ value แต่ละตัวใน header โดยใช้ varint ตามสเปคนี้ ไบต์แรกเป็น sbyte คือ value หรือ typeCode และไบต์ต่อไปคือ value 0 ถึง 127 = unsigned byte value, -1 ถึง -120 = signed byte value, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long</p><h3>วัตถุอ้างอิงแบบวนรอบ (Circular Reference Object)</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Circular Reference Object จะคล้ายกับ Version Tolerant Object แต่ถ้า memberCount เป็น 250 ค่า varint (unsigned-int32) ถัดไปจะเป็น referenceId หากไม่ใช่ หลัง byte-length-of-values จะเขียน varint referenceId ต่อ</p><h3>ทูเพิล (Tuple)</h3></p><p></code>(values...)<code></p><p>Tuple คือคอลเลกชันค่าขนาดคงที่ (fixed-size) ที่ไม่อนุญาต null ใน .NET </code>KeyValuePair<TKey, TValue><code> และ </code>ValueTuple<T,...><code> จะถูกซีเรียลไลซ์แบบ Tuple</p><h3>คอลเลกชัน (Collection)</h3></p><p></code>(int length, [values...])<code></p><p>Collection มี header เป็น integer 4 ไบต์แบบ signed สำหรับบอกจำนวนข้อมูล </code>-1<code> หมายถึง </code>null<code> values จะเก็บข้อมูล memorypack ตามจำนวน length</p><h3>สตริง (String)</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>String มีสองรูปแบบ คือ UTF16 และ UTF8 ถ้า integer 4 ไบต์แรกเป็น </code>-1<code> หมายถึง null, </code>0<code> หมายถึงว่าง (empty) UTF16 จะเหมือนกับ collection (ซีเรียลไลซ์เป็น </code>ReadOnlySpan<char><code>, ขนาดไบต์ของ utf16-value คือ utf16-length * 2) ถ้า integer แรก <= </code>-2<code> ค่า string จะถูกเข้ารหัสแบบ UTF8 โดย utf8-byte-count จะถูกเข้ารหัสในรูปแบบ complement, ใช้ </code>~utf8-byte-count<code> เพื่อหาจำนวนไบต์ ถัดไปเป็น utf16-length ซึ่งอาจเป็น </code>-1<code> เพื่อแสดงว่าความยาวไม่ทราบแน่ชัด utf8-bytes จะเก็บไบต์ตามจำนวน utf8-byte-count</p><h3>ยูเนียน (Union)</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>ไบต์แรกเป็น unsigned byte ใช้เป็น tag สำหรับแยก discriminated value type หรือ flag ค่า </code>0<code> ถึง </code>249<code> คือ tag, </code>250<code> หมายถึง unsigned short ถัดไปคือ tag, </code>255<code> หมายถึง union เป็น </code>null`</p><p>License
<hr>
ไลบรารีนี้ได้รับอนุญาตภายใต้ MIT License.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-09-16 
    </div>
    
</body>
</html>