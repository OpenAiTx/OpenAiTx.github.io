<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Russian. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Russian. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Russian, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Russian. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-ru.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Russian</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Экстремально производительный бинарный сериализатор без кодирования для C# и Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>Сравнение с <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Замеры производились на машине .NET 7 / Ryzen 9 5950X. Все эти сериализаторы используют метод <code>IBufferWriter<byte></code>, сериализация производилась с помощью <code>ArrayBufferWriter<byte></code> с повторным использованием для исключения измерения копирования буфера.</blockquote></p><p>Для стандартных объектов MemoryPack работает в 10 раз быстрее, а также в 2–5 раз быстрее других бинарных сериализаторов. Для массивов структур MemoryPack еще мощнее — скорость выше в 50–200 раз по сравнению с другими сериализаторами.</p><p>MemoryPack — мой четвертый сериализатор. Ранее я создал известные сериализаторы: ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. Причина высокой скорости MemoryPack — это специфичный для C#, оптимизированный бинарный формат и хорошо настроенная реализация, основанная на моем предыдущем опыте. Это совершенно новый дизайн с использованием .NET 7, C# 11 и Incremental Source Generator (также поддерживается .NET Standard 2.1 (.NET 5, 6) и Unity).</p><p>Другие сериализаторы выполняют множество операций кодирования, таких как VarInt кодирование, теги, строки и т.д. Формат MemoryPack использует схему нулевого кодирования, при которой копируется как можно больше памяти C#. Zero-encoding похож на FlatBuffers, но не требует специальных типов — целью сериализации MemoryPack является POCO.</p><p>Помимо производительности, MemoryPack обладает следующими возможностями.</p><ul><li>Поддержка современных I/O API (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Генерация кода на основе Source Generator, дружественная к Native AOT, без Dynamic CodeGen (IL.Emit)</li>
<li>API без рефлексии и без generic-параметров</li>
<li>Десериализация в существующий экземпляр</li>
<li>Сериализация полиморфизма (Union)</li>
<li>Ограниченная (быстрая/по умолчанию) и полная поддержка tolerant-сериализации по версиям</li>
<li>Сериализация циклических ссылок</li>
<li>Потоковая сериализация на основе PipeWriter/Reader</li>
<li>Генерация TypeScript-кода и ASP.NET Core Formatter</li>
<li>Поддержка Unity (2021.3) IL2CPP через .NET Source Generator</li></p><p></ul>Установка
<hr>
Эта библиотека распространяется через NuGet. Для наилучшей производительности рекомендуется использовать <code>.NET 7</code>. Минимальное требование — <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>Также редактор кода должен поддерживать Roslyn 4.3.1, например Visual Studio 2022 версии 17.3, .NET SDK 6.0.401. Подробнее см. в документе <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a>.</p><p>Для Unity требования и процесс установки полностью отличаются. Подробнее см. раздел <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a>.</p><p>Quick Start
<hr>
Определите структуру или класс для сериализации и пометьте его атрибутом <code>[MemoryPackable]</code> и ключевым словом <code>partial</code>.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>Код для сериализации генерируется функцией C# Source Generator, реализующей интерфейс <code>IMemoryPackable<T></code>. В Visual Studio сгенерированный код можно посмотреть по сочетанию клавиш <code>Ctrl+K, R</code> на имени класса, выбрав <code>*.MemoryPackFormatter.g.cs</code>.</p><p>Для сериализации/десериализации экземпляра объекта вызовите <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code>.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>Метод <code>Serialize</code> поддерживает возврат типа <code>byte[]</code>, а также может сериализовать в <code>IBufferWriter<byte></code> или <code>Stream</code>. Метод <code>Deserialize</code> поддерживает <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> и <code>Stream</code>. Также есть версии без generic-параметров.</p><p>Поддерживаемые типы из коробки
<hr>
Эти типы могут сериализоваться по умолчанию:</p><ul><li>Примитивы .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code> и т.д.)</li>
<li>Неуправляемые типы (любой <code>enum</code>, любой пользовательский <code>struct</code>, не содержащий ссылочных типов)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Неизменяемые коллекции (<code>ImmutableList<></code> и др.) и интерфейсы (<code>IImmutableList<></code> и др.)</li></p><p></ul>Объявление <code>[MemoryPackable]</code> для <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> может быть применён к любому <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> и <code>interface</code>. Если тип — это <code>struct</code> или <code>record struct</code>, не содержащий ссылочных типов (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">неуправляемые типы C#</a>), любые дополнительные атрибуты (ignore, include, constructor, callbacks) не используются, сериализация/десериализация происходит напрямую из памяти.</p><p>В остальных случаях по умолчанию <code>[MemoryPackable]</code> сериализует публичные экземплярные свойства или поля. Можно использовать <code>[MemoryPackIgnore]</code> для исключения члена из сериализации, <code>[MemoryPackInclude]</code> — чтобы добавить приватный член в сериализацию.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // эти члены сериализуются по умолчанию
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // эти члены по умолчанию не сериализуются
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // используйте [MemoryPackIgnore] для исключения публичного члена из сериализации
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // используйте [MemoryPackInclude], чтобы добавить приватный член в сериализацию
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>Генератор кода MemoryPack добавляет информацию о сериализуемых членах в раздел <code><remarks /></code>. Это можно посмотреть, наведя курсор на тип в Intellisense.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>Все члены должны быть сериализуемыми средствами MemoryPack, иначе генератор кода выдаст ошибку.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>В MemoryPack определено 35 диагностических правил (<code>MEMPACK001</code> — <code>MEMPACK035</code>) для комфортного использования.</p><p>Если сериализация типа реализована внешне и зарегистрирована, используйте <code>[MemoryPackAllowSerialize]</code> для подавления диагностики.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>Порядок членов <strong>важен</strong>, MemoryPack не сериализует имя члена или другую информацию, вместо этого сериализуя члены в порядке их объявления. Если тип наследуется, сериализация происходит в порядке родитель → потомок. Порядок членов нельзя менять при десериализации. Для эволюции схемы см. раздел <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a>.</p><p>По умолчанию порядок последовательный, но можно выбрать явное размещение с помощью <code>[MemoryPackable(SerializeLayout.Explicit)]</code> и <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// сериализует Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Выбор конструктора</h3></p><p>MemoryPack поддерживает как конструкторы с параметрами, так и без них. Выбор конструктора происходит по следующим правилам (применяется к классам и структурам):</p><ul><li>Если присутствует <code>[MemoryPackConstructor]</code>, он используется.</li>
<li>Если нет явного конструктора (включая приватный), используется конструктор без параметров.</li>
<li>Если есть только один конструктор без параметров или с параметрами (включая приватный), он используется.</li>
<li>Если есть несколько конструкторов, атрибут <code>[MemoryPackConstructor]</code> должен быть применён к нужному (генератор не выберет автоматически), иначе будет ошибка.</li>
<li>При использовании конструктора с параметрами, все имена параметров должны совпадать с именами членов (без учета регистра).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // Можно использовать конструктор с параметрами — имена параметров должны совпадать с именами членов (без учета регистра)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// также поддерживается record с primary-конструктором
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// Если существует несколько конструкторов, то следует использовать [MemoryPackConstructor]
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>Колбэки сериализации</h3></p><p>При сериализации/десериализации MemoryPack может вызывать события до/после процесса с помощью атрибутов <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Эти атрибуты можно применять как к статическим, так и к экземплярным (нестатическим) методам, а также к публичным и приватным методам.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // порядок вызова методов: static -> instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // также допускается приватный метод
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Примечание: экземплярный метод с MemoryPackOnDeserializing не вызывается, если экземпляр не передан через <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>Колбэки поддерживают методы без параметров и методы с параметрами <code>ref reader/writer, ref T value</code>. Например, колбэки с ref могут записывать/читать пользовательский заголовок перед процессом сериализации.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, используйте where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // записываем GUID в заголовок.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // читаем пользовательский заголовок перед десериализацией
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>Если присвоить значение переменной <code>ref value</code>, можно изменить значение, используемое для сериализации/десериализации. Например, создать экземпляр через ServiceProvider.</p><pre><code class="language-csharp">// перед использованием этого форматтера, установите ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>Определение пользовательской коллекции
<hr>
По умолчанию, тип с аннотацией <code>[MemoryPackObject]</code> пытается сериализовать свои члены. Однако если тип является коллекцией (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), используйте <code>GenerateType.Collection</code> для корректной сериализации.</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Статический конструктор
<hr>
Класс с MemoryPackable не может определять статический конструктор, потому что генерируемый partial-класс использует его. Вместо этого можно определить метод <code>static partial void StaticConstructor()</code> для выполнения той же задачи.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Полиморфизм (Union)
<hr>
MemoryPack поддерживает сериализацию объектов интерфейсов и абстрактных классов для полиморфной сериализации. В MemoryPack эта функция называется Union. Только интерфейсы и абстрактные классы допускается аннотировать атрибутами <code>[MemoryPackUnion]</code>. Требуются уникальные теги union.</p><pre><code class="language-csharp">// Аннотируйте [MemoryPackable] и типы-наследники с помощью [MemoryPackUnion]
// Union также поддерживает абстрактные классы
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Сериализация как интерфейсного типа.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Десериализация как интерфейсного типа.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> допускает значения от <code>0</code> до <code>65535</code>, особенно эффективно использовать значения меньше <code>250</code>.
<pre><code class="language-">Если интерфейс и производные типы находятся в разных сборках, вместо этого можно использовать <code>MemoryPackUnionFormatterAttribute</code>. Форматтеры генерируются таким образом, что они автоматически регистрируются через <code>ModuleInitializer</code> в C# 9.0 и выше.</p><blockquote>Обратите внимание, что <code>ModuleInitializer</code> не поддерживается в Unity, поэтому форматтер необходимо регистрировать вручную. Для регистрации вашего union форматтера вызовите <code>{имя вашего union форматтера}Initializer.RegisterFormatter()</code> вручную при запуске. Например, <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB определяет объявление вне целевого типа
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
Union можно собрать в коде через <code>DynamicUnionFormatter<T></code>.
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
Serialize API
<hr>
У <code>Serialize</code> есть три перегрузки.
</code></pre>csharp
// Также доступен не-генерик API, в этих версиях первый аргумент — Type, а value — object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
Для повышения производительности рекомендуется использовать API с <code>BufferWriter</code>. Это сериализует данные напрямую в буфер. Может быть применено к <code>PipeWriter</code> из <code>System.IO.Pipelines</code>, <code>BodyWriter</code> в ASP .NET Core и т.д.</p><p>Если требуется <code>byte[]</code> (например, <code>RedisValue</code> в <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), возвращаемый API <code>byte[]</code> прост и почти так же быстр.</p><p>Обратите внимание, что <code>SerializeAsync</code> для <code>Stream</code> асинхронен только для Flush; он сериализует всё сразу во внутренний пул буфера MemoryPack, а затем записывает с помощью <code>WriteAsync</code>. Поэтому перегрузка с <code>BufferWriter</code>, которая разделяет и управляет буфером и flush, предпочтительнее.</p><p>Если вы хотите полностью потоковую запись, смотрите раздел <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> настраивает, сериализуются ли строки как UTF16 или UTF8. Это можно настроить, передав <code>MemoryPackSerializerOptions.Utf8</code> для кодировки UTF8, <code>MemoryPackSerializerOptions.Utf16</code> для кодировки UTF16 или <code>MemoryPackSerializerOptions.Default</code>, что по умолчанию использует UTF8. Передача null или использование параметра по умолчанию приводит к кодированию в UTF8.</p><p>Поскольку внутренняя реализация строки в C# — это UTF16, UTF16 работает быстрее. Однако полезная нагрузка обычно больше; в UTF8 ASCII-строка занимает один байт, а в UTF16 — два байта. Из-за значительной разницы в размере полезной нагрузки по умолчанию используется UTF8.</p><p>Если данные не ASCII (например, японский язык, где символ может занимать больше 3 байт, и UTF8 будет больше), или если вы планируете сжимать данные отдельно, UTF16 может дать лучшие результаты.</p><p>Хотя при сериализации можно выбрать UTF8 или UTF16, при десериализации указывать это не требуется. Формат будет определён и десериализован автоматически.</p><p>Дополнительно вы можете получить/установить <code>IServiceProvider? ServiceProvider { get; init; }</code> через опции. Это полезно для получения DI-объектов (например, <code>ILogger<T></code>) из процесса сериализации (<code>MemoryPackReader/MemoryPackWriter</code> имеют свойство .Options).</p><p>Deserialize API
<hr>
У <code>Deserialize</code> есть перегрузки для <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>, <code>Stream</code> и поддержка <code>ref</code>.
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
Перегрузка с <code>ref</code> перезаписывает существующий экземпляр, подробности смотрите в разделе <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a>.</p><p><code>DeserializeAsync(Stream)</code> — это не полностью потоковая операция чтения: сначала он читает во внутренний пул MemoryPack до конца потока, затем десериализует.</p><p>Если вы хотите полностью потоковую операцию чтения, смотрите раздел <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><p>Overwrite
<hr>
Для уменьшения количества аллокаций MemoryPack поддерживает десериализацию в существующий экземпляр, перезаписывая его. Это можно использовать с перегрузкой <code>Deserialize(ref T? value)</code>.
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// перезаписать данные в существующий экземпляр.
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack попытается перезаписать как можно больше, но если не совпадают следующие условия, будет создан новый экземпляр (как при обычной десериализации):</p><ul><li>ref значение (включая члены объектного графа) равно null — создать новый экземпляр</li>
<li>допускается только конструктор без параметров, если используется конструктор с параметрами — создать новый экземпляр</li>
<li>если значение — <code>T[]</code>, переиспользовать только если длина совпадает, иначе создать новый экземпляр</li>
<li>если значение — коллекция с методом <code>.Clear()</code> (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) — вызвать Clear() и переиспользовать, иначе создать новый экземпляр</li></p><p></ul>Version tolerant
<hr>
По умолчанию (<code>GenerateType.Object</code>) MemoryPack поддерживает ограниченную эволюцию схемы.</p><ul><li>unmanaged struct больше нельзя изменять</li>
<li>можно добавлять члены, но нельзя удалять</li>
<li>можно менять имя члена</li>
<li>нельзя менять порядок членов</li>
<li>нельзя менять тип члена</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Добавлять можно.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Удалять нельзя.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Менять порядок нельзя.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
В реальных сценариях — хранить старые данные (в файл, в redis и т.д.) и читать их новой схемой всегда допустимо. В RPC-сценарии схема существует и на клиенте, и на сервере, клиент должен быть обновлён раньше сервера. Обновлённый клиент без проблем подключается к старому серверу, но старый клиент не сможет подключиться к новому серверу.</p><p>
По умолчанию, когда старые данные читаются новой схемой, любые отсутствующие на стороне данных члены инициализируются литералом <code>default</code>.
Если вы хотите этого избежать и использовать начальные значения полей/свойств, используйте <code>[SuppressDefaultInitialization]</code>.
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < если старых данных нет, установить <code>111</code>.
    
    public int Prop3 { get; set; } = 222; // < если старых данных нет, установить <code>default</code>.
}
<pre><code class="language-">
 <code>[SuppressDefaultInitialization]</code> имеет следующие ограничения:
<ul><li>Нельзя использовать с модификаторами readonly, init-only и required.</li></p><p></ul>Следующий раздел <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> показывает, как проверять изменения схемы, например, средствами CI, чтобы предотвратить ошибки.</p><p>При использовании <code>GenerateType.VersionTolerant</code> поддерживается полная устойчивость к версиям.</p><ul><li>unmanaged struct больше нельзя изменять</li>
<li>всем членам нужно явно добавить <code>[MemoryPackOrder]</code> (кроме случаев с аннотацией <code>SerializeLayout.Sequential</code>)</li>
<li>члены можно добавлять и удалять, но нельзя переиспользовать порядок (можно использовать пропущенные номера)</li>
<li>можно менять имя члена</li>
<li>нельзя менять порядок членов</li>
<li>нельзя менять тип члена</li>
</ul></code></pre>csharp
// Допустимо сериализовать/десериализовать оба варианта
// VersionTolerantObject1 -> VersionTolerantObject2 и 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// удалено
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// добавлено
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// Если явно установить SerializeLayout.Sequential, члены будут упорядочены автоматически.
// Но в этом режиме нельзя удалять члены для поддержки version-tolerant.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> сериализуется медленнее, чем <code>GenerateType.Object</code>. Также размер полезной нагрузки будет немного больше.</p><p>Информация о сериализации
----
Вы можете проверить в IntelliSense, какие члены типа сериализуются. Существует опция записи этой информации в файл во время компиляции. Установите <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> следующим образом.</p><pre><code class="language-xml"><!-- вывод информации о сериализации memorypack в директорию -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>В файл будет записана следующая информация.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>Если тип неуправляемый, перед именем типа будет указано <code>unmanaged</code>.</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>Проверяя различия в этом файле, можно предотвратить опасные изменения схемы. Например, вы можете использовать CI для обнаружения следующих правил</p><ul><li>изменение неуправляемого типа</li>
<li>изменение порядка членов</li>
<li>удаление члена</li></p><p></ul>Циклические ссылки
<hr>
MemoryPack также поддерживает циклические ссылки. Это позволяет сериализовать дерево объектов как есть.</p><pre><code class="language-csharp">// чтобы включить циклические ссылки, используйте GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p> Например, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> код будет выглядеть следующим образом.</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> имеет те же характеристики, что и version-tolerant. Однако, как дополнительное ограничение, разрешены только конструкторы без параметров. Также отслеживание ссылок на объекты выполняется только для объектов, помеченных <code>GenerateType.CircularReference</code>. Если вы хотите отслеживать другие объекты, оберните их.</p><p>CustomFormatter
<hr>
Если реализовать <code>MemoryPackCustomFormatterAttribute<T></code> или <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (более производительно, но сложнее), вы можете настроить использование собственного форматтера для члена MemoryPackObject.</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack предоставляет следующие атрибуты форматирования: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // сериализовать этот член как строку UTF16, это быстрее, чем UTF8, но для ASCII размер больше (а для не-ASCII иногда меньше).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // При десериализации Dictionary инициализируется с StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // Во время десериализации все строки интернируются (см. String.Intern). Если одинаковые значения встречаются многократно, это экономит память.
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>Для настройки equality comparer для set/dictionary, все встроенные форматтеры имеют перегрузку конструктора с comparer. Вы можете легко создать свои собственные форматтеры с equality-comparer.</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> сжимает только типы <code>bool[]</code>. Обычно <code>bool[]</code> сериализуется как 1 байт на значение, однако <code>BitPackFormatter</code> сериализует <code>bool[]</code> как <code>BitArray</code>, сохраняя каждый bool в 1 бите. Используя <code>BitPackFormatter</code>, 8 bool-значений становятся 1 байтом вместо 8, что дает 8-кратное уменьшение размера.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> предназначен для <code>byte[]</code>, например, вы можете сжать большой payload с помощью Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> предназначен для <code>string</code>, сериализует строку (UTF16) в сжатом виде с помощью Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre></p><p><code>BrotliFormatter<T></code> предназначен для любого типа, сериализованные данные сжимаются с помощью Brotli. Если тип является <code>byte[]</code> или <code>string</code>, для повышения производительности рекомендуется использовать <code>BrotliFormatter</code> или <code>BrotliStringFormatter</code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}</code></pre></p><p>Десериализация с использованием пула массивов
<hr>
Для десериализации больших массивов (любого типа <code>T</code>) MemoryPack предлагает несколько эффективных методов с использованием пула. Наиболее эффективный способ — использовать функцию <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a>. В частности, <code>List<T></code> всегда переиспользуется.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> переиспользуется, не происходит аллокаций при десериализации.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// для эффективной работы можно получить Span<T> через CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);</code></pre></p><p>Удобный способ — десериализовать непосредственно в ArrayPool во время десериализации. MemoryPack предоставляет <code>MemoryPoolFormatter<T></code> и <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // Код возврата памяти вы должны написать самостоятельно, ниже пример.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // любые действия...
}   // возврат в ArrayPool</code></pre></p><p>Производительность
<hr>
Смотрите мою статью в блоге <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Размер полезной нагрузки и сжатие
<hr>
Размер полезной нагрузки зависит от целевого значения; в отличие от JSON, здесь нет ключей, и это бинарный формат, поэтому размер полезной нагрузки, скорее всего, будет меньше, чем у JSON.</p><p>Для форматов с varint-кодированием, таких как MessagePack и Protobuf, размер данных в MemoryPack может быть больше, если часто используются int (в MemoryPack int всегда 4 байта из-за фиксированного размера кодирования, в то время как в MessagePack это 1~5 байт).</p><p>float и double занимают 4 и 8 байт в MemoryPack, но 5 и 9 байт в MessagePack. Поэтому MemoryPack меньше, например, для массивов Vector3 (float, float, float).</p><p>Строки по умолчанию в формате UTF8, что аналогично другим сериализаторам, но если выбран вариант UTF16, это будет другой случай.</p><p>В любом случае, если размер полезной нагрузки велик, стоит рассмотреть возможность сжатия. Рекомендуются LZ4, ZStandard и Brotli.</p><h3>Сжатие</h3></p><p>MemoryPack предоставляет эффективный помощник для сжатия <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> через <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> и <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. Классы <code>BrotliCompressor</code> и <code>BrotliDecompressor</code> в MemoryPack обеспечивают сжатие/распаковку, оптимизированные для внутренней работы MemoryPack.</p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Сжатие (требуется using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Получить сжатый byte[]
var compressedBytes = compressor.ToArray();</p><p>// Или записать в другой IBufferWriter<byte> (например, PipeWriter)
compressor.CopyTo(response.BodyWriter);</code></pre></p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Распаковка (требуется using)
using var decompressor = new BrotliDecompressor();</p><p>// Получить распакованный ReadOnlySequence<byte> из ReadOnlySpan<byte> или ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);</code></pre></p><p>Оба класса <code>BrotliCompressor</code> и <code>BrotliDecompressor</code> являются структурами и не выделяют память в куче. Оба хранят сжатые или распакованные данные во внутреннем пуле памяти для Serialize/Deserialize. Поэтому необходимо освобождать пул памяти, не забывайте использовать <code>using</code>.</p><p>Уровень сжатия очень важен. По умолчанию установлен quality-1 (CompressionLevel.Fastest), что отличается от значения по умолчанию в .NET (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) по скорости будет близок к <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, но quality-4 значительно медленнее. Это было признано критически важным для сценария использования сериализатора. Будьте осторожны при использовании стандартного <code>BrotliStream</code> (по умолчанию quality-4). В любом случае, скорость и степень сжатия/распаковки могут существенно отличаться в зависимости от данных. Пожалуйста, подготовьте собственные данные и протестируйте самостоятельно.</p><p>Обратите внимание, что между несжатым MemoryPack и MemoryPack с Brotli существует многократная разница в скорости.</p><p>Brotli также поддерживается в пользовательском формате. <code>BrotliFormatter</code> может сжимать конкретное поле.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p>Сериализация внешних типов
<hr>
Если вы хотите сериализовать внешние типы, вы можете создать собственный форматтер и зарегистрировать его в провайдере, подробнее смотрите <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a>. Однако создание собственного форматтера довольно сложно. Поэтому рекомендуется создать обёрточный тип. Например, если вы хотите сериализовать внешний тип <code>AnimationCurve</code>.</p><pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}</code></pre></p><p>Тип, который необходимо обернуть, является общедоступным, но исключён из сериализации (<code>MemoryPackIgnore</code>). Свойства, которые вы хотите сериализовать, приватные, но включены (<code>MemoryPackInclude</code>). Также должны быть подготовлены два варианта конструкторов. Конструктор, используемый сериализатором, должен быть приватным.</p><p>В текущем виде требуется оборачивать каждый раз, что неудобно. Кроме того, обёртка-структура не может представлять null. Поэтому создадим пользовательский форматтер.</p><pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity не поддерживает scoped и TBufferWriter, поэтому измените сигнатуру на <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)</code></pre>csharp
{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
<pre><code class="language-">
Наконец, зарегистрируйте форматтер при запуске.
</code></pre>csharp
MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());
<pre><code class="language-">> Примечание: Unity's AnimationCurve может сериализоваться по умолчанию, поэтому этот пользовательский форматтер для AnimationCurve не требуется</p><p>Пакеты
<hr>
MemoryPack включает следующие пакеты.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> — это основная библиотека, предоставляющая полную поддержку высокопроизводительной сериализации и десериализации бинарных объектов. Она зависит от <code>MemoryPack.Core</code> для базовых библиотек и от <code>MemoryPack.Generator</code> для генерации кода. <code>MemoryPack.Streaming</code> добавляет дополнительные расширения для <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">потоковой сериализации</a>.  <code>MemoryPack.AspNetCoreMvcFormatter</code> добавляет форматтеры ввода/вывода для ASP.NET Core. <code>MemoryPack.UnityShims</code> добавляет типы-шимы и форматтеры для совместного использования типов между .NET и Unity.</p><p>TypeScript и ASP.NET Core Formatter
<hr>
MemoryPack поддерживает генерацию кода TypeScript. Он генерирует класс и код сериализации из C#, другими словами, вы можете делиться типами с браузером без использования OpenAPI, proto и т.д.</p><p>Генерация кода интегрирована с Source Generator, следующие опции (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) задают директорию вывода для кода TypeScript. Код рантайма выводится одновременно, поэтому дополнительные зависимости не требуются.
</code></pre>xml
<!-- вывод кода memorypack TypeScript в директорию -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
Тип C# MemoryPackable должен быть аннотирован атрибутом <code>[GenerateTypeScript]</code>.
</code></pre>csharp
[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}
<pre><code class="language-">
Код рантайма и типы TypeScript будут сгенерированы в целевой директории.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>Сгенерированный код выглядит следующим образом, с простыми полями и статическими методами для serialize/serializeArray и deserialize/deserializeArray.
</code></pre>typescript
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
<pre><code class="language-">
Вы можете использовать этот тип следующим образом.
</code></pre>typescript
let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// сериализация в Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// десериализация из ArrayBuffer 
let person2 = Person.deserialize(buffer);
<pre><code class="language-">
Пакет <code>MemoryPack.AspNetCoreMvcFormatter</code> добавляет входные и выходные форматтеры <code>MemoryPack</code> для ASP.NET Core MVC. Вы можете добавить <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> в ASP.NET Core MVC следующим образом.
</code></pre>csharp
var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Если checkContentType: true, то можно выводить несколько форматов (JSON/MemoryPack и др.). По умолчанию false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
<pre><code class="language-">
Если вы вызываете из HttpClient, вы можете установить <code>application/x-memorypack</code> в заголовке Content-Type.
</code></pre>csharp
var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");
<pre><code class="language-">
<h3>Сопоставление типов TypeScript</h3></p><p>Существует несколько ограничений на типы, которые могут быть сгенерированы. Среди примитивов не поддерживаются <code>char</code> и <code>decimal</code>. Также нельзя использовать типы OpenGenerics.</p><p>|  C#  |  TypeScript  | Описание |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</p><p>| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | В TypeScript представлен как строка, но сериализуется/десериализуется как 16-байтовое бинарное значение
| <code>DateTime</code> | <code>Date</code> | DateTimeKind будет проигнорирован
| <code>enum</code> | <code>const enum</code> | Не поддерживается базовый тип <code>long</code> и <code>ulong</code>
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Поддерживаются все типы, реализующие <code>ICollection<T></code>, такие как <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Поддерживаются все типы, реализующие <code>ISet<T></code>, такие как <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Поддерживаются все типы, реализующие <code>IDictionary<K,V></code>, такие как <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Поддерживаются только классы
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> может быть применён только к классам и в настоящее время не поддерживается для структур.</p><h3>Настройка расширения импортируемого файла и регистра имен членов</h3></p><p>По умолчанию MemoryPack генерирует расширение файла как <code>.js</code>, например: <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. Если вы хотите изменить расширение или сделать его пустым, используйте параметр <code>MemoryPackGenerator_TypeScriptImportExtension</code>.
Также имена членов автоматически преобразуются в camelCase. Если вы хотите использовать исходное имя, установите <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> в <code>false</code>.
</code></pre>xml
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- допускается пустое значение -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- значение по умолчанию true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- значение по умолчанию false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup>
<pre><code class="language-">
<code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> позволяет аннотациям nullable C# отображаться в TypeScript-коде. По умолчанию false, делая все nullable.</p><p>Сериализация потоков
<hr>
<code>MemoryPack.Streaming</code> предоставляет <code>MemoryPackStreamingSerializer</code>, который добавляет дополнительную поддержку сериализации и десериализации коллекций с использованием потоков.
</code></pre>csharp
public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}
<pre><code class="language-">
API Форматтер/Провайдер
<hr>
Если вы хотите реализовать форматтер вручную, наследуйте <code>MemoryPackFormatter<T></code> и переопределите методы <code>Serialize</code> и <code>Deserialize</code>.
</code></pre>csharp
public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // используйте методы writer.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // используйте методы reader.
    }
}
<pre><code class="language-">Созданный форматтер регистрируется с помощью <code>MemoryPackFormatterProvider</code>.
</code></pre>csharp
MemoryPackFormatterProvider.Register(new SkeltonFormatter());
<pre><code class="language-">
Примечание: <code>unmanged struct</code> (не содержит ссылочных типов) не может использовать пользовательский форматтер, всегда сериализуется в нативном формате памяти.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
Инициализация <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> требует OptionalState. Это обёртка над <code>MemoryPackSerializerOptions</code>, которую можно создать из <code>MemoryPackWriterOptionalStatePool</code>.
</code></pre>csharp
// при освобождении, OptionalState возвращается в пул.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// для Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}
<pre><code class="language-">
Зависимость от целевого фреймворка
<hr>
MemoryPack предоставляет <code>netstandard2.1</code> и <code>net7.0</code>, но они не совместимы между собой. Например, если типы MemoryPackable определены в проекте <code>netstandard2.1</code> и используются из проекта <code>net7.0</code>, будет выброшено исключение времени выполнения, подобное этому:</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Поскольку в net7.0 используются статические абстрактные члены (<code>Virtual static method</code>), которые не поддерживаются в netstandard2.1, такое поведение является спецификацией.</p><p>Проект .NET 7 не должен использовать dll для netstandard 2.1. Другими словами, если приложение – это проект .NET 7, все зависимости, использующие MemoryPack, должны поддерживать .NET 7. Поэтому, если библиотека зависит от MemoryPack, необходимо настроить поддержку двух целевых фреймворков.
</code></pre>xml
<TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks>
``<code></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> — это grpc-dotnet-фреймворк с подходом code-first, использующий MessagePack вместо protobuf. MagicOnion теперь поддерживает MemoryPack как слой сериализации через пакет </code>MagicOnion.Serialization.MemoryPack<code> (preview). Подробнее: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>Минимально поддерживаемая версия Unity — </code>2022.3.12f1<code>.</p><p>Базовый пакет </code>MemoryPack<code> предоставляется через nuget. Он также доступен в Unity. Для поддержки встроенных типов Unity мы дополнительно предоставляем расширение MemoryPack.Unity.</p><ul><li>Установите </code>MemoryPack<code> из NuGet с помощью <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Откройте окно NuGet -> Manage NuGet Packages, найдите "MemoryPack" и нажмите Install.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>Если возникла ошибка конфликта версий, отключите проверку версии в Player Settings (Edit -> Project Settings -> Player -> прокрутите вниз и разверните "Other Settings", затем снимите "Assembly Version Validation" в разделе "Configuration").</li></p><p><li>Установите пакет </code>MemoryPack.Unity<code>, добавив ссылку на git URL</li></p><p><li></code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity<code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack использует релизные теги <em>.</em>.*, поэтому вы можете указать версию как #1.0.0. Например: </code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0<code></p><p>
Как и в .NET-версии, код генерируется генератором кода (</code>MemoryPack.Generator.dll<code>). Реализация без рефлексии также обеспечивает наилучшую производительность в IL2CPP.</p><p>Для получения дополнительной информации об Unity и Source Generator обратитесь к <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">документации Unity</a>.</p><p>Source Generator также официально используется в Unity пакетами <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> и <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. Другими словами, это стандарт для генерации кода в следующем поколении Unity.</p><p>Вы можете сериализовать все unmanaged-типы (такие как </code>Vector3<code>, </code>Rect<code> и т.д.) и некоторые классы (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>). Если вы хотите сериализовать другие Unity-специфические типы, смотрите раздел <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a>.</p><p>По производительности в Unity MemoryPack быстрее JsonUtility в 3-10 раз.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>Если в общем коде используются типы Unity (</code>Vector2<code> и т.д.), MemoryPack предоставляет пакет </code>MemoryPack.UnityShims<code> в NuGet.</p><p>Пакет </code>MemoryPack.UnityShims<code> предоставляет заглушки для стандартных структур Unity (</code>Vector2<code>, </code>Vector3<code>, </code>Vector4<code>, </code>Quaternion<code>, </code>Color<code>, </code>Bounds<code>, </code>Rect<code>, </code>Keyframe<code>, </code>WrapMode<code>, </code>Matrix4x4<code>, </code>GradientColorKey<code>, </code>GradientAlphaKey<code>, </code>GradientMode<code>, </code>Color32<code>, </code>LayerMask<code>, </code>Vector2Int<code>, </code>Vector3Int<code>, </code>RangeInt<code>, </code>RectInt<code>, </code>BoundsInt<code>) и некоторых классов (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>).</p><blockquote>[!WARNING]</blockquote>
<blockquote>В настоящее время существуют следующие ограничения для использования в Unity</blockquote></p><ul><li>Версия для Unity не поддерживает CustomFormatter.</li>
<li>Если вы используете .NET7 или новее, бинарный формат MemoryPack полностью не совместим с Unity.</li>
    <li>Эта проблема возникает для value-типов, у которых явно указан </code>[StructLayout(LayoutKind.Auto)]<code>. (По умолчанию для struct используется </code>LayoutKind.Sequencil<code>.) Для таких типов бинарные данные, сериализованные в .NET, не могут быть десериализованы в Unity. Аналогично, бинарные данные, сериализованные в Unity, не могут быть сериализованы на .NET стороне.</li>
    <li>Обычно это касается следующих типов:</li>
        <li></code>DateTimeOffset<code></li>
        <li></code>ValueTuple<code></li>
    <li>На данный момент простое решение — не использовать эти типы.</li></p><p></ul>Native AOT
<hr>
К сожалению, .NET 7 Native AOT вызывает сбой (</code>Generic virtual method pointer lookup failure<code>) при использовании MemoryPack из-за бага рантайма. 
Он будет исправлен в .NET 8. Использование </code><code>Microsoft.DotNet.ILCompiler</code><code> preview-версии решает проблему в .NET 7. Подробнее о настройке смотрите в <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">комментарии к issue</a>.</p><p>Спецификация бинарного wire-формата
<hr>
Тип </code>T<code>, определённый в </code>Serialize<T><code> и </code>Deserialize<T><code>, называется C# схемой. Формат MemoryPack не является самоописательным. Для десериализации требуется соответствующая C# схема. Эти типы существуют как внутренние представления бинарных данных, но без C# схемы типы определить невозможно.</p><p>Порядок байт должен быть </code>Little Endian<code>. Однако эталонная реализация на C# не учитывает порядок байт, поэтому не может использоваться на big-endian машине. Однако современные компьютеры обычно используют little-endian.</p><p>Существует восемь типов форматов.</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circular Reference Object</li>
<li>Tuple</li>
<li>Collection</li>
<li>String</li>
<li>Union</li></p><p></ul><h3>Unmanaged struct</h3></p><p>Unmanaged struct — это структура C# без ссылочных типов, с аналогичным ограничением как у <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">неуправляемых типов C#</a>. Сериализация происходит согласно расположению структуры в памяти, включая паддинг.</p><h3>Object</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Объект содержит 1 байт (unsigned byte) в заголовке как количество членов. Количество членов допускает значения от </code>0<code> до </code>249<code>, </code>255<code> означает, что объект равен </code>null<code>. Values содержит значения memorypack для количества членов.</p><h3>Version Tolerant Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Version Tolerant Object похож на Object, но содержит длины значений в заголовке. varint следует этим спецификациям: первый sbyte — это значение или typeCode, следующие X байт — это значение. 0 до 127 = unsigned byte value, -1 до -120 = signed byte value, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Circular Reference Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Circular Reference Object похож на Version Tolerant Object, но если memberCount равен 250, следующий varint(unsigned-int32) — это referenceId. Если нет, после byte-length-of-values записывается varint referenceId.</p><h3>Tuple</h3></p><p></code>(values...)<code></p><p>Tuple — это коллекция значений фиксированного размера, не допускающая null. В .NET, </code>KeyValuePair<TKey, TValue><code> и </code>ValueTuple<T,...><code> сериализуются как Tuple.</p><h3>Collection</h3></p><p></code>(int length, [values...])<code></p><p>Collection содержит 4-байтовое знаковое целое число в заголовке как количество данных, </code>-1<code> обозначает </code>null<code>. Values содержит значения memorypack для количества length.</p><h3>String</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>String имеет две формы: UTF16 и UTF8. Если первое 4-байтовое знаковое целое равно </code>-1<code>, это означает null. </code>0<code> — пустая строка. UTF16 аналогичен коллекции (сериализуется как </code>ReadOnlySpan<char><code>, размер в байтах равен utf16-length * 2). Если первое знаковое целое <= </code>-2<code>, значение закодировано в UTF8. utf8-byte-count кодируется в дополнительном коде, </code>~utf8-byte-count<code> для получения количества байт. Следующее знаковое целое — utf16-length, допускается </code>-1<code>, что означает неизвестную длину. utf8-bytes содержит байты на количество utf8-byte-count.</p><h3>Union</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>Первый unsigned byte — это tag для дискриминируемого типа значения или флага, </code>0<code> до </code>249<code> — это tag, </code>250<code> означает, что следующий unsigned short — это tag, </code>255<code> означает, что union равен </code>null`.</p><p>License
<hr>
Эта библиотека лицензируется по лицензии MIT.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>