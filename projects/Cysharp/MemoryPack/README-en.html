<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in English. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in English. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, English, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in English. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-en.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">English</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Zero-encoding, extremely high-performance binary serializer for C# and Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>Compared with <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Measured on a .NET 7 / Ryzen 9 5950X machine. These serializers have <code>IBufferWriter<byte></code> methods, serialized using <code>ArrayBufferWriter<byte></code> and reused to avoid measuring buffer copy.</blockquote></p><p>For standard objects, MemoryPack is x10 faster and x2 ~ x5 faster than other binary serializers. For struct arrays, MemoryPack is even more powerful, with speeds up to x50 ~ x200 greater than other serializers.</p><p>MemoryPack is my 4th serializer; previously I've created well-known serializers, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. The reason for MemoryPack's speed is due to its C#-specific, C#-optimized binary format and a well-tuned implementation based on my past experience. It is also a completely new design utilizing .NET 7 and C# 11 and the Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) and there is also Unity support).</p><p>Other serializers perform many encoding operations such as VarInt encoding, tags, strings, etc. MemoryPack format uses a zero-encoding design that copies as much C# memory as possible. Zero-encoding is similar to FlatBuffers, but it doesn't require a special type; MemoryPack's serialization target is POCO.</p><p>Other than performance, MemoryPack has these features:</p><ul><li>Supports modern I/O APIs (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Native AOT-friendly Source Generator based code generation, no Dynamic CodeGen (IL.Emit)</li>
<li>Reflectionless non-generic APIs</li>
<li>Deserialize into existing instances</li>
<li>Polymorphism (Union) serialization</li>
<li>Limited version-tolerant (fast/default) and full version-tolerant support</li>
<li>Circular reference serialization</li>
<li>PipeWriter/Reader-based streaming serialization</li>
<li>TypeScript code generation and ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP Support via .NET Source Generator</li></p><p></ul>Installation
<hr>
This library is distributed via NuGet. For best performance, it is recommended to use <code>.NET 7</code>. The minimum requirement is <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>A code editor also requires Roslyn 4.3.1 support, for example Visual Studio 2022 version 17.3, .NET SDK 6.0.401. For details, see the <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a> document.</p><p>For Unity, the requirements and installation process are completely different. See the <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a> section for details.</p><p>Quick Start
<hr>
Define a struct or class to be serialized and annotate it with the <code>[MemoryPackable]</code> attribute and the <code>partial</code> keyword.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>Serialization code is generated by the C# source generator feature which implements the <code>IMemoryPackable<T></code> interface. In Visual Studio you can check the generated code by using the shortcut <code>Ctrl+K, R</code> on the class name and selecting <code>*.MemoryPackFormatter.g.cs</code>.</p><p>Call <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> to serialize/deserialize an object instance.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>The <code>Serialize</code> method supports a return type of <code>byte[]</code> as well as serializing to <code>IBufferWriter<byte></code> or <code>Stream</code>. The <code>Deserialize</code> method supports <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>, and <code>Stream</code>. There are also non-generic versions.</p><p>Built-in supported types
<hr>
These types can be serialized by default:</p><ul><li>.NET primitives (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.)</li>
<li>Unmanaged types (Any <code>enum</code>, Any user-defined <code>struct</code> which doesn't contain reference types)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>, <code>ReadOnlyDictionary<,></code></li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code></li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Immutable collections (<code>ImmutableList<></code>, etc.) and interfaces (<code>IImmutableList<></code>, etc.)</li></p><p></ul>Define <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> can be annotated on any <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code>, and <code>interface</code>. If a type is a <code>struct</code> or <code>record struct</code> which contains no reference types (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>), any additional annotation (ignore, include, constructor, callbacks) is not used, and it serializes/deserializes directly from memory.</p><p>Otherwise, by default, <code>[MemoryPackable]</code> serializes public instance properties or fields. You can use <code>[MemoryPackIgnore]</code> to remove a serialization target, <code>[MemoryPackInclude]</code> promotes a private member to a serialization target.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // these types are serialized by default
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // these types are not serialized by default
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // use [MemoryPackIgnore] to remove target of a public member
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // use [MemoryPackInclude] to promote a private member to serialization target
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>MemoryPack's code generator adds information about which members are serialized to the <code><remarks /></code> section. This can be viewed by hovering over the type with Intellisense.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>All members must be memorypack-serializable; if not, the code generator will emit an error.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack has 35 diagnostic rules (<code>MEMPACK001</code> to <code>MEMPACK035</code>) to help define types comfortably.</p><p>If a target type is defined for MemoryPack serialization externally and registered, use <code>[MemoryPackAllowSerialize]</code> to silence diagnostics.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>Member order is <strong>important</strong>; MemoryPack does not serialize the member name or other information, instead serializing fields in the order they are declared. If a type is inherited, serialization is performed in the order of parent → child. The order of members cannot change for deserialization. For schema evolution, see the <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a> section.</p><p>The default order is sequential, but you can choose the explicit layout with <code>[MemoryPackable(SerializeLayout.Explicit)]</code> and <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// serialize Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Constructor selection</h3></p><p>MemoryPack supports both parameterized and parameterless constructors. The selection of the constructor follows these rules (applies to classes and structs):</p><ul><li>If there is <code>[MemoryPackConstructor]</code>, use it.</li>
<li>If there is no explicit constructor (including private), use a parameterless one.</li>
<li>If there is one parameterless/parameterized constructor (including private), use it.</li>
<li>If there are multiple constructors, then the <code>[MemoryPackConstructor]</code> attribute must be applied to the desired constructor (the generator will not automatically choose one), otherwise the generator will emit an error.</li>
<li>If using a parameterized constructor, all parameter names must match corresponding member names (case-insensitive).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // You can use a parameterized constructor - parameter names must match corresponding member names (case-insensitive)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// also supports record primary constructor
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// If there are multiple constructors, then [MemoryPackConstructor] should be used
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>Serialization callbacks</h3></p><p>When serializing/deserializing, MemoryPack can invoke a before/after event using the <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> attributes. It can annotate both static and instance (non-static) methods, and public and private methods.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // method call order is static -> instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // also allows private method
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Note: instance method with MemoryPackOnDeserializing, that not called if instance is not passed by <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>Callbacks allow parameterless methods and <code>ref reader/writer, ref T value</code> methods. For example, ref callbacks can write/read a custom header before the serialization process.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, use where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // emit GUID in header.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // read custom header before deserialize
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>If you set a value to <code>ref value</code>, you can change the value used for serialization/deserialization. For example, instantiate from ServiceProvider.</p><pre><code class="language-csharp">// before using this formatter, set ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>Define custom collection
<hr>
By default, a type annotated with <code>[MemoryPackObject]</code> will try to serialize its members. However, if a type is a collection (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), use <code>GenerateType.Collection</code> to serialize it correctly.</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Static constructor
<hr>
A MemoryPackable class cannot define a static constructor because the generated partial class uses it. Instead, you can define a <code>static partial void StaticConstructor()</code> to do the same thing.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Polymorphism (Union)
<hr>
MemoryPack supports serializing interface and abstract class objects for polymorphic serialization. In MemoryPack this feature is called Union. Only interfaces and abstract classes are allowed to be annotated with <code>[MemoryPackUnion]</code> attributes. Unique union tags are required.</p><pre><code class="language-csharp">// Annotate [MemoryPackable] and inheritance types with [MemoryPackUnion]
// Union also supports abstract class
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Serialize as interface type.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Deserialize as interface type.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> allows <code>0</code> ~ <code>65535</code>, it is especially efficient for less than <code>250</code>.
<pre><code class="language-">If an interface and derived types are in different assemblies, you can use <code>MemoryPackUnionFormatterAttribute</code> instead. Formatters are generated in a way that they are automatically registered via <code>ModuleInitializer</code> in C# 9.0 and above.</p><blockquote>Note that <code>ModuleInitializer</code> is not supported in Unity, so the formatter must be manually registered. To register your union formatter, invoke <code>{name of your union formatter}Initializer.RegisterFormatter()</code> manually in Startup. For example, <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB define definition outside of target type
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
A union can be assembled in code via <code>DynamicUnionFormatter<T></code>.
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
Serialize API
<hr>
<code>Serialize</code> has three overloads.
</code></pre>csharp
// Non generic API also available, these version is first argument is Type and value is object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
For performance, the recommended API uses <code>BufferWriter</code>. This serializes directly into the buffer. It can be applied to <code>PipeWriter</code> in <code>System.IO.Pipelines</code>, <code>BodyWriter</code> in ASP .NET Core, etc.</p><p>If a <code>byte[]</code> is required (e.g. <code>RedisValue</code> in <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), the returned <code>byte[]</code> API is simple and almost as fast.</p><p>Note that <code>SerializeAsync</code> for <code>Stream</code> is asynchronous only for Flush; it serializes everything once into MemoryPack's internal pool buffer and then writes using <code>WriteAsync</code>. Therefore, the <code>BufferWriter</code> overload, which separates and controls buffer and flush, is better.</p><p>If you want to do a complete streaming write, see the <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a> section.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> configures whether strings are serialized as UTF16 or UTF8. This can be configured by passing <code>MemoryPackSerializerOptions.Utf8</code> for UTF8 encoding, <code>MemoryPackSerializerOptions.Utf16</code> for UTF16 encoding, or <code>MemoryPackSerializerOptions.Default</code> which defaults to UTF8. Passing null or using the default parameter results in UTF8 encoding.</p><p>Since C#'s internal string representation is UTF16, UTF16 performs better. However, the payload tends to be larger; in UTF8, an ASCII string is one byte, while in UTF16 it is two bytes. Because the difference in the size of this payload is so large, UTF8 is set by default.</p><p>If the data is non-ASCII (e.g. Japanese, which can be more than 3 bytes, and UTF8 is larger), or if you have to compress it separately, UTF16 may give better results.</p><p>While UTF8 or UTF16 can be selected during serialization, it is not necessary to specify it during deserialization. It will be automatically detected and deserialized normally.</p><p>Additionally, you can get/set <code>IServiceProvider? ServiceProvider { get; init; }</code> from options. It is useful to get a DI object (such as <code>ILogger<T></code>) from the serialization process (<code>MemoryPackReader/MemoryPackWriter</code> has an .Options property).</p><p>Deserialize API
<hr>
<code>Deserialize</code> has <code>ReadOnlySpan<byte></code> and <code>ReadOnlySequence<byte></code>, <code>Stream</code> overload, and <code>ref</code> support.
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
The <code>ref</code> overload overwrites an existing instance; for details see the <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a> section.</p><p><code>DeserializeAsync(Stream)</code> is not a complete streaming read operation; first, it reads into MemoryPack's internal pool up to the end-of-stream, then it deserializes.</p><p>If you want to do a complete streaming read operation, see the <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a> section.</p><p>Overwrite
<hr>
To reduce allocations, MemoryPack supports deserializing to an existing instance, overwriting it. This can be used with the <code>Deserialize(ref T? value)</code> overload.
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// overwrite data to existing instance.
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack will attempt to overwrite as much as possible, but if the following conditions do not match, it will create a new instance (as in normal deserialization).</p><ul><li>ref value (includes members in object graph) is null, set new instance</li>
<li>only allows parameterless constructor, if parameterized constructor is used, create new instance</li>
<li>if value is <code>T[]</code>, reuse only if the length is the same, otherwise create new instance</li>
<li>if value is a collection that has a <code>.Clear()</code> method (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) call Clear() and reuse it, otherwise create new instance</li></p><p></ul>Version tolerant
<hr>
By default (<code>GenerateType.Object</code>), MemoryPack supports limited schema evolution.</p><ul><li>unmanaged struct can't be changed anymore</li>
<li>members can be added, but cannot be deleted</li>
<li>can change member name</li>
<li>can't change member order</li>
<li>can't change member type</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Add is OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Remove is NG.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Change order is NG.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
In use-case, storing old data (to file, to redis, etc...) and reading to new schema is always ok. In the RPC scenario, schema exists both on the client and the server side, the client must be updated before the server. An updated client has no problem connecting to the old server but an old client cannot connect to a new server.</p><p>By default, when old data is read to a new schema, any members not on the data side are initialized with the <code>default</code> literal.
If you want to avoid this and use initial values of fields/properties, you can use <code>[SuppressDefaultInitialization]</code>.
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < if old data is missing, set <code>111</code>.
    
    public int Prop3 { get; set; } = 222; // < if old data is missing, set <code>default</code>.
}
<pre><code class="language-">
 <code>[SuppressDefaultInitialization]</code> has the following limitation:
<ul><li>Cannot be used with readonly, init-only, and required modifier.</li></p><p></ul>The next <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> section shows how to check for schema changes, e.g., by CI, to prevent accidents.</p><p>When using <code>GenerateType.VersionTolerant</code>, it supports full version-tolerance.</p><ul><li>unmanaged struct can't change anymore</li>
<li>all members must add <code>[MemoryPackOrder]</code> explicitly (except annotate <code>SerializeLayout.Sequential</code>)</li>
<li>members can be added, can be deleted but not reuse order (can use missing order)</li>
<li>can change member name</li>
<li>can't change member order</li>
<li>can't change member type</li>
</ul></code></pre>csharp
// Ok to serialize/deserialize both 
// VersionTolerantObject1 -> VersionTolerantObject2 and 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// deleted
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// added
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// If you set SerializeLayout.Sequential explicitly, automatic ordering is allowed.
// However, you cannot remove any member for version-tolerance.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> is slower than <code>GenerateType.Object</code> during serialization. Also, the payload size will be slightly larger.</p><p>Serialization info
----
You can check which members are serialized using IntelliSense on the type. There is an option to output this information to a file at compile time. Set <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> as follows.</p><pre><code class="language-xml"><!-- output memorypack serialization info to directory -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>The following information will be written to the file.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>If the type is unmanaged, <code>unmanaged</code> is shown before the type name.</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>By checking the differences in this file, dangerous schema changes can be prevented. For example, you may want to use CI to detect the following rules:</p><ul><li>modification of unmanaged types</li>
<li>member order changes</li>
<li>member deletions</li></p><p></ul>Circular Reference
<hr>
MemoryPack also supports circular references. This allows tree objects to be serialized as they are.</p><pre><code class="language-csharp">// to enable circular-reference, use GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p>For example, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> code will look like this.</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> has the same characteristics as version-tolerant. However, as an additional constraint, only parameterless constructors are allowed. Also, object reference tracking is only performed for objects marked with <code>GenerateType.CircularReference</code>. If you want to track any other object, wrap it.</p><p>CustomFormatter
<hr>
If you implement <code>MemoryPackCustomFormatterAttribute<T></code> or <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (more performant, but more complex), you can configure a custom formatter for a MemoryPackObject's member.</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack provides the following formatting attributes: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // serialize this member as UTF16 String, it is more performant than UTF8 but for ASCII, the size is larger (but for non-ASCII, sometimes smaller).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // During deserialization, Dictionary is initialized with StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // During deserialization, all strings are interned (see: String.Intern). If similar values appear repeatedly, it saves memory.
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>To configure a set/dictionary's equality comparer, all built-in formatters have a comparer constructor overload. You can easily create custom equality-comparer formatters.</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> compresses only <code>bool[]</code> types. <code>bool[]</code> is normally serialized as 1 byte per boolean value, but <code>BitPackFormatter</code> serializes <code>bool[]</code> like a <code>BitArray</code>, storing each bool as 1 bit. Using <code>BitPackFormatter</code>, 8 bools become 1 byte instead of 8 bytes, resulting in a size 8x smaller.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> is for <code>byte[]</code>; for example, you can compress a large payload using Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> is for <code>string</code>; it serializes a compressed string (UTF16) using Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre>
<pre><code class="language-"><code>BrotliFormatter<T></code> is for any type, serialized data compressed by Brotli. If a type is <code>byte[]</code> or <code>string</code>, you should use <code>BrotliFormatter</code> or <code>BrotliStringFormatter</code> for performance.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}
<pre><code class="language-">
Deserialize array pooling
<hr>
In order to deserialize a large array (any <code>T</code>), MemoryPack offers multiple efficient pooling methods. The most effective way is to use the <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a> function. In particular <code>List<T></code> is always reused.
</code></pre>csharp
[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> is reused, no allocation in deserialize.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// for efficient operation, you can get Span<T> by CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);
<pre><code class="language-">
A convenient way is to deserialize to an ArrayPool at deserialization time. MemoryPack provides <code>MemoryPoolFormatter<T></code> and <code>ReadOnlyMemoryPoolFormatter<T></code>.
</code></pre>csharp
[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // You must write the return code yourself, here is snippet.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // do anything...
}   // return to ArrayPool
<pre><code class="language-">
Performance
<hr>
See the my blog post <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Payload size and compression
<hr>
Payload size depends on the target value; unlike JSON, there are no keys and it is a binary format, so the payload size is likely to be smaller than JSON.</p><p>For those with varint encoding, such as MessagePack and Protobuf, MemoryPack tends to be larger if ints are used a lot (in MemoryPack, ints are always 4 bytes due to fixed size encoding, while MessagePack is 1~5 bytes).</p><p>float and double are 4 bytes and 8 bytes in MemoryPack, but 5 bytes and 9 bytes in MessagePack. So MemoryPack is smaller, for example, for Vector3 (float, float, float) arrays.</p><p>String is UTF8 by default, which is similar to other serializers, but if the UTF16 option is chosen, it will be of a different nature.</p><p>In any case, if the payload size is large, compression should be considered. LZ4, ZStandard and Brotli are recommended.</p><h3>Compression</h3></p><p>MemoryPack provides an efficient helper for <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> compression via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. MemoryPack's <code>BrotliCompressor</code> and <code>BrotliDecompressor</code> provide compression/decompression optimized for MemoryPack's internal behavior.
</code></pre>csharp
using MemoryPack.Compression;</p><p>// Compression(require using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Get compressed byte[]
var compressedBytes = compressor.ToArray();</p><p>// Or write to other IBufferWriter<byte>(for example PipeWriter)
compressor.CopyTo(response.BodyWriter);
<pre><code class="language-"></code></pre>csharp
using MemoryPack.Compression;</p><p>// Decompression(require using)
using var decompressor = new BrotliDecompressor();</p><p>// Get decompressed ReadOnlySequence<byte> from ReadOnlySpan<byte> or ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);
<pre><code class="language-">
Both <code>BrotliCompressor</code> and <code>BrotliDecompressor</code> are struct, it does not allocate memory on heap. Both store compressed or decompressed data in an internal memory pool for Serialize/Deserialize. Therefore, it is necessary to release the memory pooling, don't forget to use <code>using</code>.</p><p>Compression level is very important. The default is set to quality-1 (CompressionLevel.Fastest), which is different from the .NET default (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) will be close to the speed of <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, but 4 is much slower. This was determined to be critical in the serializer use scenario. Be careful when using the standard <code>BrotliStream</code> (quality-4 is the default). In any case, compression/decompression speeds and sizes will result in very different results for different data. Please prepare the data to be handled by your application and test it yourself.</p><p>Note that there is a several-fold speed penalty between MemoryPack's uncompressed and Brotli's added compression.</p><p>Brotli is also suppored in a custom formatter. <code>BrotliFormatter</code> can compress a specific member.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
<pre><code class="language-">
Serialize external types
<hr>
If you want to serialize external types, you can make a custom formatter and register it to provider, see <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> for details. However, creating a custom formatter is difficult. Therefore, we recommend making a wrapper type. For example, if you want to serialize an external type called <code>AnimationCurve</code>.
</code></pre>csharp
// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}
<pre><code class="language-">
The type to wrap is public, but excluded from serialization (<code>MemoryPackIgnore</code>). The properties you want to serialize are private, but included (<code>MemoryPackInclude</code>). Two patterns of constructors should also be prepared. The constructor used by the serializer should be private.</p><p>As it is, it must be wrapped every time, which is inconvenient. And also strcut wrapper can not represents null. So let's create a custom formatter.
</code></pre>csharp
public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity does not support scoped and TBufferWriter so change signature to <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)
<pre><code class="language-csharp">{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
}</code></pre></p><p>Finally, register the formatter in startup.</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());</code></pre>
<blockquote>Note: Unity's AnimationCurve can be serialized by default so this custom formatter is not needed for AnimationCurve</blockquote></p><p>Packages
<hr>
MemoryPack includes the following packages.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> is the main library, providing full support for high-performance serialization and deserialization of binary objects. It depends on <code>MemoryPack.Core</code> for the core base libraries and <code>MemoryPack.Generator</code> for code generation. <code>MemoryPack.Streaming</code> adds additional extensions for <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>. <code>MemoryPack.AspNetCoreMvcFormatter</code> adds input/output formatters for ASP.NET Core. <code>MemoryPack.UnityShims</code> adds Unity shim types and formatters for sharing types between .NET and Unity.</p><p>TypeScript and ASP.NET Core Formatter
<hr>
MemoryPack supports TypeScript code generation. It generates classes and serialization code from C#. In other words, you can share types with the Browser without using OpenAPI, proto, etc.</p><p>Code generation is integrated with Source Generator. The following option (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) sets the output directory for TypeScript code. Runtime code is output at the same time, so no additional dependencies are required.</p><pre><code class="language-xml"><!-- output memorypack TypeScript code to directory -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup></code></pre></p><p>A C# MemoryPackable type must be annotated with <code>[GenerateTypeScript]</code>.</p><pre><code class="language-csharp">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}</code></pre></p><p>Runtime code and TypeScript type will be generated in the target directory.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>The generated code is as follows, with simple fields and static methods for serialize/serializeArray and deserialize/deserializeArray.</p><pre><code class="language-typescript">import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}</code></pre></p><p>You can use this type as follows.</p><pre><code class="language-typescript">let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// serialize to Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// deserialize from ArrayBuffer 
let person2 = Person.deserialize(buffer);</code></pre></p><p>The <code>MemoryPack.AspNetCoreMvcFormatter</code> package adds <code>MemoryPack</code> input and output formatters for ASP.NET Core MVC. You can add <code>MemoryPackInputFormatter</code> and <code>MemoryPackOutputFormatter</code> to ASP.NET Core MVC with the following code.</p><pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // If checkContentType: true then can output multiple formats (JSON/MemoryPack, etc...). Default is false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});</code></pre></p><p>If you call from HttpClient, you can set <code>application/x-memorypack</code> to the content header.</p><pre><code class="language-csharp">var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");</code></pre></p><h3>TypeScript Type Mapping</h3></p><p>There are a few restrictions on the types that can be generated. Among the primitives, <code>char</code> and <code>decimal</code> are not supported. Also, OpenGenerics types cannot be used.</p><p>|  C#  |  TypeScript  | Description |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |
<pre><code class="language-">| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | In TypeScript, represents as string but serialize/deserialize as 16byte binary
| <code>DateTime</code> | <code>Date</code> | DateTimeKind will be ignored
| <code>enum</code> | <code>const enum</code> | <code>long</code> and <code>ulong</code> underlying type is not supported
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Supports all <code>ICollection<T></code> implemented type like <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Supports all <code>ISet<T></code> implemented type like <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Supports all <code>IDictionary<K,V></code> implemented type like <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Supports class only
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> can only be applied to classes and is currently not supported by struct.</p><h3>Configure import file extension and member name casing</h3></p><p>By default, MemoryPack generates file extensions as <code>.js</code> like <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. If you want to change to another extension or leave it empty, use <code>MemoryPackGenerator_TypeScriptImportExtension</code> to configure it.
Also, member names are automatically converted to camelCase. If you want to use the original name, set <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> to <code>false</code>.
</code></pre>xml
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- allows empty -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- default is true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- default is false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup>
<pre><code class="language-">
<code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> allows C# nullable annotations to be reflected in TypeScript code. The default is false, making everything nullable.</p><p>Streaming Serialization
<hr>
<code>MemoryPack.Streaming</code> provides <code>MemoryPackStreamingSerializer</code>, which adds additional support for serializing and deserializing collections with streams.
</code></pre>csharp
public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}
<pre><code class="language-">
Formatter/Provider API
<hr>
If you want to implement a formatter manually, inherit from <code>MemoryPackFormatter<T></code> and override the <code>Serialize</code> and <code>Deserialize</code> methods.
</code></pre>csharp
public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // use writer method.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // use reader method.
    }
}
<pre><code class="language-">The created formatter is registered with <code>MemoryPackFormatterProvider</code>.
</code></pre>csharp
MemoryPackFormatterProvider.Register(new SkeltonFormatter());
<pre><code class="language-">
Note: <code>unmanaged struct</code> (doesn't contain reference types) cannot use custom formatter, it always serializes native memory layout.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
Initializing <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> requires OptionalState. It is a wrapper of <code>MemoryPackSerializerOptions</code>, and can be created from <code>MemoryPackWriterOptionalStatePool</code>.
</code></pre>csharp
// when disposed, OptionalState will return to pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// for Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}
<pre><code class="language-">
Target framework dependency
<hr>
MemoryPack provides <code>netstandard2.1</code> and <code>net7.0</code> but both are not compatible. For example, if you have MemoryPackable types under a <code>netstandard2.1</code> project and use them from a <code>net7.0</code> project, it throws a runtime exception like this</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Since net7.0 uses static abstract members (<code>Virtual static method</code>), which are not supported in netstandard2.1, this behavior is by design.</p><p>A .NET 7 project shouldn't use the netstandard 2.1 dll. In other words, if the Application is a .NET 7 Project, all the dependencies that use MemoryPack must support .NET 7. So if a library developer has a dependency on MemoryPack, you need to configure dual target frameworks.
</code></pre>xml
<TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks>
``<code></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> is a code-first grpc-dotnet framework using MessagePack instead of protobuf. MagicOnion now supports MemoryPack as a serialization layer via the </code>MagicOnion.Serialization.MemoryPack<code> package (preview). See details: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>Minimum supported Unity version is </code>2022.3.12f1<code>.</p><p>The </code>MemoryPack<code> core package is provided by NuGet. It is also available in Unity. If you want to get Unity built-in type support, we additionally provide the MemoryPack.Unity extension.</p><ul><li>Install </code>MemoryPack<code> from NuGet using <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Open the NuGet window -> Manage NuGet Packages, Search "MemoryPack" and Press Install.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>If you encounter version conflicts error, please disable version validation in Player Settings (Edit -> Project Settings -> Player -> Scroll down and expand "Other Settings" then uncheck "Assembly Version Validation" under the "Configuration" section).</li></p><p><li>Install the </code>MemoryPack.Unity<code> package by referencing the git URL</li></p><p><li></code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity<code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack uses the <em>.</em>.* release tag, so you can specify a version like #1.0.0. For example: </code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0<code></p><p>
As with the .NET version, the code is generated by a code generator (</code>MemoryPack.Generator.dll<code>). The reflection-free implementation also provides the best performance in IL2CPP.</p><p>For more information on Unity and Source Generator, please refer to the <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">Unity documentation</a>.</p><p>Source Generator is also used officially by Unity by <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> and <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. In other words, it is the standard for code generation in the next generation of Unity.</p><p>You can serialize all unmanaged types (such as </code>Vector3<code>, </code>Rect<code>, etc...) and some classes (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>). If you want to serialize other Unity-specific types, see the <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a> section.</p><p>In Unity performance, MemoryPack is x3~x10 faster than JsonUtility.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>If shared code has Unity's type (</code>Vector2<code>, etc...), MemoryPack provides a </code>MemoryPack.UnityShims<code> package in NuGet.</p><p>The </code>MemoryPack.UnityShims<code> package provides shims for Unity's standard structs (</code>Vector2<code>, </code>Vector3<code>, </code>Vector4<code>, </code>Quaternion<code>, </code>Color<code>, </code>Bounds<code>, </code>Rect<code>, </code>Keyframe<code>, </code>WrapMode<code>, </code>Matrix4x4<code>, </code>GradientColorKey<code>, </code>GradientAlphaKey<code>, </code>GradientMode<code>, </code>Color32<code>, </code>LayerMask<code>, </code>Vector2Int<code>, </code>Vector3Int<code>, </code>RangeInt<code>, </code>RectInt<code>, </code>BoundsInt<code>) and some classes (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>).</p><blockquote>[!WARNING]</blockquote>
<blockquote>Currently, the following limitations exist for use in Unity</blockquote></p><ul><li>The Unity version does not support CustomFormatter.</li>
<li>If you are using .NET7 or later, MemoryPack binary format is not fully compatible with Unity.</li>
    <li>This problem occurs with value types where </code>[StructLayout(LayoutKind.Auto)]<code> is explicitly specified. (The default for struct is </code>LayoutKind.Sequential<code>.) For such types, binaries serialized in .NET cannot be deserialized in Unity. Similarly, a binary serialized in Unity cannot be deserialized on the .NET side.</li>
    <li>The affected types typically include the following types.</li>
        <li></code>DateTimeOffset<code></li>
        <li></code>ValueTuple<code></li>
    <li>Currently, the simple solution is to not use these types.</li></p><p>
</ul>Native AOT
<hr>
Unfortunately, .NET 7 Native AOT causes crashes (</code>Generic virtual method pointer lookup failure<code>) when using MemoryPack due to a runtime bug. It 
is going to be fixed in .NET 8. Using the </code>Microsoft.DotNet.ILCompiler<code> preview version will fix it in .NET 7. Please see <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">issue's comment</a> on how to set it up.</p><p>Binary wire format specification
<hr>
The type of </code>T<code> defined in </code>Serialize<T><code> and </code>Deserialize<T><code> is called the C# schema. The MemoryPack format is not a self-describing format. Deserialization requires the corresponding C# schema. These types exist as internal representations of binaries, but types cannot be determined without a C# schema.</p><p>Endianness must be </code>Little Endian<code>. However, the reference C# implementation does not care about endianness so it cannot be used on big-endian machines. However, modern computers are usually little-endian.</p><p>There are eight types of format.</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circular Reference Object</li>
<li>Tuple</li>
<li>Collection</li>
<li>String</li>
<li>Union</li></p><p></ul><h3>Unmanaged struct</h3></p><p>Unmanaged struct is a C# struct that doesn't contain reference types, similar constraint of <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>. Serializing struct layout as it is, includes padding.</p><h3>Object</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Object has a 1-byte unsigned byte as the member count in the header. Member count allows </code>0<code> to </code>249<code>, </code>255<code> represents object is </code>null<code>. Values store memorypack value for the number of member count.</p><h3>Version Tolerant Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Version Tolerant Object is similar to Object but has byte length of values in the header. varint follows these specs: first sbyte is value or typeCode and next X bytes is value. 0 to 127 = unsigned byte value, -1 to -120 = signed byte value, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Circular Reference Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Circular Reference Object is similar to Version Tolerant Object but if memberCount is 250, next varint(unsigned-int32) is referenceId. If not, after byte-length-of-values, varint referenceId is written.</p><h3>Tuple</h3></p><p></code>(values...)<code></p><p>Tuple is a fixed-size, non-nullable value collection. In .NET, </code>KeyValuePair<TKey, TValue><code> and </code>ValueTuple<T,...><code> are serialized as Tuple.</p><h3>Collection</h3></p><p></code>(int length, [values...])<code></p><p>Collection has a 4-byte signed integer as data count in the header, </code>-1<code> represents </code>null<code>. Values store memorypack value for the number of length.</p><h3>String</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>String has two forms, UTF16 and UTF8. If first 4-byte signed integer is </code>-1<code>, represents null. </code>0<code> represents empty. UTF16 is same as collection (serialized as </code>ReadOnlySpan<char><code>, utf16-value's byte count is utf16-length * 2). If first signed integer <= </code>-2<code>, value is encoded by UTF8. utf8-byte-count is encoded in complement, use </code>~utf8-byte-count<code> to retrieve count of bytes. Next signed integer is utf16-length, it allows </code>-1<code> that represents unknown length. utf8-bytes store bytes for the number of utf8-byte-count.</p><h3>Union</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>First unsigned byte is tag that is for discriminated value type or flag, </code>0<code> to </code>249<code> represents tag, </code>250<code> means the next unsigned short is tag, </code>255<code> represents union is </code>null`.</p><p>License
<hr>
This library is licensed under the MIT License.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>