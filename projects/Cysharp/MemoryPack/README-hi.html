<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Hindi. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Hindi. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Hindi, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Hindi. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-hi.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Hindi</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र।</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>तुलना की गई है <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a> के साथ। .NET 7 / Ryzen 9 5950X मशीन द्वारा मापा गया। इन सीरियलाइज़रों में <code>IBufferWriter<byte></code> विधि है, जिसे <code>ArrayBufferWriter<byte></code> के उपयोग से सीरियलाइज़ किया गया है और बफर कॉपी को मापने से बचने के लिए पुन: उपयोग किया गया है।</blockquote></p><p>सामान्य ऑब्जेक्ट्स के लिए, MemoryPack x10 गुना तेज़ और अन्य बाइनरी सीरियलाइज़रों की तुलना में x2 ~ x5 गुना तेज़ है। स्ट्रक्चर एरे के लिए, MemoryPack और भी अधिक शक्तिशाली है, जिसकी गति अन्य सीरियलाइज़रों से x50 ~ x200 गुना अधिक है।</p><p>MemoryPack मेरा चौथा सीरियलाइज़र है, इससे पहले मैंने प्रसिद्ध सीरियलाइज़र बनाए हैं, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>। MemoryPack की गति का कारण इसकी C#-विशिष्ट, C#-अनुकूलित बाइनरी फ़ॉर्मेट और मेरे पिछले अनुभव पर आधारित एक अच्छी तरह से ट्यून की गई इम्प्लीमेंटेशन है। यह पूरी तरह से नया डिज़ाइन है, जिसमें .NET 7 और C# 11 तथा Incremental Source Generator ( .NET Standard 2.1 (.NET 5, 6) और Unity के लिए भी सपोर्ट है) का उपयोग किया गया है।</p><p>अन्य सीरियलाइज़र कई एन्कोडिंग ऑपरेशन्स करते हैं जैसे VarInt एन्कोडिंग, टैग, स्ट्रिंग आदि। MemoryPack फॉर्मेट शून्य-एन्कोडिंग डिज़ाइन का उपयोग करता है जो संभवतः जितना अधिक C# मेमोरी हो सके, उसे कॉपी करता है। शून्य-एन्कोडिंग FlatBuffers के समान है, लेकिन इसके लिए विशेष प्रकार की आवश्यकता नहीं है, MemoryPack का सीरियलाइज़ेशन लक्ष्य POCO है।</p><p>प्रदर्शन के अलावा, MemoryPack में ये विशेषताएँ हैं:</p><ul><li>आधुनिक I/O APIs का समर्थन (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Native AOT फ्रेंडली Source Generator आधारित कोड जनरेशन, कोई डायनामिक CodeGen (IL.Emit) नहीं</li>
<li>Reflectionless non-generics APIs</li>
<li>मौजूदा इंस्टेंस में डीसिरियलाइज़ करें</li>
<li>पॉलिमॉर्फिज्म (Union) सीरियलाइज़ेशन</li>
<li>सीमित वर्शन-टोलरेंट (फास्ट/डिफ़ॉल्ट) और पूर्ण वर्शन-टोलरेंट सपोर्ट</li>
<li>Circular reference सीरियलाइज़ेशन</li>
<li>PipeWriter/Reader आधारित स्ट्रीमिंग सीरियलाइज़ेशन</li>
<li>TypeScript कोड जनरेशन और ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP सपोर्ट .NET Source Generator के माध्यम से</li></p><p></ul>इंस्टॉलेशन
<hr>
यह लाइब्रेरी NuGet के माध्यम से वितरित की जाती है। सर्वोत्तम प्रदर्शन के लिए, <code>.NET 7</code> का उपयोग करने की सिफारिश की जाती है। न्यूनतम आवश्यकता <code>.NET Standard 2.1</code> है।</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>साथ ही कोड एडिटर में Roslyn 4.3.1 सपोर्ट होना आवश्यक है, जैसे Visual Studio 2022 version 17.3, .NET SDK 6.0.401। विवरण के लिए, <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a> दस्तावेज़ देखें।</p><p>Unity के लिए, आवश्यकताएँ और इंस्टॉलेशन प्रक्रिया पूरी तरह से अलग है। विवरण के लिए <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a> अनुभाग देखें।</p><p>त्वरित प्रारंभ
<hr>
सीरियलाइज़ करने के लिए एक struct या class को परिभाषित करें और उसे <code>[MemoryPackable]</code> एट्रिब्यूट तथा <code>partial</code> कीवर्ड से सजाएँ।</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>सीरियलाइज़ेशन कोड C# सोर्स जनरेटर फीचर द्वारा जनरेट किया जाता है, जो <code>IMemoryPackable<T></code> इंटरफ़ेस को इम्प्लीमेंट करता है। Visual Studio में आप जेनरेटेड कोड को क्लास नाम पर <code>Ctrl+K, R</code> शॉर्टकट का उपयोग करके और <code>*.MemoryPackFormatter.g.cs</code> चुनकर देख सकते हैं।</p><p>किसी ऑब्जेक्ट इंस्टेंस को सीरियलाइज़/डीसीरियलाइज़ करने के लिए <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> कॉल करें।</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p><code>Serialize</code> मेथड <code>byte[]</code> रिटर्न टाइप को सपोर्ट करती है, साथ ही यह <code>IBufferWriter<byte></code> या <code>Stream</code> में भी सीरियलाइज़ कर सकती है। <code>Deserialize</code> मेथड <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> और <code>Stream</code> को सपोर्ट करती है। और नॉन-जनरिक वर्शन भी उपलब्ध हैं।</p><p>बिल्ट-इन सपोर्टेड टाइप्स
<hr>
ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ किए जा सकते हैं:</p><ul><li>.NET प्रिमिटिव्स (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, आदि)</li>
<li>Unmanaged टाइप्स (कोई भी <code>enum</code>, कोई भी यूज़र-डिफाइन्ड <code>struct</code> जिसमें रेफरेंस टाइप्स न हों)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Immutable collections (<code>ImmutableList<></code>, आदि) और इंटरफेसेस (<code>IImmutableList<></code>, आदि)</li></p><p></ul><code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code> को परिभाषित करें
<hr>
<code>[MemoryPackable]</code> को किसी भी <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> और <code>interface</code> पर लगाया जा सकता है। यदि कोई टाइप <code>struct</code> या <code>record struct</code> है जिसमें कोई रेफरेंस टाइप नहीं है (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>), तो कोई अतिरिक्त एट्रिब्यूट (ignore, include, constructor, callbacks) उपयोग नहीं होते, इसे सीधे मेमोरी से सीरियलाइज़/डीसीरियलाइज़ किया जाता है।</p><p>अन्यथा, डिफ़ॉल्ट रूप से, <code>[MemoryPackable]</code> पब्लिक इंस्टेंस प्रॉपर्टीज़ या फील्ड्स को सीरियलाइज़ करता है। आप <code>[MemoryPackIgnore]</code> का उपयोग करके किसी सीरियलाइज़ेशन टार्गेट को हटा सकते हैं, <code>[MemoryPackInclude]</code> किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ होते हैं
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ नहीं होते हैं
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // किसी पब्लिक सदस्य को टार्गेट से हटाने के लिए [MemoryPackIgnore] का उपयोग करें
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करने के लिए [MemoryPackInclude] का उपयोग करें
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p><code>MemoryPack</code> का कोड जनरेटर <code><remarks /></code> सेक्शन में यह जानकारी जोड़ता है कि कौन से सदस्य सीरियलाइज़ किए गए हैं। इसे टाइप पर Intellisense के साथ होवर करके देखा जा सकता है।</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>सभी सदस्यों का मेमोरीपैक-सीरियलाइज़ेबल होना आवश्यक है, यदि नहीं, तो कोड जनरेटर त्रुटि देगा।</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack में 35 डायग्नोस्टिक्स नियम हैं (<code>MEMPACK001</code> से <code>MEMPACK035</code>) ताकि डिफ़ाइन करना सरल हो।</p><p>यदि टार्गेट टाइप का MemoryPack सीरियलाइज़ेशन बाहरी रूप से डिफाइन किया गया है और रजिस्टर्ड है, तो डायग्नोस्टिक्स को साइलेंट करने के लिए <code>[MemoryPackAllowSerialize]</code> का उपयोग करें।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>सदस्यों का क्रम <strong>महत्वपूर्ण</strong> है, MemoryPack सदस्य-नाम या अन्य जानकारी को सीरियलाइज़ नहीं करता, बल्कि फील्ड्स को उनके डिक्लेरेशन क्रम में सीरियलाइज़ करता है। यदि टाइप इनहेरिटेड है, तो सीरियलाइज़ेशन माता-पिता → बच्चे के क्रम में किया जाता है। डीसिरियलाइज़ेशन के लिए सदस्यों का क्रम बदला नहीं जा सकता। स्कीमा इवोल्यूशन के लिए, <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a> अनुभाग देखें।</p><p>डिफ़ॉल्ट क्रम अनुक्रमिक है, लेकिन आप <code>[MemoryPackable(SerializeLayout.Explicit)]</code> और <code>[MemoryPackOrder()]</code> के साथ स्पष्ट लेआउट चुन सकते हैं।</p><pre><code class="language-csharp">// Prop0 -> Prop1 को सीरियलाइज़ करें
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>कन्स्ट्रक्टर चयन</h3></p><p>MemoryPack पैरामीटराइज्ड और पैरामीटरलेस दोनों कन्स्ट्रक्टर्स को सपोर्ट करता है। कन्स्ट्रक्टर का चयन ये नियम अपनाता है (क्लास और स्ट्रक्चर दोनों पर लागू):</p><ul><li>यदि <code>[MemoryPackConstructor]</code> है, तो उसी का उपयोग करें।</li>
<li>यदि कोई स्पष्ट कन्स्ट्रक्टर (प्राइवेट सहित) नहीं है, तो पैरामीटरलेस का उपयोग करें।</li>
<li>यदि एक ही पैरामीटरलेस/पैरामीटराइज्ड कन्स्ट्रक्टर (प्राइवेट सहित) है, तो उसी का उपयोग करें।</li>
<li>यदि एक से अधिक कन्स्ट्रक्टर हैं, तो वांछित कन्स्ट्रक्टर पर <code>[MemoryPackConstructor]</code> एट्रिब्यूट लगाया जाना चाहिए (जनरेटर अपने आप कोई नहीं चुनेगा), अन्यथा जनरेटर त्रुटि देगा।</li>
<li>यदि पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग करते हैं, तो सभी पैरामीटर नाम संबंधित सदस्य नामों से मेल खाने चाहिए (केस-इन्सेंसिटिव)।</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // आप पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग कर सकते हैं - पैरामीटर नाम संबंधित सदस्यों के नाम से मेल खाने चाहिए (केस-इन्सेंसिटिव)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// रिकॉर्ड प्राइमरी कन्स्ट्रक्टर भी सपोर्टेड है
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// यदि एक से अधिक कंस्ट्रक्टर हैं, तो [MemoryPackConstructor] का उपयोग किया जाना चाहिए
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>सीरियलाइज़ेशन कॉलबैक</h3></p><p>सीरियलाइज़/डिसीरियलाइज़ करते समय, MemoryPack <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> एट्रिब्यूट्स का उपयोग कर के पहले/बाद में इवेंट को इनवोक कर सकता है। यह दोनों static और instance (non-static) मेथड्स, और public तथा private मेथड्स पर एनोनेट किया जा सकता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // मेथड कॉल ऑर्डर है static -> instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // प्राइवेट मेथड भी अनुमति है
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // नोट: instance मेथड जिसमें MemoryPackOnDeserializing है, वह तब नहीं कॉल होता अगर instance <code>ref</code> से पास न हो
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>कॉलबैक बिना पैरामीटर वाले मेथड और <code>ref reader/writer, ref T value</code> मेथड की अनुमति देता है। उदाहरण के लिए, ref कॉलबैक सीरियलाइज़ेशन प्रोसेस से पहले कस्टम हेडर लिख/पढ़ सकते हैं।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, उपयोग करें where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // हेडर में GUID लिखें।
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // डिसीरियलाइज़ से पहले कस्टम हेडर पढ़ें
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>यदि <code>ref value</code> में कोई मान सेट किया जाए, तो आप सीरियलाइज़ेशन/डिसीरियलाइज़ेशन के लिए उपयोग किए गए मान को बदल सकते हैं। उदाहरण के लिए, ServiceProvider से इंस्टेंसिएट करें।</p><pre><code class="language-csharp">// इस फॉर्मेटर का उपयोग करने से पहले, ServiceProvider सेट करें
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>कस्टम कलेक्शन परिभाषित करें
<hr>
डिफ़ॉल्ट रूप से, एनोनेटेड <code>[MemoryPackObject]</code> टाइप अपने सदस्यों को सीरियलाइज़ करने की कोशिश करता है। हालांकि, यदि कोई टाइप कलेक्शन (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>) है, तो इसे सही तरीके से सीरियलाइज़ करने के लिए <code>GenerateType.Collection</code> का उपयोग करें।</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Static constructor
<hr>
MemoryPackable क्लास static constructor को परिभाषित नहीं कर सकती क्योंकि जेनेरेटेड partial class इसका उपयोग करती है। इसके बजाय, आप वही कार्य करने के लिए <code>static partial void StaticConstructor()</code> परिभाषित कर सकते हैं।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Polymorphism (Union)
<hr>
MemoryPack इंटरफेस और एब्सट्रैक्ट क्लास ऑब्जेक्ट्स को सीरियलाइज़ करने के लिए पोलीमॉर्फिज्म सीरियलाइज़ेशन का समर्थन करता है। MemoryPack में इस फीचर को Union कहा जाता है। केवल इंटरफेस और एब्सट्रैक्ट क्लासेज को <code>[MemoryPackUnion]</code> एट्रिब्यूट्स के साथ एनोनेट करने की अनुमति है। यूनिक यूनियन टैग्स आवश्यक हैं।</p><pre><code class="language-csharp">// [MemoryPackable] और इनहेरिटेंस टाइप्स को [MemoryPackUnion] से एनोनेट करें
// Union एब्सट्रैक्ट क्लास को भी सपोर्ट करता है
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// इंटरफेस टाइप के रूप में सीरियलाइज़ करें।
var bin = MemoryPackSerializer.Serialize(data);</p><p>// इंटरफेस टाइप के रूप में डिसीरियलाइज़ करें।
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> की अनुमति <code>0</code> ~ <code>65535</code> तक है, यह विशेष रूप से <code>250</code> से कम के लिए कुशल है।
<pre><code class="language-">यदि कोई इंटरफ़ेस और डेराइव्ड टाइप्स अलग-अलग असेंबली में हैं, तो आप इसके बजाय <code>MemoryPackUnionFormatterAttribute</code> का उपयोग कर सकते हैं। फॉर्मेटर्स इस प्रकार जनरेट किए जाते हैं कि वे स्वचालित रूप से C# 9.0 और उसके ऊपर में <code>ModuleInitializer</code> के माध्यम से रजिस्टर हो जाते हैं।</p><blockquote>ध्यान दें कि <code>ModuleInitializer</code> यूनिटी में समर्थित नहीं है, इसलिए फॉर्मेटर को मैन्युअली रजिस्टर करना होगा। अपने यूनियन फॉर्मेटर को रजिस्टर करने के लिए स्टार्टअप में <code>{name of your union formatter}Initializer.RegisterFormatter()</code> मैन्युअली कॉल करें। उदाहरण के लिए <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>।</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB में टारगेट टाइप के बाहर डिफिनिशन डिफाइन करें
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
यूनियन को कोड में <code>DynamicUnionFormatter<T></code> के माध्यम से असेंबल किया जा सकता है।
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
Serialize API
<hr>
<code>Serialize</code> के तीन ओवरलोड्स हैं।
</code></pre>csharp
// नॉन-जेनरिक API भी उपलब्ध है, इन वर्शन में पहला आर्ग्युमेंट टाइप होता है और वैल्यू ऑब्जेक्ट?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
परफॉर्मेंस के लिए, अनुशंसित API <code>BufferWriter</code> का उपयोग करता है। यह सीधे बफर में सीरियलाइज़ करता है। इसे <code>System.IO.Pipelines</code> के <code>PipeWriter</code>, ASP .NET Core के <code>BodyWriter</code> आदि पर लागू किया जा सकता है।</p><p>यदि <code>byte[]</code> आवश्यक है (जैसे <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a> में <code>RedisValue</code>), तो रिटर्निंग <code>byte[]</code> API सरल और लगभग उतना ही तेज़ है।</p><p>ध्यान दें कि <code>Stream</code> के लिए <code>SerializeAsync</code> केवल Flush के लिए असिंक्रोनस है; यह सब कुछ एक बार MemoryPack के इंटरनल पूल बफर में सीरियलाइज़ करता है और फिर <code>WriteAsync</code> का उपयोग करता है। इसलिए, <code>BufferWriter</code> ओवरलोड, जो बफर और फ्लश को अलग और नियंत्रित करता है, बेहतर है।</p><p>यदि आप पूरी तरह से स्ट्रीमिंग राइट करना चाहते हैं, तो <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a> सेक्शन देखें।</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> यह कॉन्फ़िगर करता है कि स्ट्रिंग्स को UTF16 या UTF8 के रूप में सीरियलाइज़ किया जाए। इसे UTF8 एन्कोडिंग के लिए <code>MemoryPackSerializerOptions.Utf8</code>, UTF16 के लिए <code>MemoryPackSerializerOptions.Utf16</code> या डिफ़ॉल्ट के लिए <code>MemoryPackSerializerOptions.Default</code> (जो डिफ़ॉल्ट रूप से UTF8 है) पास करके सेट किया जा सकता है। null पास करने या डिफ़ॉल्ट पैरामीटर का उपयोग करने पर UTF8 एन्कोडिंग होती है।</p><p>चूंकि C# की इंटरनल स्ट्रिंग रिप्रेजेंटेशन UTF16 है, इसलिए UTF16 परफॉर्मेंस में बेहतर है। हालांकि, पेलोड आमतौर पर बड़ा होता है; UTF8 में एक ASCII स्ट्रिंग एक बाइट है, जबकि UTF16 में दो बाइट होती है। इस पेलोड के साइज में बड़ा अंतर होने के कारण, डिफ़ॉल्ट रूप से UTF8 सेट किया गया है।</p><p>यदि डेटा नॉन-ASCII है (जैसे जापानी, जो 3 से अधिक बाइट हो सकता है, और UTF8 में बड़ा होता है), या यदि आपको इसे अलग से कंप्रेस करना है, तो UTF16 बेहतर परिणाम दे सकता है।</p><p>सीरियलाइज़ेशन के दौरान आप UTF8 या UTF16 चुन सकते हैं, लेकिन डीसिरियलाइज़ेशन के दौरान इसे स्पेसिफाई करना आवश्यक नहीं है। यह स्वचालित रूप से डिटेक्ट और सामान्य रूप से डीसिरियलाइज़ हो जाएगा।</p><p>इसके अलावा, आप ऑप्शंस से <code>IServiceProvider? ServiceProvider { get; init; }</code> प्राप्त/सेट कर सकते हैं। यह सीरियलाइज़ेशन प्रोसेस से DI ऑब्जेक्ट (जैसे <code>ILogger<T></code>) प्राप्त करने में उपयोगी है (<code>MemoryPackReader/MemoryPackWriter</code> में .Options प्रॉपर्टी है)।</p><p>Deserialize API
<hr>
<code>Deserialize</code> में <code>ReadOnlySpan<byte></code> और <code>ReadOnlySequence<byte></code>, <code>Stream</code> ओवरलोड और <code>ref</code> सपोर्ट है।
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
<code>ref</code> ओवरलोड मौजूदा इंस्टेंस को ओवरराइट करता है, विवरण के लिए <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a> सेक्शन देखें।</p><p><code>DeserializeAsync(Stream)</code> पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन नहीं है, पहले यह MemoryPack के इंटरनल पूल में एंड-ऑफ-स्ट्रीम तक पढ़ता है, फिर डीसिरियलाइज़ करता है।</p><p>यदि आप पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन करना चाहते हैं, तो <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a> सेक्शन देखें।</p><p>Overwrite
<hr>
अलोकेशन्स को कम करने के लिए, MemoryPack मौजूदा इंस्टेंस में डीसिरियलाइज़ करके उसे ओवरराइट करने को सपोर्ट करता है। इसे <code>Deserialize(ref T? value)</code> ओवरलोड के साथ उपयोग किया जा सकता है।
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// मौजूदा इंस्टेंस में डेटा ओवरराइट करें।
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack जितना संभव हो उतना ओवरराइट करने का प्रयास करेगा, लेकिन यदि निम्नलिखित कंडीशंस मेल नहीं खातीं, तो यह नया इंस्टेंस बनाएगा (सामान्य डीसिरियलाइज़ेशन की तरह)।</p><ul><li>ref value (ऑब्जेक्ट ग्राफ में मेंबर्स सहित) null है, नया इंस्टेंस सेट करें</li>
<li>केवल पैरामीटरलेस कंस्ट्रक्टर की अनुमति है, यदि पैरामीटराइज्ड कंस्ट्रक्टर का उपयोग किया गया है, तो नया इंस्टेंस बनाएं</li>
<li>यदि value <code>T[]</code> है, तो केवल तभी री-यूज़ करें जब लेंथ समान हो, अन्यथा नया इंस्टेंस बनाएं</li>
<li>यदि value ऐसी कलेक्शन है जिसमें <code>.Clear()</code> मेथड है (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) तो Clear() कॉल करें और री-यूज़ करें, अन्यथा नया इंस्टेंस बनाएं</li></p><p></ul>Version tolerant
<hr>
डिफ़ॉल्ट में (<code>GenerateType.Object</code>), MemoryPack सीमित स्कीमा इवोल्यूशन को सपोर्ट करता है।</p><ul><li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>मेंबर्स जोड़े जा सकते हैं, लेकिन हटाए नहीं जा सकते</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Add करना ठीक है।
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Remove करना NG (नॉट गुड) है।
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// ऑर्डर बदलना NG (नॉट गुड) है।
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
उपयोग में, पुराना डेटा (फाइल में, रेडिस में आदि) स्टोर करें और नए स्कीमा में पढ़ना हमेशा ठीक है। RPC परिदृश्य में, स्कीमा क्लाइंट और सर्वर दोनों साइड पर मौजूद होता है, क्लाइंट को सर्वर से पहले अपडेट करना चाहिए। अपडेटेड क्लाइंट को पुराने सर्वर से कनेक्ट करने में कोई समस्या नहीं है, लेकिन पुराना क्लाइंट नए सर्वर से कनेक्ट नहीं कर सकता।</p><p>डिफ़ॉल्ट रूप से, जब पुराना डेटा नए स्कीमा में पढ़ा जाता है, तो डेटा साइड पर मौजूद न होने वाले सभी मेंबर्स को <code>default</code> लिटरल से इनिशियलाइज़ किया जाता है।
यदि आप इससे बचना चाहते हैं और फील्ड/प्रॉपर्टीज के इनिशियल वैल्यू का उपयोग करना चाहते हैं, तो आप <code>[SuppressDefaultInitialization]</code> का उपयोग कर सकते हैं।
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < अगर पुराना डेटा मिसिंग है तो <code>111</code> सेट करें।
    
    public int Prop3 { get; set; } = 222; // < अगर पुराना डेटा मिसिंग है तो <code>default</code> सेट करें।
}
<pre><code class="language-">
<code>[SuppressDefaultInitialization]</code> की निम्नलिखित सीमाएँ हैं:
<ul><li>इसे readonly, init-only, और required मोडिफायर के साथ उपयोग नहीं किया जा सकता।</li></p><p></ul>अगला <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> सेक्शन दिखाता है कि स्कीमा बदलावों की जांच कैसे करें, जैसे CI के द्वारा, दुर्घटनाओं को रोकने के लिए।</p><p>जब <code>GenerateType.VersionTolerant</code> का उपयोग करते हैं, तो यह पूर्ण वर्शन-टॉलरेंट को सपोर्ट करता है।</p><ul><li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>सभी मेंबर्स को स्पष्ट रूप से <code>[MemoryPackOrder]</code> जोड़ना आवश्यक है (सिवाय <code>SerializeLayout.Sequential</code> के)</li>
<li>मेंबर्स जोड़े जा सकते हैं, हटाए जा सकते हैं लेकिन ऑर्डर को री-यूज़ नहीं किया जा सकता (मिसिंग ऑर्डर का उपयोग कर सकते हैं)</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul></code></pre>csharp
// दोनों को serialize/deserialize करना ठीक है 
// VersionTolerantObject1 -> VersionTolerantObject2 और 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// हटाया गया
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// जोड़ा गया
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// यदि SerializeLayout.Sequential को स्पष्ट रूप से सेट किया गया है, तो स्वतः क्रम की अनुमति देता है।
// लेकिन यह वर्शन-टॉलरेंट के लिए कोई सदस्य हटाने की अनुमति नहीं देता।
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> को serialize करने में <code>GenerateType.Object</code> की तुलना में धीमा है। साथ ही, पेलोड का आकार थोड़ा बड़ा होगा।</p><p>Serialization जानकारी
----
आप यह देख सकते हैं कि किस प्रकार के कौन से सदस्य serialize हो रहे हैं, इसके लिए IntelliSense में चेक करें। एक विकल्प है कि इस जानकारी को compile समय पर एक फ़ाइल में लिखा जाए। <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> को निम्न प्रकार से सेट करें।</p><pre><code class="language-xml"><!-- memorypack serialization info को directory में आउटपुट करें -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>निम्न जानकारी फ़ाइल में लिखी जाती है।</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>यदि प्रकार unmanaged है, तो type नाम से पहले <code>unmanaged</code> दिखाया जाता है।</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>इस फ़ाइल में अंतर की जाँच करके, खतरनाक schema बदलाव को रोका जा सकता है। उदाहरण के लिए, आप निम्न नियमों का पता लगाने के लिए CI का उपयोग कर सकते हैं</p><ul><li>unmanaged type को बदलना</li>
<li>सदस्य के क्रम में परिवर्तन</li>
<li>सदस्य को हटाना</li></p><p></ul>Circular Reference
<hr>
MemoryPack सर्कुलर रेफरेंस को भी सपोर्ट करता है। इससे ट्री ऑब्जेक्ट्स को जैसा है वैसा serialize किया जा सकता है।</p><pre><code class="language-csharp">// सर्कुलर-रेफरेंस सक्षम करने के लिए, GenerateType.CircularReference का उपयोग करें
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p> उदाहरण के लिए, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> कोड यहां जैसा होगा।</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> में version-tolerant के समान विशेषताएँ हैं। हालांकि, एक अतिरिक्त बाध्यता के रूप में, केवल parameterless constructors की अनुमति है। साथ ही, object reference tracking केवल उन्हीं objects के लिए किया जाता है जिन्हें <code>GenerateType.CircularReference</code> के साथ चिह्नित किया गया है। यदि आप किसी अन्य object को ट्रैक करना चाहते हैं, तो उसे wrap करें।</p><p>CustomFormatter
<hr>
यदि आप <code>MemoryPackCustomFormatterAttribute<T></code> या <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (अधिक performant, लेकिन जटिल) को implement करते हैं, तो आप MemoryPackObject के सदस्य के लिए custom formatter का उपयोग configure कर सकते हैं।</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack निम्नलिखित formatting attributes प्रदान करता है: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // इस सदस्य को UTF16 String के रूप में serialize करें, यह UTF8 की तुलना में बेहतर performance देता है लेकिन ASCII में, आकार बड़ा होता है (लेकिन non ASCII में कभी-कभी छोटा भी हो सकता है)।
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // deserialize में, Dictionary को StringComparer.OrdinalIgnoreCase के साथ initialize किया जाता है।
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // deserialize समय, सभी string को intern किया जाता है (देखें: String.Intern)। यदि समान मान बार-बार आते हैं, तो यह memory बचाता है।
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>Set/dictionary के equality comparer को configure करने के लिए, सभी built-in formatter में एक comparer constructor overload होता है। आप आसानी से custom equality-comparer formatter बना सकते हैं।</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> केवल <code>bool[]</code> प्रकार को compress करता है। <code>bool[]</code> आमतौर पर प्रत्येक boolean मान के लिए 1 बाइट के रूप में serialize होता है, लेकिन <code>BitPackFormatter</code> <code>bool[]</code> को एक <code>BitArray</code> की तरह serialize करता है, जिसमें प्रत्येक bool को 1 बिट के रूप में संग्रहित किया जाता है। <code>BitPackFormatter</code> का उपयोग करने पर, 8 bools = 1 बाइट, जबकि सामान्यतः 8 बाइट होते, जिससे आकार 8 गुना कम हो जाता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> <code>byte[]</code> के लिए है, उदाहरण के लिए आप Brotli द्वारा बड़े payload को compress कर सकते हैं।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> <code>string</code> के लिए है, Brotli द्वारा compressed string (UTF16) को serialize करता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre>
<code>BrotliFormatter<T></code> किसी भी प्रकार के लिए है, ब्रोटली द्वारा संपीड़ित सीरियलाइज़्ड डेटा के लिए। यदि प्रकार <code>byte[]</code> या <code>string</code> है, तो प्रदर्शन के लिए आपको <code>BrotliFormatter</code> या <code>BrotliStringFormatter</code> का उपयोग करना चाहिए।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}</code></pre></p><p>एरे पूलिंग को डिसीरियलाइज़ करना
<hr>
किसी बड़े एरे (किसी भी <code>T</code>) को डिसीरियलाइज़ करने के लिए, MemoryPack कई कुशल पूलिंग विधियाँ प्रदान करता है। सबसे प्रभावी तरीका है <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a> फ़ंक्शन का उपयोग करना। विशेष रूप से <code>List<T></code> हमेशा पुन: उपयोग होती है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> पुन: उपयोग होती है, डिसीरियलाइज़ में कोई आवंटन नहीं।
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// कुशल संचालन के लिए, आप CollectionsMarshal द्वारा Span<T> प्राप्त कर सकते हैं
var span = CollectionsMarshal.AsSpan(value.Payload);</code></pre></p><p>एक सुविधाजनक तरीका है डिसीरियलाइज़ के समय ArrayPool में डिसीरियलाइज़ करना। MemoryPack <code>MemoryPoolFormatter<T></code> और <code>ReadOnlyMemoryPoolFormatter<T></code> प्रदान करता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // आपको return कोड स्वयं लिखना होगा, यहाँ स्निपेट है।</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // कुछ भी करें...
}   // ArrayPool में वापस करें</code></pre></p><p>प्रदर्शन
<hr>
मेरा ब्लॉग पोस्ट देखें <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>पेलोड आकार और संपीड़न
<hr>
पेलोड आकार लक्ष्य मान पर निर्भर करता है; JSON के विपरीत, इसमें कोई कुंजी नहीं होती और यह एक बाइनरी फॉर्मेट है, इसलिए पेलोड आकार JSON से छोटा होने की संभावना है।</p><p>उनके लिए जिनमें varint एन्कोडिंग है, जैसे MessagePack और Protobuf, यदि बहुत अधिक int का उपयोग किया गया हो तो MemoryPack बड़ा हो सकता है (MemoryPack में, int हमेशा 4 बाइट होते हैं फिक्स्ड साइज एन्कोडिंग के कारण, जबकि MessagePack में 1~5 बाइट होते हैं)।</p><p>float और double MemoryPack में 4 बाइट और 8 बाइट हैं, लेकिन MessagePack में 5 बाइट और 9 बाइट हैं। तो उदाहरण के लिए, Vector3 (float, float, float) एरे के लिए MemoryPack छोटा होता है।</p><p>String डिफ़ॉल्ट रूप से UTF8 है, जो अन्य सीरियलाइज़र्स के समान है, लेकिन यदि UTF16 विकल्प चुना जाता है, तो यह अलग प्रकार का होगा।</p><p>किसी भी स्थिति में, यदि पेलोड आकार बड़ा है, तो संपीड़न पर विचार किया जाना चाहिए। LZ4, ZStandard और Brotli अनुशंसित हैं।</p><h3>संपीड़न</h3></p><p>MemoryPack <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> संपीड़न के लिए <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> और <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a> के माध्यम से एक कुशल हेल्पर प्रदान करता है। MemoryPack के <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> MemoryPack के आंतरिक व्यवहार के लिए अनुकूलित संपीड़न/डिसम्प्रेशन प्रदान करते हैं।</p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Compression(आवश्यक using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// संपीड़ित byte[] प्राप्त करें
var compressedBytes = compressor.ToArray();</p><p>// या अन्य IBufferWriter<byte> में लिखें (जैसे PipeWriter)
compressor.CopyTo(response.BodyWriter);</code></pre></p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Decompression(आवश्यक using)
using var decompressor = new BrotliDecompressor();</p><p>// ReadOnlySpan<byte> या ReadOnlySequence<byte> से डिसम्प्रेस्ड ReadOnlySequence<byte> प्राप्त करें
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);</code></pre></p><p>दोनों <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> struct हैं, यह heap पर मेमोरी आवंटित नहीं करते। दोनों Serialize/Deserialize के लिए डेटा को एक आंतरिक मेमोरी पूल में संग्रहित करते हैं। इसलिए, मेमोरी पूलिंग को रिलीज़ करना आवश्यक है, <code>using</code> का उपयोग करना न भूलें।</p><p>संपीड़न स्तर बहुत महत्वपूर्ण है। डिफ़ॉल्ट रूप से quality-1 (CompressionLevel.Fastest) सेट किया गया है, जो .NET डिफ़ॉल्ट (CompressionLevel.Optimal, quality-4) से अलग है।</p><p>Fastest (quality-1) की गति <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a> के करीब होगी, लेकिन 4 बहुत धीमा है। यह सीरियलाइज़र उपयोग परिदृश्य में महत्वपूर्ण पाया गया। मानक <code>BrotliStream</code> का उपयोग करते समय सावधान रहें (डिफ़ॉल्ट quality-4 है)। किसी भी स्थिति में, संपीड़न/डिसम्प्रेशन की गति और आकार अलग-अलग डेटा के लिए बहुत भिन्न होंगे। कृपया अपने एप्लिकेशन द्वारा उपयोग किए जाने वाले डेटा के साथ स्वयं परीक्षण करें।</p><p>ध्यान दें कि MemoryPack के असंपीड़ित और Brotli के संपीड़न के बीच कई गुना गति दंड है।</p><p>Brotli कस्टम फ़ॉर्मेटर में भी समर्थित है। <code>BrotliFormatter</code> किसी विशिष्ट सदस्य को संपीड़ित कर सकता है।</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p>बाहरी प्रकारों को सीरियलाइज़ करें
<hr>
यदि आप बाहरी प्रकारों को सीरियलाइज़ करना चाहते हैं, तो आप एक कस्टम फ़ॉर्मेटर बना सकते हैं और उसे प्रोवाइडर में रजिस्टर कर सकते हैं, विवरण के लिए देखें <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a>। हालांकि, एक कस्टम फ़ॉर्मेटर बनाना कठिन है। इसलिए, हम एक रैपर टाइप बनाने की सलाह देते हैं। उदाहरण के लिए, यदि आप <code>AnimationCurve</code> नामक बाहरी प्रकार को सीरियलाइज़ करना चाहते हैं।</p><pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}</code></pre></p><p>रैप करने के लिए प्रकार सार्वजनिक है, लेकिन सीरियलाइज़ेशन से बाहर रखा गया है (<code>MemoryPackIgnore</code>)। जिन गुणों को आप सीरियलाइज़ करना चाहते हैं वे निजी हैं, लेकिन शामिल किए गए हैं (<code>MemoryPackInclude</code>)। दो प्रकार के कन्स्ट्रक्टर भी तैयार किए जाने चाहिए। सीरियलाइज़र द्वारा उपयोग किया जाने वाला कन्स्ट्रक्टर निजी होना चाहिए।</p><p>जैसा है, इसे हर बार रैप करना होगा, जो असुविधाजनक है। और साथ ही struct wrapper null को निरूपित नहीं कर सकता। तो आइए एक कस्टम फ़ॉर्मेटर बनाते हैं।</p><pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity scoped और TBufferWriter को सपोर्ट नहीं करता, इसलिए signature बदलें <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)</code></pre>csharp
{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // null ब्लॉक को छोड़ें
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
<pre><code class="language-">
अंत में, स्टार्टअप में फॉर्मेटर को रजिस्टर करें।
</code></pre>csharp
MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());
<pre><code class="language-">> नोट: Unity की AnimationCurve डिफ़ॉल्ट रूप से सीरियलाइज़ेबल है इसलिए AnimationCurve के लिए इस कस्टम फॉर्मेटर की आवश्यकता नहीं है।</p><p>Packages
<hr>
MemoryPack के ये पैकेज हैं।</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> मुख्य लाइब्रेरी है, यह बाइनरी ऑब्जेक्ट्स के हाई परफॉर्मेंस सीरियलाइज़ेशन और डीसीरियलाइज़ेशन के लिए पूरी सपोर्ट प्रदान करता है। यह <code>MemoryPack.Core</code> पर बेस लाइब्रेरीज़ के लिए और <code>MemoryPack.Generator</code> पर कोड जेनरेशन के लिए निर्भर करता है। <code>MemoryPack.Streaming</code> <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a> के लिए अतिरिक्त एक्सटेंशन जोड़ता है।  <code>MemoryPack.AspNetCoreMvcFormatter</code> ASP.NET Core के लिए इनपुट/आउटपुट फॉर्मेटर्स जोड़ता है। <code>MemoryPack.UnityShims</code> .NET और Unity के बीच साझा किए जाने वाले टाइप्स के लिए Unity शिम टाइप्स और फॉर्मेटर्स जोड़ता है।</p><p>TypeScript और ASP.NET Core Formatter
<hr>
MemoryPack TypeScript कोड जेनरेशन सपोर्ट करता है। यह C# से क्लास और सीरियलाइज़ेशन कोड जेनरेट करता है, दूसरे शब्दों में, आप OpenAPI, proto, आदि का उपयोग किए बिना ब्राउज़र के साथ टाइप्स साझा कर सकते हैं।</p><p>कोड जेनरेशन Source Generator के साथ इंटीग्रेटेड है, निम्नलिखित विकल्प (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) TypeScript कोड के लिए आउटपुट डायरेक्टरी सेट करते हैं। रनटाइम कोड भी एक ही समय पर आउटपुट होता है, इसलिए कोई अतिरिक्त डिपेंडेंसी आवश्यक नहीं है।
</code></pre>xml
<!-- मेमोरीपैक TypeScript कोड को डायरेक्टरी में आउटपुट करें -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
एक C# MemoryPackable टाइप को <code>[GenerateTypeScript]</code> के साथ एनोटेट किया जाना चाहिए।
</code></pre>csharp
[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}
<pre><code class="language-">
रनटाइम कोड और TypeScript टाइप लक्ष्य डायरेक्टरी में जेनरेट हो जाएंगे।</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>जेनरेट किया गया कोड निम्नानुसार है, जिसमें सरल फील्ड्स और serialize/serializeArray व deserialize/deserializeArray के लिए स्टैटिक मेथड्स होते हैं।
</code></pre>typescript
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
<pre><code class="language-">
आप इस टाइप का उपयोग निम्नानुसार कर सकते हैं।
</code></pre>typescript
let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// Uint8Array में सीरियलाइज़ करें
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// ArrayBuffer से डीसीरियलाइज़ करें 
let person2 = Person.deserialize(buffer);
<pre><code class="language-">
<code>MemoryPack.AspNetCoreMvcFormatter</code> पैकेज ASP.NET Core MVC के लिए <code>MemoryPack</code> इनपुट और आउटपुट फॉर्मेटर जोड़ता है। आप निम्नलिखित कोड के साथ ASP.NET Core MVC में <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> जोड़ सकते हैं।
</code></pre>csharp
var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // यदि checkContentType: true है तो मल्टीपल फॉर्मेट (JSON/MemoryPack, आदि) आउटपुट कर सकते हैं। डिफ़ॉल्ट false है।
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
<pre><code class="language-">
यदि आप HttpClient से कॉल करते हैं, तो आप कंटेंट-हेडर में <code>application/x-memorypack</code> सेट कर सकते हैं।
</code></pre>csharp
var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");
<pre><code class="language-">
<h3>TypeScript टाइप मैपिंग</h3></p><p>उन टाइप्स पर कुछ प्रतिबंध हैं जिन्हें जेनरेट किया जा सकता है। प्रिमिटिव्स में, <code>char</code> और <code>decimal</code> समर्थित नहीं हैं। इसके अलावा, OpenGenerics टाइप का उपयोग नहीं किया जा सकता।</p><p>|  C#  |  TypeScript  | विवरण |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</code></pre>
| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | TypeScript में string के रूप में प्रस्तुत किया जाता है, लेकिन 16 बाइट बाइनरी के रूप में serialize/deserialize होता है
| <code>DateTime</code> | <code>Date</code> | DateTimeKind को अनदेखा किया जाएगा
| <code>enum</code> | <code>const enum</code> | <code>long</code> और <code>ulong</code> आधारभूत प्रकार समर्थित नहीं हैं
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | सभी <code>ICollection<T></code> लागू प्रकार जैसे <code>List<T></code> को समर्थन करता है
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | सभी <code>ISet<T></code> लागू प्रकार जैसे <code>HashSet<T></code> को समर्थन करता है
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | सभी <code>IDictionary<K,V></code> लागू प्रकार जैसे <code>Dictionary<K,V></code> को समर्थन करता है।
| <code>[MemoryPackable]</code> | <code>class</code> | केवल class को समर्थन करता है
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> केवल classes पर लागू किया जा सकता है और वर्तमान में struct द्वारा समर्थित नहीं है।</p><h3>इम्पोर्ट फाइल एक्सटेंशन और सदस्य नाम केसिंग कॉन्फ़िगर करें</h3></p><p>डिफ़ॉल्ट रूप में, MemoryPack फाइल एक्सटेंशन को <code>.js</code> के रूप में जेनरेट करता है जैसे कि <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>। यदि आप कोई अन्य एक्सटेंशन या खाली रखना चाहते हैं, तो इसे कॉन्फ़िगर करने के लिए <code>MemoryPackGenerator_TypeScriptImportExtension</code> का उपयोग करें।
साथ ही सदस्य नाम अपने आप camelCase में बदल जाता है। यदि आप मूल नाम का उपयोग करना चाहते हैं, तो <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> को <code>false</code> पर सेट करें।</p><pre><code class="language-xml"><ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- खाली रखना संभव है -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- डिफ़ॉल्ट true है -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- डिफ़ॉल्ट false है -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup></code></pre></p><p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> C# nullable एनोटेशन को TypeScript कोड में प्रतिबिंबित करने की अनुमति देता है। डिफ़ॉल्ट रूप से false है, जिससे सब कुछ nullable बन जाता है।</p><p>Streaming Serialization
<hr>
<code>MemoryPack.Streaming</code> <code>MemoryPackStreamingSerializer</code> प्रदान करता है, जो streams के साथ collections को serialize और deserialize करने के लिए अतिरिक्त समर्थन जोड़ता है।</p><pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}</code></pre></p><p>Formatter/Provider API
<hr>
यदि आप formatter को मैन्युअली लागू करना चाहते हैं, तो <code>MemoryPackFormatter<T></code> से इनहेरिट करें और <code>Serialize</code> और <code>Deserialize</code> मेथड्स को override करें।</p><pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // writer मेथड का उपयोग करें।
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // reader मेथड का उपयोग करें।
    }
}</code></pre>
बनाए गए formatter को <code>MemoryPackFormatterProvider</code> के साथ रजिस्टर किया जाता है।</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());</code></pre></p><p>नोट: <code>unmanged struct</code> (जिसमें कोई reference types नहीं हैं) कस्टम formatter का उपयोग नहीं कर सकते, यह हमेशा native memory layout को serialize करता है।</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
<code>MemoryPackWriter</code>/<code>MemoryPackReader</code> को इनिशियलाइज़ करने के लिए OptionalState की आवश्यकता होती है। यह <code>MemoryPackSerializerOptions</code> का wrapper है, जिसे <code>MemoryPackWriterOptionalStatePool</code> से बनाया जा सकता है।</p><pre><code class="language-csharp">// जब dispose किया जाएगा, OptionalState pool में वापस चला जाएगा।
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// Reader के लिए
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}</code></pre></p><p>Target framework dependency
<hr>
MemoryPack <code>netstandard2.1</code> और <code>net7.0</code> प्रदान करता है, लेकिन दोनों संगत नहीं हैं। उदाहरण के लिए, यदि आप <code>netstandard2.1</code> प्रोजेक्ट के तहत MemoryPackable types का उपयोग करते हैं और उसे <code>net7.0</code> प्रोजेक्ट से उपयोग करते हैं, तो रनटाइम exception मिलेगा, जैसे:</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>चूंकि net7.0 static abstract members (<code>Virtual static method</code>) का उपयोग करता है, जो netstandard2.1 में समर्थित नहीं है, यह व्यवहार एक विशेषता है।</p><p>.NET 7 प्रोजेक्ट को netstandard 2.1 dll का उपयोग नहीं करना चाहिए। दूसरे शब्दों में, यदि एप्लिकेशन .NET 7 प्रोजेक्ट है, तो सभी dependencies जिन्हें MemoryPack का उपयोग करना है, उन्हें .NET 7 को समर्थन करना चाहिए। इसलिए यदि किसी लाइब्रेरी डेवलपर की dependency MemoryPack पर है, तो आपको dual target framework कॉन्फ़िगर करना होगा।</p><pre><code class="language-xml"><TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks></code></pre></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> एक code-first grpc-dotnet framework है, जो protobuf के बजाय MessagePack का उपयोग करता है। MagicOnion अब MemoryPack को serialization layer के रूप में <code>MagicOnion.Serialization.MemoryPack</code> पैकेज (preview) के माध्यम से समर्थन करता है। विवरण देखें: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>न्यूनतम समर्थित Unity संस्करण <code>2022.3.12f1</code> है।</p><p><code>MemoryPack</code> कोर पैकेज nuget द्वारा प्रदान किया गया है। यह Unity में भी उपलब्ध है। यदि आप Unity बिल्ट-इन टाइप समर्थन प्राप्त करना चाहते हैं, तो हम अतिरिक्त रूप से MemoryPack.Unity एक्सटेंशन प्रदान करते हैं।</p><ul><li><a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a> का उपयोग कर NuGet से <code>MemoryPack</code> इंस्टॉल करें</li></p><p><li>NuGet -> Manage NuGet Packages विंडो खोलें, "MemoryPack" सर्च करें और Install दबाएं।</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>यदि आपको version conflicts error मिलता है, तो कृपया Player Settings (Edit -> Project Settings -> Player -> नीचे स्क्रॉल करें और "Other Settings" को विस्तार करें, फिर "Configuration" सेक्शन के तहत "Assembly Version Validation" को अनचेक करें) में version validation को disable करें।</li></p><p><li>git URL का संदर्भ देकर <code>MemoryPack.Unity</code> पैकेज इंस्टॉल करें</li></p><p><li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack <em>.</em>.* रिलीज़ टैग का उपयोग करता है, इसलिए आप एक version जैसे #1.0.0 निर्दिष्ट कर सकते हैं। उदाहरण: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p><p>
.NET संस्करण की तरह, कोड जेनरेशन एक कोड जनरेटर (<code>MemoryPack.Generator.dll</code>) द्वारा होती है। Reflection-free implementation IL2CPP में भी बेहतरीन प्रदर्शन प्रदान करता है।</p><p>Unity और Source Generator के बारे में अधिक जानकारी के लिए, कृपया <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">Unity documentation</a> देखें।</p><p>Source Generator का आधिकारिक रूप से Unity द्वारा <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> और <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a> में भी उपयोग होता है। दूसरे शब्दों में, यह अगली पीढ़ी के Unity में कोड जेनरेशन का मानक है।</p><p>आप सभी unmanaged types (जैसे कि <code>Vector3</code>, <code>Rect</code>, आदि...) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) को serialize कर सकते हैं। यदि आप अन्य Unity-विशिष्ट प्रकार serialize करना चाहते हैं, तो <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a> अनुभाग देखें।</p><p>Unity में प्रदर्शन के मामले में, MemoryPack JsonUtility से x3~x10 गुना तेज है।</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>यदि साझा कोड में Unity का type (<code>Vector2</code>, आदि...) है, तो MemoryPack NuGet में <code>MemoryPack.UnityShims</code> पैकेज प्रदान करता है।</p><p><code>MemoryPack.UnityShims</code> पैकेज Unity के मानक structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) के लिए shims प्रदान करता है।</p><blockquote>[!WARNING]</blockquote>
<blockquote>वर्तमान में, Unity में उपयोग के लिए निम्नलिखित सीमाएँ हैं</blockquote></p><ul><li>Unity संस्करण CustomFormatter को समर्थन नहीं करता।</li>
<li>यदि आप .NET7 या बाद के संस्करण का उपयोग कर रहे हैं, तो MemoryPack बाइनरी फॉर्मेट Unity के साथ पूरी तरह संगत नहीं है।</li>
    <li>यह समस्या उन value types के साथ होती है, जिनमें <code>[StructLayout(LayoutKind.Auto)]</code> स्पष्ट रूप से निर्दिष्ट है। (struct का डिफ़ॉल्ट <code>LayoutKind.Sequencil</code> होता है।) ऐसे types के लिए, .NET में serialize किया गया binary, Untiy में deserialize नहीं किया जा सकता। इसी तरह, Unity में serialize किया गया binary .NET साइड में serialize नहीं किया जा सकता।</li>
    <li>प्रभावित types में आमतौर पर निम्नलिखित प्रकार शामिल हैं।</li>
        <li><code>DateTimeOffset</code></li>
        <li><code>ValueTuple</code></li>
    <li>वर्तमान में, आसान समाधान यह है कि इन types का उपयोग न करें।</li></p><p>
</ul>Native AOT
<hr>
दुर्भाग्यवश, .NET 7 Native AOT में एक रनटाइम बग के कारण MemoryPack का उपयोग करते समय crash (<code>Generic virtual method pointer lookup failure</code>) होता है। यह .NET 8 में ठीक किया जाएगा। <code>Microsoft.DotNet.ILCompiler</code> के preview संस्करण का उपयोग करने से .NET 7 में इसे ठीक किया जा सकता है। कृपया <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">issue's comment</a> देखें कि इसे कैसे सेटअप करें।</p><p>Binary wire format specification
<hr>
<code>Serialize<T></code> और <code>Deserialize<T></code> में परिभाषित <code>T</code> प्रकार को C# schema कहा जाता है। MemoryPack फॉर्मेट self-described फॉर्मेट नहीं है। Deserialize के लिए संबंधित C# schema की आवश्यकता होती है। ये types binaries के आंतरिक प्रतिनिधित्व के रूप में मौजूद होते हैं, लेकिन types C# schema के बिना निर्धारित नहीं किए जा सकते।</p><p>Endian <code>Little Endian</code> होना चाहिए। हालांकि, reference C# implementation endianness की परवाह नहीं करता, इसलिए इसे big-endian मशीन पर उपयोग नहीं किया जा सकता। हालांकि, आधुनिक कंप्यूटर आमतौर पर little-endian होते हैं।</p><p>फॉर्मेट के आठ प्रकार हैं।</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>सर्कुलर रेफरेंस ऑब्जेक्ट  </li>
<li>टपल  </li>
<li>कलेक्शन  </li>
<li>स्ट्रिंग  </li>
<li>यूनियन  </li></p><p></ul><h3>अनमैनेज्ड स्ट्रक्चर</h3></p><p>अनमैनेज्ड स्ट्रक्चर वह C# स्ट्रक्चर है जिसमें रेफरेंस टाइप्स नहीं होते, यह <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# अनमैनेज्ड टाइप्स</a> जैसी कंस्ट्रेंट के समान है। स्ट्रक्चर लेआउट को जेसा है वैसा ही सीरियलाइज़ किया जाता है, जिसमें पैडिंग भी शामिल होती है।</p><h3>ऑब्जेक्ट</h3></p><p><code>(byte memberCount, [values...])</code></p><p>ऑब्जेक्ट के हैडर में 1 बाइट अनसाइन्ड बाइट के रूप में मेंबर काउंट होता है। मेंबर काउंट <code>0</code> से <code>249</code> तक हो सकता है, <code>255</code> दर्शाता है कि ऑब्जेक्ट <code>null</code> है। वैल्यूज़ में मेंबर काउंट की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p><h3>वर्शन टॉलरेंट ऑब्जेक्ट</h3></p><p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p><p>वर्शन टॉलरेंट ऑब्जेक्ट ऑब्जेक्ट के समान है, लेकिन इसमें हैडर में वैल्यूज़ की बाइट लेंथ होती है। वरिन्ट इन स्पेसिफिकेशन का पालन करता है, पहला sbyte वैल्यू या टाइपकोड होता है और अगले X बाइट वैल्यू होते हैं। 0 से 127 = अनसाइन्ड बाइट वैल्यू, -1 से -120 = साइनड बाइट वैल्यू, -121 = बाइट, -122 = स्बाइट, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long।</p><h3>सर्कुलर रेफरेंस ऑब्जेक्ट</h3></p><p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code>  
<code>(250, varint referenceId)</code></p><p>सर्कुलर रेफरेंस ऑब्जेक्ट वर्शन टॉलरेंट ऑब्जेक्ट के समान है लेकिन अगर memberCount 250 है, तो अगला varint (unsigned-int32) referenceId होता है। यदि नहीं, तो byte-length-of-values के बाद varint referenceId लिखा जाता है।</p><h3>टपल</h3></p><p><code>(values...)</code></p><p>टपल फिक्स्ड-साइज़, नॉन-नल वैल्यू कलेक्शन है। .NET में, <code>KeyValuePair<TKey, TValue></code> और <code>ValueTuple<T,...></code> को टपल के रूप में सीरियलाइज़ किया जाता है।</p><h3>कलेक्शन</h3></p><p><code>(int length, [values...])</code></p><p>कलेक्शन के हैडर में 4 बाइट साइनड इन्टीजर के रूप में डेटा काउंट होता है, <code>-1</code> का अर्थ है <code>null</code>। वैल्यूज़ में लेंथ की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p><h3>स्ट्रिंग</h3></p><p><code>(int utf16-length, utf16-value)</code>  
<code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p><p>स्ट्रिंग के दो रूप होते हैं, UTF16 और UTF8। अगर पहली 4-बाइट साइनड इन्टीजर <code>-1</code> है, तो यह null दर्शाता है। <code>0</code> का अर्थ है खाली। UTF16 कलेक्शन के समान है (<code>ReadOnlySpan<char></code> के रूप में सीरियलाइज़), utf16-value के बाइट काउंट = utf16-length * 2। अगर पहली साइनड इन्टीजर <= <code>-2</code>, तो वैल्यू UTF8 में एन्कोड की जाती है। utf8-byte-count कंप्लीमेंट में एन्कोडेड है, बाइट्स की गिनती प्राप्त करने के लिए <code>~utf8-byte-count</code>। अगला साइनड इन्टीजर utf16-length है, यह <code>-1</code> हो सकता है जो अज्ञात लंबाई दर्शाता है। utf8-bytes में utf8-byte-count की संख्या के लिए बाइट्स स्टोर होती हैं।</p><h3>यूनियन</h3></p><p><code>(byte tag, value)</code>  
<code>(250, ushort tag, value)</code></p><p>पहली अनसाइन्ड बाइट टैग है जो डिस्क्रिमिनेटेड वैल्यू टाइप या फ्लैग के लिए है, <code>0</code> से <code>249</code> टैग दर्शाते हैं, <code>250</code> दर्शाता है कि अगला अनसाइन्ड शॉर्ट टैग है, <code>255</code> दर्शाता है कि यूनियन <code>null</code> है।</p><p>License  
---  
यह लाइब्रेरी MIT लाइसेंस के तहत लाइसेंस प्राप्त है।

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>