<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Dutch. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Dutch. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Dutch, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Dutch. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-nl.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Dutch</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Zero encoding extreme performance binary serializer voor C# en Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>In vergelijking met <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Gemeten op .NET 7 / Ryzen 9 5950X machine. Deze serializers hebben een <code>IBufferWriter<byte></code> methode, geserialiseerd met <code>ArrayBufferWriter<byte></code> en hergebruikt om buffer kopiëren te vermijden.</blockquote></p><p>Voor standaard objecten is MemoryPack x10 sneller en x2 ~ x5 sneller dan andere binaire serializers. Voor struct arrays is MemoryPack zelfs nog krachtiger, met snelheden tot x50 ~ x200 hoger dan andere serializers.</p><p>MemoryPack is mijn 4e serializer. Hiervoor heb ik bekende serializers gemaakt, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. De reden voor de snelheid van MemoryPack is het C#-specifieke, voor C# geoptimaliseerde binaire formaat en een goed afgestemde implementatie gebaseerd op mijn eerdere ervaring. Het is ook een compleet nieuw ontwerp dat gebruik maakt van .NET 7 en C# 11 en de Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) en er is ook Unity-ondersteuning).</p><p>Andere serializers voeren veel coderingsbewerkingen uit zoals VarInt-codering, tags, string, enz. Het MemoryPack-formaat gebruikt een zero-encoding ontwerp dat zoveel mogelijk C#-geheugen kopieert. Zero-encoding lijkt op FlatBuffers, maar heeft geen speciaal type nodig, het serialisatiedoel van MemoryPack is POCO.</p><p>Naast prestaties heeft MemoryPack de volgende functies.</p><ul><li>Ondersteunt moderne I/O-API's (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Native AOT-vriendelijke Source Generator gebaseerde codegeneratie, geen Dynamic CodeGen (IL.Emit)</li>
<li>Reflectievrije niet-generieke API's</li>
<li>Deserialiseren in een bestaand instantie</li>
<li>Polymorfe (Union) serialisatie</li>
<li>Beperkt versie-tolerant (snel/standaard) en volledige versie-tolerante ondersteuning</li>
<li>Serialisatie van circulaire referenties</li>
<li>PipeWriter/Reader gebaseerde streaming serialisatie</li>
<li>TypeScript codegeneratie en ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP-ondersteuning via .NET Source Generator</li></p><p></ul>Installatie
<hr>
Deze bibliotheek wordt verspreid via NuGet. Voor de beste prestaties wordt <code>.NET 7</code> aanbevolen. De minimale vereiste is <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>Daarnaast vereist een code-editor Roslyn 4.3.1 ondersteuning, bijvoorbeeld Visual Studio 2022 versie 17.3, .NET SDK 6.0.401. Zie voor details het <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a> document.</p><p>Voor Unity zijn de vereisten en het installatieproces volledig anders. Zie de <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a> sectie voor details.</p><p>Snelle start
<hr>
Definieer een struct of klasse om te serialiseren en annoteer deze met het <code>[MemoryPackable]</code> attribuut en het <code>partial</code> sleutelwoord.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>Serialisatiecode wordt gegenereerd door de C# source generator functionaliteit, die de <code>IMemoryPackable<T></code> interface implementeert. In Visual Studio kun je de gegenereerde code bekijken door de sneltoets <code>Ctrl+K, R</code> te gebruiken op de klassenaam en <code>*.MemoryPackFormatter.g.cs</code> te selecteren.</p><p>Roep <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> aan om een objectinstantie te serialiseren/deserialiseren.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>De <code>Serialize</code>-methode ondersteunt een returntype van <code>byte[]</code> evenals serialisatie naar <code>IBufferWriter<byte></code> of <code>Stream</code>. De <code>Deserialize</code>-methode ondersteunt <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> en <code>Stream</code>. Er zijn ook niet-generieke versies.</p><p>Standaard ondersteunde types
<hr>
Deze types kunnen standaard worden geserialiseerd:</p><ul><li>.NET-primitieven (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.)</li>
<li>Unmanaged types (Elke <code>enum</code>, elke door de gebruiker gedefinieerde <code>struct</code> zonder referentietypes)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Immutable collecties (<code>ImmutableList<></code>, etc.) en interfaces (<code>IImmutableList<></code>, etc.)</li></p><p></ul>Definieer <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> kan worden geannoteerd op elke <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> en <code>interface</code>. Als een type een <code>struct</code> of <code>record struct</code> is die geen referentietypes bevat (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>), wordt extra annotatie (ignore, include, constructor, callbacks) niet gebruikt; deze worden direct uit het geheugen geserialiseerd/gedeserialiseerd.</p><p>Anders serialiseert <code>[MemoryPackable]</code> standaard de publieke instantie-eigenschappen of velden. Je kunt <code>[MemoryPackIgnore]</code> gebruiken om een serialisatiedoel te verwijderen, <code>[MemoryPackInclude]</code> promoot een privé-lid tot serialisatiedoel.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // deze types worden standaard geserialiseerd
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // deze types worden standaard niet geserialiseerd
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // gebruik [MemoryPackIgnore] om een publiek lid uit te sluiten van serialisatie
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // gebruik [MemoryPackInclude] om een privé-lid te promoten tot serialisatiedoel
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>De codegenerator van <code>MemoryPack</code> voegt informatie toe over welke leden worden geserialiseerd aan de <code><remarks /></code> sectie. Dit kan worden bekeken door met Intellisense over het type te zweven.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>Alle leden moeten memorypack-serialiseerbaar zijn, zo niet dan zal de codegenerator een foutmelding geven.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack heeft 35 diagnosticaregels (<code>MEMPACK001</code> tot <code>MEMPACK035</code>) om comfortabel te definiëren.</p><p>Als een doeltijdstype extern MemoryPack-serialisatie heeft en geregistreerd is, gebruik dan <code>[MemoryPackAllowSerialize]</code> om diagnostics te onderdrukken.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>De volgorde van leden is <strong>belangrijk</strong>. MemoryPack serialiseert niet de ledennaam of andere informatie, maar serialiseert velden in de volgorde waarin ze zijn gedeclareerd. Als een type is overgeërfd, gebeurt serialisatie in de volgorde ouder → kind. De volgorde van leden mag niet veranderen voor de deserialisatie. Zie voor schema-evolutie de <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a> sectie.</p><p>De standaardvolgorde is sequentieel, maar je kunt een expliciete layout kiezen met <code>[MemoryPackable(SerializeLayout.Explicit)]</code> en <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// serialiseer Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Constructorselectie</h3></p><p>MemoryPack ondersteunt zowel geparametriseerde als parameterloze constructors. De selectie van de constructor volgt deze regels (geldt voor klassen en structs):</p><ul><li>Als er een <code>[MemoryPackConstructor]</code> is, wordt deze gebruikt.</li>
<li>Als er geen expliciete constructor is (inclusief privé), wordt een parameterloze gebruikt.</li>
<li>Als er één parameterloze/geparametriseerde constructor is (inclusief privé), wordt deze gebruikt.</li>
<li>Als er meerdere constructors zijn, dan moet het <code>[MemoryPackConstructor]</code> attribuut worden toegepast op de gewenste constructor (de generator kiest niet automatisch), anders geeft de generator een foutmelding.</li>
<li>Bij gebruik van een geparametriseerde constructor moeten alle parameternamen overeenkomen met de corresponderende ledennamen (hoofdletterongevoelig).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // Je kunt een geparametriseerde constructor gebruiken - parameternamen moeten overeenkomen met de corresponderende ledennaam (hoofdletterongevoelig)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// ondersteunt ook record primary constructor
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// Als er meerdere constructors zijn, dan moet [MemoryPackConstructor] gebruikt worden
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>Serialisatie-callbacks</h3></p><p>Bij serialiseren/deserialiseren kan MemoryPack een before/after event aanroepen met behulp van de attributen <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Deze kunnen zowel statische als instantie (niet-statische) methoden annoteren, en zowel publieke als private methoden.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // aanroepvolgorde van de methoden is statisch -> instantie
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // private methode is ook toegestaan
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Let op: instantie-methode met MemoryPackOnDeserializing wordt niet aangeroepen als instantie niet via <code>ref</code> is meegegeven
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>Callbacks staan parameterloze methoden en <code>ref reader/writer, ref T value</code> methoden toe. Bijvoorbeeld, ref callbacks kunnen een custom header schrijven/uitlezen vóór het serialisatieproces.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, gebruik where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // schrijf GUID in de header.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // lees custom header vóór deserialisatie
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>Als je een waarde toekent aan <code>ref value</code>, kun je de waarde wijzigen die wordt gebruikt voor serialisatie/deserialisatie. Bijvoorbeeld, instantieren vanuit een ServiceProvider.</p><pre><code class="language-csharp">// voor je deze formatter gebruikt, stel ServiceProvider in
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>Definieer een custom collectie
<hr>
Standaard probeert een met <code>[MemoryPackObject]</code> geannoteerd type zijn members te serialiseren. Echter, als een type een collectie is (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), gebruik dan <code>GenerateType.Collection</code> om het correct te serialiseren.</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Statische constructor
<hr>
Een MemoryPackable class kan geen statische constructor definiëren omdat de gegenereerde partial class deze gebruikt. In plaats daarvan kun je een <code>static partial void StaticConstructor()</code> definiëren om hetzelfde te bereiken.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Polymorfisme (Union)
<hr>
MemoryPack ondersteunt het serialiseren van interface- en abstracte klasse-objecten voor polymorfe serialisatie. In MemoryPack wordt deze functie Union genoemd. Alleen interfaces en abstracte klassen mogen worden geannoteerd met <code>[MemoryPackUnion]</code> attributen. Unieke union-tags zijn vereist.</p><pre><code class="language-csharp">// Annoteer [MemoryPackable] en afgeleide types met [MemoryPackUnion]
// Union ondersteunt ook abstracte klassen
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Serialize als interface type.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Deserialize als interface type.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> staat waarden toe van <code>0</code> ~ <code>65535</code>, het is vooral efficiënt voor minder dan <code>250</code>.
<pre><code class="language-">Als een interface en afgeleide typen zich in verschillende assemblies bevinden, kun je in plaats daarvan <code>MemoryPackUnionFormatterAttribute</code> gebruiken. Formatters worden zo gegenereerd dat ze automatisch worden geregistreerd via <code>ModuleInitializer</code> in C# 9.0 en hoger.</p><blockquote>Let op: <code>ModuleInitializer</code> wordt niet ondersteund in Unity, dus de formatter moet handmatig worden geregistreerd. Om je union formatter te registreren, roep je <code>{naam van je union formatter}Initializer.RegisterFormatter()</code> handmatig aan in Startup. Bijvoorbeeld <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB definieer de definitie buiten het doeldtype
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
Union kan in code worden samengesteld via <code>DynamicUnionFormatter<T></code>.
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
Serialize API
<hr>
<code>Serialize</code> heeft drie overloads.
</code></pre>csharp
// Niet-generieke API is ook beschikbaar, bij deze versies is het eerste argument Type en de waarde object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
Voor prestaties wordt de aanbevolen API met <code>BufferWriter</code> gebruikt. Dit serialiseert direct in de buffer. Het kan worden toegepast op <code>PipeWriter</code> in <code>System.IO.Pipelines</code>, <code>BodyWriter</code> in ASP .NET Core, enzovoort.</p><p>Als een <code>byte[]</code> vereist is (bijv. <code>RedisValue</code> in <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), is de teruggegeven <code>byte[]</code> API eenvoudig en bijna net zo snel.</p><p>Let op dat <code>SerializeAsync</code> voor <code>Stream</code> alleen asynchroon is voor Flush; het serialiseert alles in één keer in de interne poolbuffer van MemoryPack en schrijft vervolgens met <code>WriteAsync</code>. Daarom is de <code>BufferWriter</code> overload, die buffer en flush scheidt en beheert, beter.</p><p>Als je volledig streaming wilt schrijven, zie de sectie <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> configureert of strings als UTF16 of UTF8 worden geserialiseerd. Dit kan worden geconfigureerd door <code>MemoryPackSerializerOptions.Utf8</code> door te geven voor UTF8-codering, <code>MemoryPackSerializerOptions.Utf16</code> voor UTF16-codering, of <code>MemoryPackSerializerOptions.Default</code> wat standaard op UTF8 staat. Null doorgeven of de standaardparameter gebruiken resulteert in UTF8-codering.</p><p>Aangezien de interne stringrepresentatie van C# UTF16 is, presteert UTF16 beter. Echter, de payload is meestal groter; in UTF8 is een ASCII-string één byte, terwijl deze in UTF16 twee bytes is. Omdat het verschil in grootte van deze payload zo groot is, wordt standaard UTF8 gebruikt.</p><p>Als de data niet-ASCII is (bijv. Japans, wat meer dan 3 bytes kan zijn, en UTF8 is dan groter), of als je het apart moet comprimeren, kan UTF16 betere resultaten geven.</p><p>Hoewel tijdens serialisatie kan worden gekozen voor UTF8 of UTF16, is het niet nodig om dit tijdens deserialisatie te specificeren. Het wordt automatisch gedetecteerd en normaal gedeserialiseerd.</p><p>Daarnaast kun je <code>IServiceProvider? ServiceProvider { get; init; }</code> uit de opties krijgen/instellen. Dit is handig om een DI-object (zoals <code>ILogger<T></code>) te verkrijgen tijdens het serialisatieproces (<code>MemoryPackReader/MemoryPackWriter</code> heeft een .Options property).</p><p>Deserialize API
<hr>
<code>Deserialize</code> heeft overloads voor <code>ReadOnlySpan<byte></code> en <code>ReadOnlySequence<byte></code>, <code>Stream</code> en <code>ref</code> ondersteuning.
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
De <code>ref</code> overload overschrijft een bestaande instantie, zie voor details de <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a> sectie.</p><p><code>DeserializeAsync(Stream)</code> is geen volledige streaming read-operatie; eerst wordt tot het einde van de stream gelezen in de interne pool van MemoryPack, daarna wordt gedeserialiseerd.</p><p>Als je een volledige streaming read-operatie wilt uitvoeren, zie de sectie <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><p>Overwrite
<hr>
Om allocaties te verminderen ondersteunt MemoryPack deserialisatie naar een bestaande instantie, waarbij deze wordt overschreven. Dit kan met de overload <code>Deserialize(ref T? value)</code>.
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// overschrijf data naar bestaande instantie.
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack zal proberen zoveel mogelijk te overschrijven, maar als aan de volgende voorwaarden niet wordt voldaan, wordt er een nieuwe instantie aangemaakt (zoals bij normale deserialisatie).</p><ul><li>ref waarde (inclusief leden in het objectgrafiek) is null, stel een nieuwe instantie in</li>
<li>alleen parameterloze constructor toegestaan, als een constructor met parameters wordt gebruikt, wordt een nieuwe instantie gemaakt</li>
<li>als waarde <code>T[]</code> is, alleen hergebruiken als de lengte gelijk is, anders een nieuwe instantie maken</li>
<li>als waarde een collectie is die een <code>.Clear()</code> methode heeft (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) wordt Clear() aangeroepen en wordt deze hergebruikt, anders wordt een nieuwe instantie aangemaakt</li></p><p></ul>Version tolerant
<hr>
Standaard (<code>GenerateType.Object</code>) ondersteunt MemoryPack beperkte schema-evolutie.</p><ul><li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>leden kunnen worden toegevoegd, maar niet verwijderd</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Toevoegen is OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Verwijderen is NG.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Volgorde wijzigen is NG.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
In het gebruiksgeval, oude data opslaan (naar bestand, naar redis, etc...) en lezen naar nieuw schema is altijd oké. In het RPC-scenario bestaat het schema zowel aan de client- als aan de serverzijde; de client moet vóór de server worden bijgewerkt. Een bijgewerkte client kan zonder problemen verbinding maken met de oude server, maar een oude client kan niet verbinden met een nieuwe server.</p><p>Standaard, wanneer oude data wordt gelezen naar een nieuw schema, worden leden die niet aan de datazijde staan geïnitialiseerd met het <code>default</code> literal.
Als je dit wilt vermijden en de initiële waarden van velden/properties wilt gebruiken, kun je <code>[SuppressDefaultInitialization]</code> gebruiken.
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < als oude data ontbreekt, wordt <code>111</code> gezet.
    
    public int Prop3 { get; set; } = 222; // < als oude data ontbreekt, wordt <code>default</code> gezet.
}
<pre><code class="language-">
 <code>[SuppressDefaultInitialization]</code> heeft de volgende beperking:
<ul><li>Kan niet worden gebruikt met readonly, init-only en required modifier.</li></p><p></ul>De volgende <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> sectie laat zien hoe je kunt controleren op schemawijzigingen, bijvoorbeeld met CI, om ongelukken te voorkomen.</p><p>Bij gebruik van <code>GenerateType.VersionTolerant</code> wordt volledige versie-tolerantie ondersteund.</p><ul><li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>alle leden moeten expliciet <code>[MemoryPackOrder]</code> krijgen (behalve als <code>SerializeLayout.Sequential</code> is geannoteerd)</li>
<li>leden kunnen worden toegevoegd, verwijderd, maar volgorde niet hergebruiken (wel ontbrekende volgorde gebruiken)</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul></code></pre>csharp
// Ok om te serialiseren/deserialiseren beide 
// VersionTolerantObject1 -> VersionTolerantObject2 en 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// verwijderd
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// toegevoegd
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// Indien SerializeLayout.Sequential expliciet is ingesteld, wordt automatische ordening toegestaan.
// Maar het is niet mogelijk om leden te verwijderen voor versie-tolerantie.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> is langzamer dan <code>GenerateType.Object</code> bij het serialiseren. Ook zal de payload-grootte iets groter zijn.</p><p>Serialisatie-informatie
----
Je kunt via IntelliSense in het type zien welke leden worden geserialiseerd. Er is een optie om deze informatie tijdens het compileren naar een bestand te schrijven. Stel <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> als volgt in.</p><pre><code class="language-xml"><!-- output memorypack serialisatie-info naar een map -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>De volgende informatie wordt naar het bestand geschreven.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>Als het type unmanaged is, wordt <code>unmanaged</code> vóór de typenaam weergegeven.</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>Door de verschillen in dit bestand te controleren, kunnen gevaarlijke schemawijzigingen worden voorkomen. Bijvoorbeeld, je kunt CI gebruiken om de volgende regels te detecteren</p><ul><li>wijziging van unmanaged type</li>
<li>wijziging van ledenvolgorde</li>
<li>verwijderen van leden</li></p><p></ul>Circulaire Referentie
<hr>
MemoryPack ondersteunt ook circulaire referenties. Dit maakt het mogelijk om boomstructuren als zodanig te serialiseren.</p><pre><code class="language-csharp">// om circulaire referentie mogelijk te maken, gebruik GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p> Bijvoorbeeld, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> code wordt dan als volgt.</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> heeft dezelfde eigenschappen als versie-tolerant. Echter, als extra beperking zijn alleen parameterloze constructors toegestaan. Ook wordt object-referentie-tracking alleen gedaan voor objecten gemarkeerd met <code>GenerateType.CircularReference</code>. Als je een ander object wilt volgen, wikkel het dan in.</p><p>CustomFormatter
<hr>
Als je <code>MemoryPackCustomFormatterAttribute<T></code> of <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> implementeert (presteert beter, maar complexer), kun je een custom formatter configureren voor een lid van een MemoryPackObject.</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack biedt de volgende formatter-attributen: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // serialiseer dit lid als UTF16 String, het is sneller dan UTF8 maar in ASCII is de grootte groter (maar voor niet-ASCII soms kleiner).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // Bij deserialisatie wordt Dictionary geïnitialiseerd met StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // Tijdens deserialisatie worden alle strings geïnterneerd (zie: String.Intern). Als vergelijkbare waarden vaak voorkomen, bespaart dit geheugen.
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>Om een gelijkheidscomparer voor een set/dictionary te configureren, hebben alle ingebouwde formatters een comparer-constructor overload. Je kunt eenvoudig aangepaste gelijkheidscomparer-formatters maken.</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> comprimeert alleen <code>bool[]</code> types. <code>bool[]</code> wordt normaal geserialiseerd als 1 byte per boolean waarde, maar <code>BitPackFormatter</code> serialiseert <code>bool[]</code> zoals een <code>BitArray</code> waarbij elke bool als 1 bit wordt opgeslagen. Door <code>BitPackFormatter</code> te gebruiken, worden 8 booleans 1 byte, terwijl dat normaal 8 bytes zou zijn, wat resulteert in een 8x kleinere grootte.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> is voor <code>byte[]</code>, bijvoorbeeld kun je met Brotli een grote payload comprimeren.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> is voor <code>string</code>, serialiseer gecomprimeerde string (UTF16) met Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre></p><p><code>BrotliFormatter<T></code> is voor elk type, seriële data gecomprimeerd door Brotli. Als een type <code>byte[]</code> of <code>string</code> is, kun je voor de prestaties beter <code>BrotliFormatter</code> of <code>BrotliStringFormatter</code> gebruiken.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}</code></pre></p><p>Deserialiseren met array pooling
<hr>
Om een grote array (elke <code>T</code>) te deserialiseren, biedt MemoryPack meerdere efficiënte pooling-methoden. De meest effectieve manier is om de <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a> functie te gebruiken. In het bijzonder wordt <code>List<T></code> altijd hergebruikt.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> wordt hergebruikt, geen allocatie bij deserialiseren.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// voor efficiënte bewerking kun je Span<T> krijgen via CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);</code></pre></p><p>Een handige manier is deserialiseren naar een ArrayPool op het moment van deserialisatie. MemoryPack biedt <code>MemoryPoolFormatter<T></code> en <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // Je moet zelf de return code schrijven, hier een snippet.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // doe iets...
}   // teruggeven aan ArrayPool</code></pre></p><p>Prestaties
<hr>
Zie mijn blogpost <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Payloadgrootte en compressie
<hr>
De payloadgrootte hangt af van de doelwaarde; in tegenstelling tot JSON zijn er geen sleutels en het is een binair formaat, dus de payloadgrootte zal waarschijnlijk kleiner zijn dan bij JSON.</p><p>Voor formaten met varint-codering, zoals MessagePack en Protobuf, is MemoryPack vaak groter als er veel ints worden gebruikt (in MemoryPack zijn ints altijd 4 bytes vanwege fixed size encoding, terwijl MessagePack 1~5 bytes gebruikt).</p><p>float en double zijn 4 bytes en 8 bytes in MemoryPack, maar 5 bytes en 9 bytes in MessagePack. Dus MemoryPack is kleiner, bijvoorbeeld voor Vector3 (float, float, float) arrays.</p><p>String is standaard UTF8, wat vergelijkbaar is met andere serializers, maar als de UTF16-optie wordt gekozen, heeft het een ander karakter.</p><p>In elk geval, als de payloadgrootte groot is, moet compressie worden overwogen. LZ4, ZStandard en Brotli worden aanbevolen.</p><h3>Compressie</h3></p><p>MemoryPack biedt een efficiënte helper voor <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> compressie via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> en <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. MemoryPack's <code>BrotliCompressor</code> en <code>BrotliDecompressor</code> bieden compressie/decompressie geoptimaliseerd voor het interne gedrag van MemoryPack.</p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Compressie (vereist using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Verkrijg gecomprimeerde byte[]
var compressedBytes = compressor.ToArray();</p><p>// Of schrijf naar een andere IBufferWriter<byte> (bijvoorbeeld PipeWriter)
compressor.CopyTo(response.BodyWriter);</code></pre></p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Decompressie (vereist using)
using var decompressor = new BrotliDecompressor();</p><p>// Verkrijg gedecomprimeerde ReadOnlySequence<byte> van ReadOnlySpan<byte> of ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);</code></pre></p><p>Zowel <code>BrotliCompressor</code> als <code>BrotliDecompressor</code> zijn structs, ze alloceren geen geheugen op de heap. Beide slaan gecomprimeerde of gedecomprimeerde data op in een interne geheugenpool voor Serialize/Deserialize. Daarom is het noodzakelijk om het geheugengebruik vrij te geven; vergeet niet om <code>using</code> te gebruiken.</p><p>Het compressieniveau is erg belangrijk. De standaardwaarde is ingesteld op quality-1 (CompressionLevel.Fastest), wat anders is dan de .NET-standaard (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) is qua snelheid vergelijkbaar met <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, maar 4 is veel langzamer. Dit is cruciaal bevonden in het serializer-gebruiksscenario. Wees voorzichtig bij het gebruik van de standaard <code>BrotliStream</code> (quality-4 is de standaard). In elk geval zullen compressie-/decompressiesnelheden en -groottes zeer verschillende resultaten opleveren voor verschillende data. Bereid de data voor die jouw applicatie moet verwerken en test het zelf.</p><p>Let op: er is een meervoudige snelheidsstraf tussen MemoryPack's ongecomprimeerde en Brotli's extra compressie.</p><p>Brotli wordt ook ondersteund in een custom formatter. Met <code>BrotliFormatter</code> kun je een specifiek lid comprimeren.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p>Externe types serialiseren
<hr>
Als je externe types wilt serialiseren, kun je een custom formatter maken en deze registreren bij de provider, zie <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> voor details. Het maken van een custom formatter is echter moeilijk. Daarom raden we aan een wrappertype te maken. Bijvoorbeeld, als je een extern type wilt serialiseren genaamd <code>AnimationCurve</code>.</p><pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}</code></pre></p><p>Het te wrappen type is public, maar uitgesloten van serialisatie (<code>MemoryPackIgnore</code>). De properties die je wilt serialiseren zijn private, maar inbegrepen (<code>MemoryPackInclude</code>). Twee patronen van constructors moeten ook voorbereid zijn. De constructor die door de serializer wordt gebruikt, moet private zijn.</p><p>Zoals het nu is, moet het elke keer worden gewrapt, wat onhandig is. En een struct wrapper kan geen null representeren. Laten we dus een custom formatter maken.</p><pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity ondersteunt geen scoped en TBufferWriter, dus wijzig de signature naar <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)</code></pre>csharp
{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
}
<pre><code class="language-">
Registreer tenslotte de formatter in startup.
</code></pre>csharp
MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());
<pre><code class="language-">> Opmerking: Unity's AnimationCurve is standaard serialiseerbaar, dus deze aangepaste formatter is niet nodig voor AnimationCurve</p><p>Pakketten
<hr>
MemoryPack heeft de volgende pakketten.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> is de hoofd bibliotheek en biedt volledige ondersteuning voor hoge prestaties bij serialisatie en deserialisatie van binaire objecten. Het is afhankelijk van <code>MemoryPack.Core</code> voor de kernbibliotheken en van <code>MemoryPack.Generator</code> voor codegeneratie. <code>MemoryPack.Streaming</code> voegt aanvullende extensies toe voor <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.  <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt input/output formatters toe voor ASP.NET Core. <code>MemoryPack.UnityShims</code> voegt Unity shim types en formatters toe voor gedeeld gebruik van types tussen .NET en Unity.</p><p>TypeScript en ASP.NET Core Formatter
<hr>
MemoryPack ondersteunt TypeScript codegeneratie. Het genereert klassen- en serialisatiecode vanuit C#, met andere woorden, je kunt types delen met de browser zonder gebruik te maken van OpenAPI, proto, etc.</p><p>Codegeneratie is geïntegreerd met Source Generator, de volgende optie (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) stelt de uitvoermap in voor TypeScript-code. Runtime code wordt gelijktijdig gegenereerd, dus er zijn geen aanvullende afhankelijkheden vereist.
</code></pre>xml
<!-- output memorypack TypeScript-code naar map -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
Een C# MemoryPackable type moet geannoteerd zijn met <code>[GenerateTypeScript]</code>.
</code></pre>csharp
[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}
<pre><code class="language-">
Runtime code en TypeScript type worden gegenereerd in de doelmap.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>De gegenereerde code ziet er als volgt uit, met eenvoudige velden en statische methoden voor serialize/serializeArray en deserialize/deserializeArray.
</code></pre>typescript
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
<pre><code class="language-">
Je kunt dit type als volgt gebruiken.
</code></pre>typescript
let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// serialiseer naar Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// deserialiseer van ArrayBuffer 
let person2 = Person.deserialize(buffer);
<pre><code class="language-">
Het pakket <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt <code>MemoryPack</code> input en output formatters toe aan ASP.NET Core MVC. Je kunt <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> toevoegen aan ASP.NET Core MVC met de volgende code.
</code></pre>csharp
var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Als checkContentType: true, dan kan meerdere formaten outputten (JSON/MemoryPack, etc...). standaard is false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
<pre><code class="language-">
Als je aanroept vanuit HttpClient, kun je <code>application/x-memorypack</code> instellen als content-header.
</code></pre>csharp
var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");
<pre><code class="language-">
<h3>TypeScript Type Mapping</h3></p><p>Er zijn enkele beperkingen op de typen die gegenereerd kunnen worden. Onder de primitieve types worden <code>char</code> en <code>decimal</code> niet ondersteund. Ook kan een OpenGenerics type niet gebruikt worden.</p><p>|  C#  |  TypeScript  | Beschrijving |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</code></pre>
| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | In TypeScript wordt dit als string weergegeven, maar bij serialiseren/deserialiseren als 16-byte binaire data
| <code>DateTime</code> | <code>Date</code> | DateTimeKind wordt genegeerd
| <code>enum</code> | <code>const enum</code> | <code>long</code> en <code>ulong</code> als onderliggende types worden niet ondersteund
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Ondersteunt alle <code>ICollection<T></code> geïmplementeerde types zoals <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Ondersteunt alle <code>ISet<T></code> geïmplementeerde types zoals <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Ondersteunt alle <code>IDictionary<K,V></code> geïmplementeerde types zoals <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Ondersteunt alleen klassen
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> kan alleen op klassen worden toegepast en wordt momenteel niet ondersteund voor structs.</p><h3>Extensie van importbestand en lidnaamnotatie configureren</h3></p><p>Standaard genereert MemoryPack de bestandsextensie als <code>.js</code>, bijvoorbeeld <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. Wil je een andere extensie of geen extensie, gebruik dan <code>MemoryPackGenerator_TypeScriptImportExtension</code> om dit te configureren.
Ook worden de lidnamen automatisch omgezet naar camelCase. Wil je de originele naam gebruiken, zet <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> op <code>false</code>.</p><pre><code class="language-xml"><ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- mag leeg zijn -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- standaard is true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- standaard is false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup></code></pre></p><p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> zorgt ervoor dat C# nullable annotaties worden weerspiegeld in de TypeScript-code. De standaardwaarde is false, waardoor alles nullable wordt.</p><p>Streaming Serialisatie
<hr>
<code>MemoryPack.Streaming</code> biedt <code>MemoryPackStreamingSerializer</code>, die extra ondersteuning toevoegt voor het serialiseren en deserialiseren van collecties met streams.</p><pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}</code></pre></p><p>Formatter/Provider API
<hr>
Als je een formatter handmatig wilt implementeren, erf dan van <code>MemoryPackFormatter<T></code> en overschrijf de methoden <code>Serialize</code> en <code>Deserialize</code>.</p><pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // gebruik writer-methoden.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // gebruik reader-methoden.
    }
}</code></pre>
De gemaakte formatter wordt geregistreerd met <code>MemoryPackFormatterProvider</code>.</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());</code></pre></p><p>Let op: <code>unmanaged struct</code> (bevat geen referentietypen) kan geen custom formatter gebruiken, deze wordt altijd geserialiseerd volgens de native geheugenlayout.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
Initialiseren van <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> vereist OptionalState. Dit is een wrapper om <code>MemoryPackSerializerOptions</code>, en kan worden gemaakt via <code>MemoryPackWriterOptionalStatePool</code>.</p><pre><code class="language-csharp">// bij dispose, wordt OptionalState teruggegeven aan de pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// voor Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}</code></pre></p><p>Afhankelijkheid van target framework
<hr>
MemoryPack biedt <code>netstandard2.1</code> en <code>net7.0</code>, maar deze zijn niet compatibel met elkaar. Als je bijvoorbeeld MemoryPackable types onder een <code>netstandard2.1</code> project gebruikt vanuit een <code>net7.0</code> project, krijg je een runtime-exceptie zoals:</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Omdat net7.0 gebruikmaakt van statische abstracte leden (<code>Virtual static method</code>), die niet worden ondersteund door netstandard2.1, is dit het verwachte gedrag.</p><p>Een .NET 7-project mag de netstandard 2.1 dll niet gebruiken. Met andere woorden: als de applicatie een .NET 7-project is, moeten alle afhankelijkheden die MemoryPack gebruiken .NET 7 ondersteunen. Dus als een bibliotheekontwikkelaar afhankelijk is van MemoryPack, moet je een dual target framework configureren.</p><pre><code class="language-xml"><TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks></code></pre></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> is een code-first grpc-dotnet framework dat MessagePack gebruikt in plaats van protobuf. MagicOnion ondersteunt nu MemoryPack als serialisatielaag via het <code>MagicOnion.Serialization.MemoryPack</code>-pakket (preview). Zie details: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>Minimaal ondersteunde Unity-versie is <code>2022.3.12f1</code>.</p><p>Het <code>MemoryPack</code>-kernpakket is beschikbaar via nuget. Het is ook beschikbaar in Unity. Wil je ondersteuning voor Unity ingebouwde types, dan bieden we aanvullend de MemoryPack.Unity-extensie.</p><ul><li>Installeer <code>MemoryPack</code> vanuit NuGet met <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Open het venster via NuGet -> Beheer NuGet Packages, zoek "MemoryPack" en druk op Installeren.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>Krijg je een foutmelding over versieconflicten, schakel dan versievalidatie uit in Player Settings (Edit -> Projectinstellingen -> Player -> Scroll naar beneden en vouw "Other Settings" uit, schakel vervolgens "Assembly Version Validation" uit onder het kopje "Configuration").</li></p><p><li>Installeer het <code>MemoryPack.Unity</code>-pakket door te verwijzen naar de git-URL</li></p><p><li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack gebruikt het <em>.</em>.* release tag-systeem, dus je kunt een versie opgeven als #1.0.0. Bijvoorbeeld: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p><p>
Net als bij de .NET-versie wordt de code gegenereerd door een code generator (<code>MemoryPack.Generator.dll</code>). Implementatie zonder reflectie biedt ook de beste prestaties in IL2CPP.</p><p>Voor meer informatie over Unity en Source Generator, zie de <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">Unity documentatie</a>.</p><p>Source Generator wordt ook officieel gebruikt door Unity door <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> en <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. Met andere woorden, het is de standaard voor codegeneratie in de volgende generatie Unity.</p><p>Je kunt alle unmanaged types (zoals <code>Vector3</code>, <code>Rect</code>, etc...) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) serialiseren. Wil je andere Unity-specifieke types serialiseren, zie het gedeelte <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Externe types serialiseren</a>.</p><p>Qua prestaties in Unity is MemoryPack x3~x10 sneller dan JsonUtility.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>Als gedeelde code Unity-types bevat (<code>Vector2</code>, etc...), biedt MemoryPack het <code>MemoryPack.UnityShims</code>-pakket via NuGet.</p><p>Het <code>MemoryPack.UnityShims</code>-pakket biedt shims voor Unity's standaard structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p><blockquote>[!WAARSCHUWING]</blockquote>
<blockquote>Momenteel gelden de volgende beperkingen voor gebruik in Unity</blockquote></p><ul><li>De Unity-versie ondersteunt geen CustomFormatter.</li>
<li>Als je .NET7 of nieuwer gebruikt, is het MemoryPack binaire formaat niet volledig compatibel met Unity.</li>
    <li>Dit probleem doet zich voor bij waarde types waarvoor <code>[StructLayout(LayoutKind.Auto)]</code> expliciet is opgegeven. (De standaard voor struct is <code>LayoutKind.Sequencial</code>.) Voor zulke types kunnen binaries die in .NET zijn geserialiseerd, niet worden gedeserialiseerd in Unity. Evenzo kan een binary die in Unity is geserialiseerd, niet worden geserialiseerd aan de .NET-kant.</li>
    <li>De getroffen types omvatten doorgaans de volgende types:</li>
        <li><code>DateTimeOffset</code></li>
        <li><code>ValueTuple</code></li>
    <li>Momenteel is de eenvoudige oplossing om deze types niet te gebruiken.</li></p><p>
</ul>Native AOT
<hr>
Helaas veroorzaakt .NET 7 Native AOT een crash (<code>Generic virtual method pointer lookup failure</code>) bij gebruik van MemoryPack, vanwege een runtime bug. 
Dit wordt opgelost in .NET 8. Door `<code>Microsoft.DotNet.ILCompiler</code><code> preview te gebruiken, wordt het probleem in .NET 7 opgelost. Zie <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">opmerking bij issue</a> voor instructies om dit in te stellen.</p><p>Binaire wireformaatspecificatie
<hr>
Het type </code>T<code> dat wordt gedefinieerd in </code>Serialize<T><code> en </code>Deserialize<T><code> wordt het C#-schema genoemd. Het MemoryPack-formaat is geen zelfbeschrijvend formaat. Voor deserialisatie is het bijbehorende C#-schema vereist. Deze types bestaan als interne representaties van binaries, maar types kunnen niet worden bepaald zonder een C#-schema.</p><p>Endianness moet </code>Little Endian<code> zijn. De C#-implementatie houdt echter geen rekening met endianness en kan dus niet worden gebruikt op big-endian machines. Moderne computers zijn echter vrijwel altijd little-endian.</p><p>Er zijn acht types formaten.</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circulaire Referentie Object</li>
<li>Tuple</li>
<li>Collectie</li>
<li>String</li>
<li>Unie</li></p><p></ul><h3>Unmanaged struct</h3></p><p>Unmanaged struct is een C# struct die geen referentietypen bevat, vergelijkbare beperking als <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>. Serialiseren van struct layout zoals het is, inclusief padding.</p><h3>Object</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Object heeft 1 byte unsigned byte als aantal leden in de header. Aantal leden kan van </code>0<code> tot </code>249<code>, </code>255<code> geeft aan dat het object </code>null<code> is. Waarden slaan memorypack-waarde op voor het aantal leden.</p><h3>Version Tolerant Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Version Tolerant Object is vergelijkbaar met Object maar heeft de bytelengte van de waarden in de header. varint volgt deze specificatie, eerste sbyte is waarde of typeCode en de volgende X bytes zijn de waarde. 0 tot 127 = unsigned byte waarde, -1 tot -120 = signed byte waarde, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Circulaire Referentie Object</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Circulaire Referentie Object is vergelijkbaar met Version Tolerant Object maar als memberCount 250 is, is de volgende varint(unsigned-int32) de referenceId. Zo niet, dan wordt na byte-length-of-values, varint referenceId geschreven.</p><h3>Tuple</h3></p><p></code>(values...)<code></p><p>Tuple is een collectie met vaste grootte van niet-nullable waarden. In .NET worden </code>KeyValuePair<TKey, TValue><code> en </code>ValueTuple<T,...><code> geserialiseerd als Tuple.</p><h3>Collectie</h3></p><p></code>(int length, [values...])<code></p><p>Collectie heeft een 4-byte signed integer als datatelling in de header, </code>-1<code> betekent </code>null<code>. Waarden slaan memorypack-waarde op voor het aantal van de lengte.</p><h3>String</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>String heeft twee vormen, UTF16 en UTF8. Als de eerste 4-byte signed integer </code>-1<code> is, betekent dit null. </code>0<code> betekent leeg. UTF16 is hetzelfde als collectie (serialiseren als </code>ReadOnlySpan<char><code>, utf16-value's byte-telling is utf16-length * 2). Als het eerste signed integer <= </code>-2<code>, wordt de waarde gecodeerd in UTF8. utf8-byte-count is gecodeerd in complement, </code>~utf8-byte-count<code> om het aantal bytes te bepalen. De volgende signed integer is utf16-length, dit kan </code>-1<code> zijn wat onbekende lengte betekent. utf8-bytes slaan bytes op voor het aantal utf8-byte-count.</p><h3>Unie</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>Eerste unsigned byte is tag voor gediscrimineerde waarde type of vlag, </code>0<code> tot </code>249<code> betekent tag, </code>250<code> betekent dat de volgende unsigned short de tag is, </code>255<code> betekent dat de unie </code>null` is.</p><p>Licentie
<hr>
Deze bibliotheek is gelicentieerd onder de MIT-licentie.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>