<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Portuguese. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Portuguese. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Portuguese, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Portuguese. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-pt.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Portuguese</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Serializador binário de desempenho extremo com zero codificação para C# e Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>Comparado com <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Medido em máquina .NET 7 / Ryzen 9 5950X. Esses serializadores possuem método <code>IBufferWriter<byte></code>, serializados utilizando <code>ArrayBufferWriter<byte></code> e reutilizados para evitar a medição de cópia de buffer.</blockquote></p><p>Para objetos padrão, o MemoryPack é x10 mais rápido e x2 ~ x5 mais rápido que outros serializadores binários. Para arrays de struct, o MemoryPack é ainda mais poderoso, com velocidades até x50 ~ x200 maiores do que outros serializadores.</p><p>MemoryPack é meu quarto serializador, anteriormente criei serializadores bem conhecidos, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. O motivo da velocidade do MemoryPack é devido ao seu formato binário específico e otimizado para C#, além de uma implementação bem ajustada baseada em minha experiência anterior. Também é um design completamente novo, utilizando .NET 7 e C# 11 e o Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) e também há suporte para Unity).</p><p>Outros serializadores realizam muitas operações de codificação, como VarInt, tag, string, etc. O formato do MemoryPack utiliza um design de zero-codificação que copia o máximo possível da memória do C#. Zero-codificação é similar ao FlatBuffers, mas não necessita de um tipo especial, o alvo da serialização do MemoryPack é POCO.</p><p>Além do desempenho, o MemoryPack possui estes recursos:</p><ul><li>Suporte às APIs modernas de I/O (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Geração de código baseada em Source Generator nativo amigável para AOT, sem Dynamic CodeGen (IL.Emit)</li>
<li>APIs não genéricas sem reflexão</li>
<li>Desserialização em instância existente</li>
<li>Serialização polimórfica (Union)</li>
<li>Suporte a tolerância de versão limitada (rápido/padrão) e completa</li>
<li>Serialização de referência circular</li>
<li>Serialização de streaming baseada em PipeWriter/Reader</li>
<li>Geração de código TypeScript e Formatter para ASP.NET Core</li>
<li>Suporte a Unity (2021.3) IL2CPP via .NET Source Generator</li></p><p></ul>Instalação
<hr>
Esta biblioteca é distribuída via NuGet. Para melhor desempenho, recomenda-se usar <code>.NET 7</code>. O requisito mínimo é <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>Além disso, o editor de código requer suporte ao Roslyn 4.3.1, por exemplo, Visual Studio 2022 versão 17.3, .NET SDK 6.0.401. Para mais detalhes, consulte o documento <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a>.</p><p>Para Unity, os requisitos e processo de instalação são completamente diferentes. Veja a seção <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a> para detalhes.</p><p>Início Rápido
<hr>
Defina uma struct ou classe a ser serializada e anote com o atributo <code>[MemoryPackable]</code> e a palavra-chave <code>partial</code>.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>O código de serialização é gerado pela funcionalidade de source generator do C#, que implementa a interface <code>IMemoryPackable<T></code>. No Visual Studio você pode verificar o código gerado usando o atalho <code>Ctrl+K, R</code> sobre o nome da classe e selecionando <code>*.MemoryPackFormatter.g.cs</code>.</p><p>Chame <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> para serializar/desserializar uma instância de objeto.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>O método <code>Serialize</code> suporta tipo de retorno <code>byte[]</code>, além de poder serializar para <code>IBufferWriter<byte></code> ou <code>Stream</code>. O método <code>Deserialize</code> suporta <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> e <code>Stream</code>. Também existem versões não genéricas.</p><p>Tipos suportados nativamente
<hr>
Estes tipos podem ser serializados por padrão:</p><ul><li>Primitivos do .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.)</li>
<li>Tipos não gerenciados (Qualquer <code>enum</code>, qualquer <code>struct</code> definido pelo usuário que não contenha tipos de referência)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Coleções imutáveis (<code>ImmutableList<></code>, etc.) e interfaces (<code>IImmutableList<></code>, etc.)</li></p><p></ul>Defina <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> pode ser aplicado a qualquer <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> e <code>interface</code>. Se o tipo for <code>struct</code> ou <code>record struct</code> que não contém tipos de referência (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">Tipos não gerenciados em C#</a>), qualquer anotação adicional (ignore, include, construtor, callbacks) não é usada, pois será serializado/desserializado diretamente da memória.</p><p>Caso contrário, por padrão, <code>[MemoryPackable]</code> serializa propriedades ou campos de instância públicos. Você pode usar <code>[MemoryPackIgnore]</code> para remover o alvo da serialização, <code>[MemoryPackInclude]</code> promove um membro privado para alvo de serialização.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // estes tipos são serializados por padrão
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // estes tipos não são serializados por padrão
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // use [MemoryPackIgnore] para remover o alvo de um membro público
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // use [MemoryPackInclude] para promover um membro privado como alvo de serialização
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>O gerador de código do <code>MemoryPack</code> adiciona informações sobre quais membros são serializados à seção <code><remarks /></code>. Isso pode ser visualizado ao passar o mouse sobre o tipo com o Intellisense.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>Todos os membros devem ser serializáveis pelo memorypack, caso contrário o gerador de código emitirá um erro.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>O MemoryPack possui 35 regras de diagnóstico (<code>MEMPACK001</code> a <code>MEMPACK035</code>) para facilitar a definição.</p><p>Se o tipo alvo possuir serialização MemoryPack definida externamente e registrada, use <code>[MemoryPackAllowSerialize]</code> para silenciar diagnósticos.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>A ordem dos membros é <strong>importante</strong>, o MemoryPack não serializa o nome do membro nem outras informações, ao invés disso, serializa os campos na ordem em que são declarados. Se um tipo for herdado, a serialização ocorre na ordem pai → filho. A ordem dos membros não pode ser alterada para a desserialização. Para evolução de esquema, veja a seção <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Tolerância de versão</a>.</p><p>A ordem padrão é sequencial, mas você pode escolher o layout explícito com <code>[MemoryPackable(SerializeLayout.Explicit)]</code> e <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// serializa Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Seleção de construtor</h3></p><p>O MemoryPack suporta tanto construtores parametrizados quanto sem parâmetros. A seleção do construtor segue estas regras (aplicável a classes e structs):</p><ul><li>Se houver <code>[MemoryPackConstructor]</code>, use-o.</li>
<li>Se não houver construtor explícito (incluindo privado), use o sem parâmetros.</li>
<li>Se houver um único construtor sem parâmetros/parametrizado (incluindo privado), use-o.</li>
<li>Se houver múltiplos construtores, então o atributo <code>[MemoryPackConstructor]</code> deve ser aplicado ao construtor desejado (o gerador não escolherá automaticamente), caso contrário, o gerador emitirá um erro.</li>
<li>Se usar construtor parametrizado, todos os nomes dos parâmetros devem corresponder aos nomes dos membros correspondentes (case-insensitive).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // Você pode usar um construtor parametrizado - os nomes dos parâmetros devem corresponder aos nomes dos membros (case-insensitive)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// também suporta record com construtor primário
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }
</code></pre>csharp
// Se houver múltiplos construtores, então [MemoryPackConstructor] deve ser utilizado
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}
<pre><code class="language-">
<h3>Callbacks de serialização</h3></p><p>Ao serializar/desserializar, o MemoryPack pode invocar um evento antes/depois utilizando os atributos <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Pode-se anotar tanto métodos estáticos quanto de instância (não estáticos), e métodos públicos ou privados.
</code></pre>csharp
[MemoryPackable]
public partial class MethodCallSample
{
    // a ordem de chamada dos métodos é estático -> instância
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // também permite método privado
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Nota: método de instância com MemoryPackOnDeserializing, não é chamado se a instância não for passada por <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}
<pre><code class="language-">
Os callbacks permitem métodos sem parâmetros e métodos com <code>ref reader/writer, ref T value</code>. Por exemplo, callbacks com ref podem escrever/ler cabeçalhos personalizados antes do processo de serialização.
</code></pre>csharp
[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, use where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // emite GUID no cabeçalho.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // lê cabeçalho personalizado antes de desserializar
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}
<pre><code class="language-">
Se definir um valor para <code>ref value</code>, você pode alterar o valor utilizado para serialização/desserialização. Por exemplo, instanciar a partir de um ServiceProvider.
</code></pre>csharp
// antes de usar este formatter, configure o ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}
<pre><code class="language-">
Definir coleção personalizada
<hr>
Por padrão, o tipo anotado com <code>[MemoryPackObject]</code> tenta serializar seus membros. Entretanto, se um tipo for uma coleção (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), utilize <code>GenerateType.Collection</code> para serializá-lo corretamente.
</code></pre>csharp
[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}
<pre><code class="language-">
Construtor estático
<hr>
A classe MemoryPackable não pode definir construtor estático porque a classe parcial gerada o utiliza. Em vez disso, você pode definir um <code>static partial void StaticConstructor()</code> para realizar a mesma ação.
</code></pre>csharp
[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}
<pre><code class="language-">
Polimorfismo (Union)
<hr>
O MemoryPack suporta serialização de objetos de interface e classes abstratas para serialização polimórfica. No MemoryPack este recurso é chamado de Union. Apenas interfaces e classes abstratas podem ser anotadas com os atributos <code>[MemoryPackUnion]</code>. Tags únicas de união são obrigatórias.
</code></pre>csharp
// Anote [MemoryPackable] e os tipos de herança com [MemoryPackUnion]
// Union também suporta classe abstrata
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Serializa como tipo de interface.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Desserializa como tipo de interface.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}
<pre><code class="language-">
<code>tag</code> permite valores de <code>0</code> ~ <code>65535</code>, sendo especialmente eficiente para valores menores que <code>250</code>.</code></pre>
Se uma interface e os tipos derivados estiverem em assemblies diferentes, você pode usar <code>MemoryPackUnionFormatterAttribute</code>. Os formatadores são gerados de forma que sejam registrados automaticamente via <code>ModuleInitializer</code> no C# 9.0 e superior.</p><blockquote>Observe que <code>ModuleInitializer</code> não é suportado no Unity, portanto o formatador deve ser registrado manualmente. Para registrar seu formatador union, invoque manualmente <code>{nome do seu union formatter}Initializer.RegisterFormatter()</code> na inicialização. Por exemplo, <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote></p><pre><code class="language-csharp">// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB define definição fora do tipo alvo
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}</code></pre></p><p>Union pode ser montada em código via <code>DynamicUnionFormatter<T></code>.</p><pre><code class="language-csharp">// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);</code></pre></p><p>API de Serialização
<hr>
<code>Serialize</code> possui três sobrecargas.</p><pre><code class="language-csharp">// API não genérica também disponível, nestas versões o primeiro argumento é Type e o valor é object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)</code></pre></p><p>Para desempenho, a API recomendada utiliza <code>BufferWriter</code>. Isso serializa diretamente no buffer. Pode ser aplicado a <code>PipeWriter</code> em <code>System.IO.Pipelines</code>, <code>BodyWriter</code> no ASP .NET Core, etc.</p><p>Se um <code>byte[]</code> for necessário (por exemplo, <code>RedisValue</code> em <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), a API que retorna <code>byte[]</code> é simples e quase tão rápida quanto.</p><p>Observe que o <code>SerializeAsync</code> para <code>Stream</code> é assíncrono apenas para o Flush; ele serializa tudo de uma vez para o buffer interno do MemoryPack e então escreve usando <code>WriteAsync</code>. Portanto, a sobrecarga <code>BufferWriter</code>, que separa e controla o buffer e o flush, é melhor.</p><p>Se quiser realizar uma gravação totalmente streaming, veja a seção <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> configura se strings serão serializadas como UTF16 ou UTF8. Isso pode ser configurado passando <code>MemoryPackSerializerOptions.Utf8</code> para codificação UTF8, <code>MemoryPackSerializerOptions.Utf16</code> para codificação UTF16 ou <code>MemoryPackSerializerOptions.Default</code>, que padrão é UTF8. Passar null ou usar o parâmetro padrão resulta em codificação UTF8.</p><p>Como a representação interna de string do C# é UTF16, UTF16 tem melhor desempenho. Porém, o payload tende a ser maior; em UTF8, uma string ASCII é um byte, enquanto em UTF16 são dois bytes. Como a diferença de tamanho desse payload é grande, UTF8 é o padrão.</p><p>Se os dados não forem ASCII (ex: japonês, que pode ser mais de 3 bytes, e UTF8 fica maior), ou se você precisar comprimir separadamente, UTF16 pode dar melhores resultados.</p><p>Embora UTF8 ou UTF16 possam ser escolhidos durante a serialização, não é necessário especificar durante a desserialização. Será detectado automaticamente e desserializado normalmente.</p><p>Adicionalmente, você pode obter/definir <code>IServiceProvider? ServiceProvider { get; init; }</code> nas opções. É útil para obter um objeto DI (como <code>ILogger<T></code>) no processo de serialização (<code>MemoryPackReader/MemoryPackWriter</code> possui a propriedade .Options).</p><p>API de Desserialização
<hr>
<code>Deserialize</code> possui sobrecargas para <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>, <code>Stream</code> e suporte a <code>ref</code>.</p><pre><code class="language-csharp">T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)</code></pre></p><p>A sobrecarga <code>ref</code> sobrescreve uma instância existente, para detalhes veja a seção <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a>.</p><p><code>DeserializeAsync(Stream)</code> não é uma operação de leitura streaming completa, primeiro lê para o pool interno do MemoryPack até o fim do stream, depois desserializa.</p><p>Se quiser realizar uma leitura totalmente streaming, veja a seção <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><p>Sobrescrita (Overwrite)
<hr>
Para reduzir alocações, o MemoryPack suporta desserialização para uma instância existente, sobrescrevendo-a. Isso pode ser usado com a sobrecarga <code>Deserialize(ref T? value)</code>.</p><pre><code class="language-csharp">var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// sobrescreve os dados na instância existente.
MemoryPackSerializer.Deserialize(bin, ref person);</code></pre></p><p>O MemoryPack tentará sobrescrever o máximo possível, mas se as seguintes condições não forem atendidas, criará uma nova instância (como na desserialização normal).</p><ul><li>valor ref (inclui membros no grafo de objetos) é null, cria nova instância</li>
<li>só permite construtor sem parâmetros, se utilizar construtor com parâmetros, cria nova instância</li>
<li>se o valor for <code>T[]</code>, reutiliza apenas se o comprimento for igual, caso contrário cria nova instância</li>
<li>se o valor for coleção que possui método <code>.Clear()</code> (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) chama Clear() e reutiliza, senão cria nova instância</li></p><p></ul>Tolerância a Versão
<hr>
Por padrão (<code>GenerateType.Object</code>), o MemoryPack suporta evolução de schema limitada.</p><ul><li>struct não gerenciado não pode ser alterado</li>
<li>membros podem ser adicionados, mas não podem ser removidos</li>
<li>pode alterar o nome do membro</li>
<li>não pode alterar a ordem dos membros</li>
<li>não pode alterar o tipo do membro</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Adicionar é OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Remover é NG.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Alterar ordem é NG.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}</code></pre></p><p>No caso de uso, armazenar dados antigos (em arquivo, redis, etc...) e ler para o novo schema sempre é permitido. No cenário de RPC, o schema existe tanto no cliente quanto no servidor, o cliente deve ser atualizado antes do servidor. Um cliente atualizado não tem problemas para conectar com o servidor antigo, mas um cliente antigo não pode conectar com um servidor novo.</p><p>Por padrão, quando os dados antigos são lidos para o novo schema, quaisquer membros ausentes no lado dos dados são inicializados com o literal <code>default</code>.
Se quiser evitar isso e usar valores iniciais dos campos/propriedades, pode usar <code>[SuppressDefaultInitialization]</code>.</p><pre><code class="language-cs">[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < se dados antigos não tiverem, define <code>111</code>.
    
    public int Prop3 { get; set; } = 222; // < se dados antigos não tiverem, define <code>default</code>.
}</code></pre></p><p> <code>[SuppressDefaultInitialization]</code> possui as seguintes limitações:
<ul><li>Não pode ser usado com modificador readonly, init-only e required.</li></p><p></ul>A próxima seção <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> mostra como verificar mudanças de schema, por exemplo, via CI, para evitar acidentes.</p><p>Ao usar <code>GenerateType.VersionTolerant</code>, há suporte total à tolerância de versão.</p><ul><li>struct não gerenciado não pode mais ser alterado</li>
<li>todos os membros devem adicionar <code>[MemoryPackOrder]</code> explicitamente (exceto anotação <code>SerializeLayout.Sequential</code>)</li>
<li>membros podem ser adicionados, podem ser removidos mas não reutilizar ordem (pode usar ordem faltante)</li>
<li>pode mudar nome do membro</li>
<li>não pode mudar ordem do membro</li>
<li>não pode mudar tipo do membro</li></p><p></ul><pre><code class="language-csharp">// Ok para serializar/desserializar ambos 
// VersionTolerantObject1 -> VersionTolerantObject2 e 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{</code></pre>csharp
[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// excluído
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// adicionado
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}
<pre><code class="language-"></code></pre>csharp
// Se definir SerializeLayout.Sequential explicitamente, permite ordenação automática.
// Mas não pode remover nenhum membro para tolerância a versões.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}
<pre><code class="language-">
<code>GenerateType.VersionTolerant</code> é mais lento do que <code>GenerateType.Object</code> na serialização. Além disso, o tamanho do payload será um pouco maior.</p><p>Informações de serialização
----
Você pode verificar no IntelliSense do tipo quais membros são serializados. Existe uma opção para gravar essas informações em um arquivo em tempo de compilação. Defina <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> da seguinte forma.
</code></pre>xml
<!-- exporta informações de serialização do memorypack para o diretório -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
As seguintes informações são gravadas no arquivo.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>Se o tipo for unmanaged, será exibido <code>unmanaged</code> antes do nome do tipo.
</code></pre>txt
unmanaged FooStruct
<hr>
int x
int y
<pre><code class="language-">
Verificando as diferenças neste arquivo, mudanças perigosas no esquema podem ser evitadas. Por exemplo, talvez você queira usar CI para detectar as seguintes regras</p><ul><li>modificar tipo unmanaged</li>
<li>alteração na ordem dos membros</li>
<li>deleção de membro</li></p><p></ul>Referência circular
<hr>
MemoryPack também suporta referência circular. Isso permite que os objetos em árvore sejam serializados como estão.
</code></pre>csharp
// para habilitar referência circular, use GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}
<pre><code class="language-">
Por exemplo, o código <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> ficará assim.
</code></pre>csharp
// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}
<pre><code class="language-">
<code>GenerateType.CircularReference</code> possui as mesmas características que version-tolerant. Entretanto, como restrição adicional, somente construtores sem parâmetros são permitidos. Além disso, o rastreamento de referência de objeto é feito apenas para objetos marcados com <code>GenerateType.CircularReference</code>. Se desejar rastrear qualquer outro objeto, encapsule-o.</p><p>CustomFormatter
<hr>
Se implementar <code>MemoryPackCustomFormatterAttribute<T></code> ou <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (mais performático, porém mais complexo), você pode configurar o uso de formatador personalizado para membros do MemoryPackObject.
</code></pre>csharp
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}
<pre><code class="language-">
MemoryPack fornece os seguintes atributos de formatação: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    // serializa este membro como String UTF16, é mais performático que UTF8 mas em ASCII, o tamanho é maior (mas para não-ASCII, às vezes é menor).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // Na desserialização, o Dictionary é inicializado com StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // No momento da desserialização, todas as strings são internadas (veja: String.Intern). Se valores semelhantes aparecem repetidamente, economiza memória.
    [InternStringFormatter]
    public string? Flag { get; set; }
}
<pre><code class="language-">
Para configurar o equality comparer de um set/dictionary, todos os formatadores internos possuem um overload de construtor com comparer. Você pode facilmente criar formatadores personalizados de equality-comparer.
</code></pre>csharp
public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}
<pre><code class="language-">
<code>BitPackFormatter</code> comprime apenas tipos <code>bool[]</code>. <code>bool[]</code> normalmente é serializado como 1 byte por valor booleano, entretanto <code>BitPackFormatter</code> serializa <code>bool[]</code> como um <code>BitArray</code>, armazenando cada bool como 1 bit. Usando <code>BitPackFormatter</code>, 8 bools tornam-se 1 byte onde normalmente seriam 8 bytes, resultando em um tamanho 8x menor.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}
<pre><code class="language-">
<code>BrotliFormatter</code> é para <code>byte[]</code>, por exemplo você pode comprimir um payload grande usando Brotli.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
<pre><code class="language-">
<code>BrotliStringFormatter</code> é para <code>string</code>, serializa string comprimida (UTF16) usando Brotli.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}
<pre><code class="language-"><code>BrotliFormatter<T></code> é para qualquer tipo, dados serializados comprimidos por Brotli. Se um tipo for <code>byte[]</code> ou <code>string</code>, você deve usar <code>BrotliFormatter</code> ou <code>BrotliStringFormatter</code> para desempenho.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}
<pre><code class="language-">
Pooling de arrays na desserialização
<hr>
Para desserializar um array grande (qualquer <code>T</code>), o MemoryPack oferece vários métodos eficientes de pooling. A maneira mais eficaz é usar a função <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a>. Em particular, <code>List<T></code> é sempre reutilizada.
</code></pre>csharp
[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> é reutilizada, sem alocação na desserialização.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// para operação eficiente, você pode obter Span<T> por CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);
<pre><code class="language-">
Uma maneira conveniente é desserializar para um ArrayPool no momento da desserialização. O MemoryPack fornece <code>MemoryPoolFormatter<T></code> e <code>ReadOnlyMemoryPoolFormatter<T></code>.
</code></pre>csharp
[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // Você deve escrever o código de retorno sozinho, aqui está um trecho.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // faça qualquer coisa...
}   // retorna para ArrayPool
<pre><code class="language-">
Desempenho
<hr>
Veja meu post no blog <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Tamanho do payload e compressão
<hr>
O tamanho do payload depende do valor de destino; diferente do JSON, não há chaves e é um formato binário, então o tamanho do payload tende a ser menor que o do JSON.</p><p>Para aqueles com codificação varint, como MessagePack e Protobuf, o MemoryPack tende a ser maior se muitos ints forem usados (em MemoryPack, ints são sempre 4 bytes devido à codificação de tamanho fixo, enquanto em MessagePack é de 1~5 bytes).</p><p>float e double são 4 bytes e 8 bytes em MemoryPack, mas 5 bytes e 9 bytes em MessagePack. Assim, o MemoryPack é menor, por exemplo, para arrays de Vector3 (float, float, float).</p><p>String é UTF8 por padrão, o que é semelhante a outros serializadores, mas se a opção UTF16 for escolhida, será de natureza diferente.</p><p>Em qualquer caso, se o tamanho do payload for grande, a compressão deve ser considerada. LZ4, ZStandard e Brotli são recomendados.</p><h3>Compressão</h3></p><p>O MemoryPack fornece um helper eficiente para compressão <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> e <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. Os <code>BrotliCompressor</code> e <code>BrotliDecompressor</code> do MemoryPack oferecem compressão/descompressão otimizadas para o comportamento interno do MemoryPack.
</code></pre>csharp
using MemoryPack.Compression;</p><p>// Compressão (requer using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Obter byte[] comprimido
var compressedBytes = compressor.ToArray();</p><p>// Ou escrever para outro IBufferWriter<byte> (por exemplo PipeWriter)
compressor.CopyTo(response.BodyWriter);
<pre><code class="language-"></code></pre>csharp
using MemoryPack.Compression;</p><p>// Descompressão (requer using)
using var decompressor = new BrotliDecompressor();</p><p>// Obter ReadOnlySequence<byte> descomprimido a partir de ReadOnlySpan<byte> ou ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);
<pre><code class="language-">
Tanto <code>BrotliCompressor</code> quanto <code>BrotliDecompressor</code> são structs, não alocam memória no heap. Ambos armazenam dados comprimidos ou descomprimidos em um memory pool interno para Serialize/Deserialize. Portanto, é necessário liberar o memory pooling, não esqueça de usar <code>using</code>.</p><p>O nível de compressão é muito importante. O padrão é definido como quality-1 (CompressionLevel.Fastest), o que é diferente do padrão .NET (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) será próximo à velocidade do <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, mas 4 é muito mais lento. Isso foi considerado crítico no cenário de uso do serializador. Tenha cuidado ao usar o <code>BrotliStream</code> padrão (quality-4 é o padrão). Em qualquer caso, as velocidades e tamanhos de compressão/descompressão resultarão em resultados muito diferentes para diferentes dados. Prepare os dados que serão tratados por sua aplicação e teste você mesmo.</p><p>Observe que há uma penalidade de velocidade várias vezes entre o MemoryPack sem compressão e a compressão Brotli adicionada.</p><p>Brotli também é suportado em um formatter personalizado. <code>BrotliFormatter</code> pode comprimir um membro específico.
</code></pre>csharp
[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
<pre><code class="language-">
Serializar tipos externos
<hr>
Se você quiser serializar tipos externos, pode criar um formatter personalizado e registrá-lo no provider, veja <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> para detalhes. Porém, criar um formatter personalizado é difícil. Portanto, recomendamos fazer um tipo wrapper. Por exemplo, se você quiser serializar um tipo externo chamado <code>AnimationCurve</code>.
</code></pre>csharp
// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}
<pre><code class="language-">
O tipo a ser encapsulado é público, mas excluído da serialização (<code>MemoryPackIgnore</code>). As propriedades que você deseja serializar são privadas, mas incluídas (<code>MemoryPackInclude</code>). Dois padrões de construtores também devem ser preparados. O construtor usado pelo serializador deve ser privado.</p><p>Como está, deve ser encapsulado toda vez, o que é inconveniente. E também o wrapper struct não pode representar null. Então, vamos criar um formatter personalizado.
</code></pre>csharp
public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity não suporta scoped e TBufferWriter então altere a assinatura para <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)
<pre><code class="language-csharp">{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // pular bloco nulo
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
}</code></pre></p><p>Finalmente, registre o formatador na inicialização.</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());</code></pre>
<blockquote>Nota: AnimationCurve do Unity pode ser serializado por padrão, portanto não necessita deste formatador personalizado para AnimationCurve</blockquote></p><p>Pacotes
<hr>
MemoryPack possui estes pacotes.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> é a biblioteca principal, fornece suporte completo para serialização e desserialização de objetos binários de alta performance. Depende de <code>MemoryPack.Core</code> para as bibliotecas base e de <code>MemoryPack.Generator</code> para geração de código. <code>MemoryPack.Streaming</code> adiciona extensões para <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Serialização Streaming</a>. <code>MemoryPack.AspNetCoreMvcFormatter</code> adiciona formatadores de entrada/saída para ASP.NET Core. <code>MemoryPack.UnityShims</code> adiciona tipos shims e formatadores para compartilhamento de tipos entre .NET e Unity.</p><p>TypeScript e Formatter para ASP.NET Core
<hr>
MemoryPack suporta geração de código TypeScript. Ele gera classes e código de serialização a partir de C#. Em outras palavras, você pode compartilhar tipos com o navegador sem usar OpenAPI, proto, etc.</p><p>A geração de código é integrada ao Source Generator, as opções a seguir (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) definem o diretório de saída para o código TypeScript. O código de runtime é gerado ao mesmo tempo, portanto, nenhuma dependência adicional é necessária.</p><pre><code class="language-xml"><!-- saída do código TypeScript do memorypack para o diretório -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup></code></pre></p><p>Um tipo C# MemoryPackable deve ser anotado com <code>[GenerateTypeScript]</code>.</p><pre><code class="language-csharp">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}</code></pre></p><p>O código de runtime e o tipo TypeScript serão gerados no diretório de destino.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>O código gerado é o seguinte, com campos simples e métodos estáticos para serialize/serializeArray e deserialize/deserializeArray.</p><pre><code class="language-typescript">import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}</code></pre></p><p>Você pode usar este tipo como no exemplo a seguir.</p><pre><code class="language-typescript">let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// serializar para Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// desserializar de ArrayBuffer 
let person2 = Person.deserialize(buffer);</code></pre></p><p>O pacote <code>MemoryPack.AspNetCoreMvcFormatter</code> adiciona formatadores de entrada e saída <code>MemoryPack</code> para o ASP.NET Core MVC. Você pode adicionar <code>MemoryPackInputFormatter</code> e <code>MemoryPackOutputFormatter</code> ao ASP.NET Core MVC com o código a seguir.</p><pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Se checkContentType: true então pode gerar saída em múltiplos formatos (JSON/MemoryPack, etc...). O padrão é false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});</code></pre></p><p>Se você chamar a partir do HttpClient, pode definir <code>application/x-memorypack</code> no cabeçalho do conteúdo.</p><pre><code class="language-csharp">var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");</code></pre></p><h3>Mapeamento de Tipos TypeScript</h3></p><p>Há algumas restrições nos tipos que podem ser gerados. Entre os tipos primitivos, <code>char</code> e <code>decimal</code> não são suportados. Além disso, tipos OpenGenerics não podem ser usados.</p><p>|  C#  |  TypeScript  | Descrição |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |
| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | Em TypeScript, representa como string, mas serializa/desserializa como binário de 16 bytes
| <code>DateTime</code> | <code>Date</code> | DateTimeKind será ignorado
| <code>enum</code> | <code>const enum</code> | Tipo subjacente <code>long</code> e <code>ulong</code> não é suportado
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Suporta todo tipo que implementa <code>ICollection<T></code>, como <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Suporta todo tipo que implementa <code>ISet<T></code>, como <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Suporta todo tipo que implementa <code>IDictionary<K,V></code>, como <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Suporta apenas classes
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> só pode ser aplicado a classes e atualmente não é suportado por struct.</p><h3>Configurar extensão de arquivo de importação e formatação dos nomes dos membros</h3></p><p>Por padrão, o MemoryPack gera arquivos com extensão <code>.js</code>, como <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. Se quiser mudar para outra extensão ou deixar vazio, use <code>MemoryPackGenerator_TypeScriptImportExtension</code> para configurar.
Além disso, o nome dos membros é automaticamente convertido para camelCase. Se quiser usar o nome original, defina <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> como <code>false</code>.</p><pre><code class="language-xml"><ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- permite vazio -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- padrão é true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- padrão é false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup></code></pre></p><p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> permite que anotações de nullable do C# sejam refletidas no código TypeScript. O padrão é false, tornando tudo nullable.</p><p>Serialização Streaming
<hr>
<code>MemoryPack.Streaming</code> fornece <code>MemoryPackStreamingSerializer</code>, que adiciona suporte adicional para serializar e desserializar coleções com streams.</p><pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}</code></pre></p><p>API Formatter/Provider
<hr>
Se você deseja implementar um formatter manualmente, herde de <code>MemoryPackFormatter<T></code> e sobrescreva os métodos <code>Serialize</code> e <code>Deserialize</code>.</p><pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // use o método do writer.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // use o método do reader.
    }
}</code></pre>
O formatter criado é registrado com <code>MemoryPackFormatterProvider</code>.</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());</code></pre></p><p>Nota: <code>unmanaged struct</code> (não contém tipos de referência) não pode usar custom formatter, sempre serializa o layout de memória nativo.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
Inicializar <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> requer OptionalState. É um wrapper do <code>MemoryPackSerializerOptions</code>, podendo ser criado a partir do <code>MemoryPackWriterOptionalStatePool</code>.</p><pre><code class="language-csharp">// ao fazer dispose, OptionalState retorna ao pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// para Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}</code></pre></p><p>Dependência de framework alvo
<hr>
MemoryPack fornece <code>netstandard2.1</code> e <code>net7.0</code>, mas ambos não são compatíveis entre si. Por exemplo, tipos MemoryPackable sob projeto <code>netstandard2.1</code> usados a partir de um projeto <code>net7.0</code> geram exceção de runtime como:</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Como o net7.0 usa membros static abstract (<code>Virtual static method</code>), isso não é suportado em netstandard2.1. Este comportamento é uma especificação.</p><p>Projetos .NET 7 não devem usar a dll do netstandard 2.1. Ou seja, se a aplicação é um projeto .NET 7, todas as dependências que usam MemoryPack devem suportar .NET 7. Portanto, se um desenvolvedor de biblioteca depende do MemoryPack, é necessário configurar dual target framework.</p><pre><code class="language-xml"><TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks></code></pre></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> é um framework grpc-dotnet code-first usando MessagePack ao invés de protobuf. O MagicOnion agora suporta MemoryPack como camada de serialização via pacote <code>MagicOnion.Serialization.MemoryPack</code> (preview). Veja detalhes: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>A versão mínima suportada do Unity é <code>2022.3.12f1</code>.</p><p>O pacote core do <code>MemoryPack</code> é fornecido via nuget. Ele também está disponível no Unity. Se você quiser obter suporte para tipos nativos do Unity, fornecemos adicionalmente a extensão MemoryPack.Unity.</p><ul><li>Instale <code>MemoryPack</code> do NuGet usando <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Abra a janela do NuGet -> Manage NuGet Packages, pesquise por "MemoryPack" e pressione Install.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>Se encontrar erros de conflito de versão, desabilite a validação de versão em Player Settings (Edit -> Project Settings -> Player -> Role para baixo e expanda "Other Settings", depois desmarque "Assembly Version Validation" na seção "Configuration").</li></p><p><li>Instale o pacote <code>MemoryPack.Unity</code> referenciando a URL do git</li></p><p><li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
O MemoryPack usa a tag de release <em>.</em>.*, então você pode especificar uma versão como #1.0.0. Por exemplo: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p><p>
Assim como na versão .NET, o código é gerado por um gerador de código (<code>MemoryPack.Generator.dll</code>). A implementação sem reflection também garante a melhor performance no IL2CPP.</p><p>Para mais informações sobre Unity e Source Generator, consulte a <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">documentação da Unity</a>.</p><p>Source Generator também é usado oficialmente pela Unity por <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> e <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. Ou seja, é o padrão para geração de código na próxima geração do Unity.</p><p>Você pode serializar todos os tipos unmanaged (como <code>Vector3</code>, <code>Rect</code>, etc...) e algumas classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>). Se quiser serializar outros tipos específicos do Unity, veja a seção <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a>.</p><p>Em performance no Unity, MemoryPack é de 3 a 10 vezes mais rápido que o JsonUtility.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>Se o código compartilhado possui tipos do Unity (<code>Vector2</code>, etc...), o MemoryPack fornece o pacote <code>MemoryPack.UnityShims</code> no NuGet.</p><p>O pacote <code>MemoryPack.UnityShims</code> fornece shims para structs padrão do Unity (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) e algumas classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p><blockquote>[!AVISO]</blockquote>
<blockquote>Atualmente, existem as seguintes limitações para uso no Unity</blockquote></p><ul><li>A versão do Unity não suporta CustomFormatter.</li>
<li>Se você está usando .NET7 ou superior, o formato binário do MemoryPack não é totalmente compatível com o Unity.</li>
    <li>Esse problema ocorre com tipos de valor que especificam explicitamente <code>[StructLayout(LayoutKind.Auto)]</code>. (O padrão para struct é <code>LayoutKind.Sequential</code>.) Para esses tipos, binários serializados no .NET não podem ser desserializados no Unity. Da mesma forma, um binário serializado no Unity não pode ser desserializado no lado .NET.</li>
    <li>Os tipos afetados normalmente incluem:</li>
        <li><code>DateTimeOffset</code></li>
        <li><code>ValueTuple</code></li>
    <li>Atualmente, a solução simples é não usar esses tipos.</li></p><p>
</ul>Native AOT
<hr>
Infelizmente, o .NET 7 Native AOT causa crash (<code>Generic virtual method pointer lookup failure</code>) ao usar MemoryPack devido a um bug de runtime. Isso será corrigido no .NET 8. Usando a versão preview do `<code>Microsoft.DotNet.ILCompiler</code><code>, isso será corrigido no .NET 7. Veja o <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">comentário da issue</a> para saber como configurar.</p><p>Especificação do formato binário
<hr>
O tipo </code>T<code> definido em </code>Serialize<T><code> e </code>Deserialize<T><code> é chamado de schema C#. O formato MemoryPack não é um formato autodescritivo. A desserialização requer o schema C# correspondente. Esses tipos existem como representações internas dos binários, mas os tipos não podem ser determinados sem um schema C#.</p><p>O Endian deve ser </code>Little Endian<code>. No entanto, a implementação de referência em C# não se preocupa com endianness, então não pode ser usada em máquinas big-endian. Porém, computadores modernos geralmente são little-endian.</p><p>Existem oito tipos de formato.</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Objeto de Referência Circular</li>
<li>Tupla</li>
<li>Coleção</li>
<li>String</li>
<li>União</li></p><p></ul><h3>Struct não gerenciado</h3></p><p>Struct não gerenciado é uma struct C# que não contém tipos de referência, restrição semelhante à de <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">Tipos não gerenciados do C#</a>. Serializa o layout da struct como está, incluindo preenchimento (padding).</p><h3>Objeto</h3></p><p></code>(byte memberCount, [values...])<code></p><p>O objeto possui 1 byte sem sinal como contagem de membros no cabeçalho. A contagem de membros permite de </code>0<code> a </code>249<code>, </code>255<code> representa que o objeto é </code>null<code>. Os valores armazenam o valor memorypack para o número da contagem de membros.</p><h3>Objeto Tolerante a Versão</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Objeto Tolerante a Versão é semelhante ao Objeto, mas possui o comprimento em bytes dos valores no cabeçalho. varint segue estas especificações: o primeiro sbyte é valor ou typeCode e os próximos X bytes são o valor. 0 a 127 = valor byte sem sinal, -1 a -120 = valor byte com sinal, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Objeto de Referência Circular</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Objeto de Referência Circular é semelhante ao Objeto Tolerante a Versão, mas se memberCount for 250, o próximo varint (uint32 sem sinal) é referenceId. Caso contrário, após o byte-length-of-values, varint referenceId é gravado.</p><h3>Tupla</h3></p><p></code>(values...)<code></p><p>Tupla é uma coleção de valores de tamanho fixo e não anulável. No .NET, </code>KeyValuePair<TKey, TValue><code> e </code>ValueTuple<T,...><code> são serializados como Tupla.</p><h3>Coleção</h3></p><p></code>(int length, [values...])<code></p><p>Coleção possui um inteiro de 4 bytes com sinal como contagem de dados no cabeçalho, </code>-1<code> representa </code>null<code>. Os valores armazenam o valor memorypack para o número do comprimento.</p><h3>String</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>String possui duas formas, UTF16 e UTF8. Se o primeiro inteiro de 4 bytes com sinal for </code>-1<code>, representa nulo. </code>0<code> representa vazio. UTF16 é igual a coleção (serializa como </code>ReadOnlySpan<char><code>, a contagem de bytes do valor utf16 é utf16-length * 2). Se o primeiro inteiro com sinal for <= </code>-2<code>, o valor é codificado por UTF8. utf8-byte-count é codificado em complemento, </code>~utf8-byte-count<code> para recuperar a contagem de bytes. O próximo inteiro com sinal é utf16-length, permitindo </code>-1<code> que representa comprimento desconhecido. utf8-bytes armazena os bytes pelo número de utf8-byte-count.</p><h3>União</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>O primeiro byte sem sinal é a tag para o tipo de valor discriminado ou flag, </code>0<code> a </code>249<code> representa tag, </code>250<code> indica que o próximo unsigned short é tag, </code>255<code> representa que a união é </code>null`.</p><p>Licença
<hr>
Esta biblioteca é licenciada sob a Licença MIT.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>