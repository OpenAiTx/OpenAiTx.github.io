<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Vietnamese. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Vietnamese. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Vietnamese, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Vietnamese. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-vi.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-09-16",
  "dateModified": "2025-09-16"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Vietnamese</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Trình tuần tự hóa nhị phân hiệu năng cực cao không mã hóa cho C# và Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>So sánh với <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Được đo bằng máy .NET 7 / Ryzen 9 5950X. Các serializer này đều có phương thức <code>IBufferWriter<byte></code>, được tuần tự hóa bằng <code>ArrayBufferWriter<byte></code> và tái sử dụng để tránh đo việc sao chép bộ đệm. </blockquote></p><p>Đối với các đối tượng thông thường, MemoryPack nhanh hơn x10 và nhanh hơn x2 ~ x5 so với các serializer nhị phân khác. Đối với mảng struct, MemoryPack còn mạnh mẽ hơn nữa, với tốc độ nhanh hơn x50 ~ x200 so với các serializer khác.</p><p>MemoryPack là trình tuần tự hóa thứ 4 tôi phát triển, trước đây tôi đã tạo ra các serializer nổi tiếng, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. Lý do MemoryPack nhanh là nhờ định dạng nhị phân tối ưu hóa riêng cho C#, và một triển khai được tinh chỉnh dựa trên kinh nghiệm trước đây của tôi. Đây cũng là một thiết kế hoàn toàn mới tận dụng .NET 7, C# 11 và Incremental Source Generator (hỗ trợ .NET Standard 2.1 (.NET 5, 6) và có hỗ trợ Unity).</p><p>Các serializer khác thực hiện nhiều thao tác mã hóa như mã hóa VarInt, tag, chuỗi, v.v. Định dạng MemoryPack sử dụng thiết kế không mã hóa, sao chép càng nhiều bộ nhớ C# càng tốt. Không mã hóa tương tự như FlatBuffers, nhưng không cần kiểu đặc biệt, mục tiêu tuần tự hóa của MemoryPack là POCO.</p><p>Ngoài hiệu năng, MemoryPack còn có các tính năng sau.</p><ul><li>Hỗ trợ các API I/O hiện đại (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Sinh mã dựa trên Source Generator thân thiện với Native AOT, không sử dụng Dynamic CodeGen (IL.Emit)</li>
<li>API không phản xạ, không generic</li>
<li>Khả năng giải tuần tự vào instance đã có sẵn</li>
<li>Tuần tự hóa đa hình (Union)</li>
<li>Hỗ trợ chịu lỗi phiên bản giới hạn (fast/default) và đầy đủ</li>
<li>Tuần tự hóa tham chiếu vòng lặp</li>
<li>Tuần tự hóa luồng dựa trên PipeWriter/Reader</li>
<li>Sinh mã TypeScript và ASP.NET Core Formatter</li>
<li>Hỗ trợ Unity (2021.3) IL2CPP qua .NET Source Generator</li></p><p></ul>Cài đặt
<hr>
Thư viện này được phân phối qua NuGet. Để đạt hiệu năng tốt nhất, khuyến nghị sử dụng <code>.NET 7</code>. Yêu cầu tối thiểu là <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>Ngoài ra trình soạn thảo mã cần hỗ trợ Roslyn 4.3.1, ví dụ Visual Studio 2022 phiên bản 17.3, .NET SDK 6.0.401. Xem chi tiết tại tài liệu <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a>.</p><p>Đối với Unity, yêu cầu và quá trình cài đặt hoàn toàn khác. Xem chi tiết ở mục <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a>.</p><p>Bắt đầu nhanh
<hr>
Định nghĩa một struct hoặc class để tuần tự hóa và gắn thuộc tính <code>[MemoryPackable]</code> cùng từ khóa <code>partial</code>.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>Mã tuần tự hóa được sinh ra bởi tính năng source generator của C# triển khai giao diện <code>IMemoryPackable<T></code>. Trong Visual Studio, bạn có thể xem mã sinh ra bằng tổ hợp phím <code>Ctrl+K, R</code> trên tên lớp và chọn <code>*.MemoryPackFormatter.g.cs</code>.</p><p>Gọi <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> để tuần tự hóa/giải tuần tự một instance đối tượng.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>Phương thức <code>Serialize</code> hỗ trợ kiểu trả về <code>byte[]</code> cũng như có thể tuần tự hóa vào <code>IBufferWriter<byte></code> hoặc <code>Stream</code>. Phương thức <code>Deserialize</code> hỗ trợ <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> và <code>Stream</code>. Ngoài ra còn có các phiên bản không generic.</p><p>Các kiểu được hỗ trợ sẵn
<hr>
Các kiểu này có thể được tuần tự hóa mặc định:</p><ul><li>Kiểu nguyên thủy .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, v.v.)</li>
<li>Kiểu unmanaged (Bất kỳ <code>enum</code>, bất kỳ <code>struct</code> do người dùng định nghĩa không chứa kiểu tham chiếu)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Bộ sưu tập bất biến (<code>ImmutableList<></code>, v.v.) và interface (<code>IImmutableList<></code>, v.v.)</li></p><p></ul>Định nghĩa <code>[MemoryPackable]</code> cho <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> có thể gắn vào bất kỳ <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> và <code>interface</code>. Nếu kiểu là <code>struct</code> hoặc <code>record struct</code> không chứa kiểu tham chiếu (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>) thì mọi annotation bổ sung (bỏ qua, bao gồm, constructor, callback) sẽ không được dùng, sẽ tuần tự hóa/giải tuần tự trực tiếp từ bộ nhớ.</p><p>Ngược lại, mặc định <code>[MemoryPackable]</code> sẽ tuần tự hóa các property hoặc field instance public. Bạn có thể sử dụng <code>[MemoryPackIgnore]</code> để loại khỏi mục tiêu tuần tự hóa, <code>[MemoryPackInclude]</code> để đẩy một thành viên private thành mục tiêu tuần tự hóa.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // các kiểu này được tuần tự hóa mặc định
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // các kiểu này không được tuần tự hóa mặc định
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // dùng [MemoryPackIgnore] để loại public member khỏi tuần tự hóa
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // dùng [MemoryPackInclude] để đưa một thành viên private vào tuần tự hóa
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>Bộ sinh mã của <code>MemoryPack</code> sẽ thêm thông tin về các thành viên được tuần tự hóa vào phần <code><remarks /></code>. Có thể xem bằng cách di chuột lên kiểu với Intellisense.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>Tất cả các thành viên phải có khả năng tuần tự hóa bởi memorypack, nếu không bộ sinh mã sẽ báo lỗi.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack có 35 quy tắc chẩn đoán (<code>MEMPACK001</code> đến <code>MEMPACK035</code>) để định nghĩa một cách thoải mái.</p><p>Nếu kiểu mục tiêu đã có tuần tự hóa MemoryPack định nghĩa bên ngoài và đã đăng ký, sử dụng <code>[MemoryPackAllowSerialize]</code> để tắt cảnh báo chẩn đoán.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>Thứ tự thành viên là <strong>quan trọng</strong>, MemoryPack không tuần tự hóa tên thành viên hay thông tin khác, thay vào đó tuần tự hóa các trường theo thứ tự khai báo. Nếu kiểu kế thừa, tuần tự hóa thực hiện theo thứ tự cha → con. Thứ tự các thành viên không thể thay đổi khi giải tuần tự. Để tiến hóa schema, xem mục <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a>.</p><p>Thứ tự mặc định là tuần tự, nhưng bạn có thể chọn layout rõ ràng với <code>[MemoryPackable(SerializeLayout.Explicit)]</code> và <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// tuần tự hóa Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Lựa chọn constructor</h3></p><p>MemoryPack hỗ trợ cả constructor có tham số và không tham số. Việc lựa chọn constructor tuân theo các quy tắc sau. (Áp dụng cho cả class và struct).</p><ul><li>Nếu có <code>[MemoryPackConstructor]</code>, sẽ sử dụng nó.</li>
<li>Nếu không có constructor rõ ràng (bao gồm cả private), sử dụng constructor không tham số.</li>
<li>Nếu chỉ có một constructor không tham số/ có tham số (bao gồm cả private), sẽ sử dụng nó.</li>
<li>Nếu có nhiều constructor, thuộc tính <code>[MemoryPackConstructor]</code> phải được áp dụng cho constructor mong muốn (bộ sinh mã sẽ không tự động chọn), nếu không sẽ phát sinh lỗi.</li>
<li>Nếu sử dụng constructor có tham số, tất cả tên tham số phải khớp với tên thành viên tương ứng (không phân biệt hoa thường).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // Có thể sử dụng constructor có tham số - tên tham số phải khớp với tên thành viên (không phân biệt hoa thường)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// cũng hỗ trợ record primary constructor
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// Nếu có nhiều constructor, thì nên sử dụng [MemoryPackConstructor]
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>Callback khi tuần tự hóa</h3></p><p>Khi tuần tự hóa/giải tuần tự, MemoryPack có thể gọi một sự kiện trước/sau bằng cách sử dụng các thuộc tính <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Có thể đánh dấu cả phương thức static và instance (không static), cũng như phương thức public và private.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // thứ tự gọi phương thức là static -> instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // cũng cho phép phương thức private
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Lưu ý: phương thức instance với MemoryPackOnDeserializing sẽ không được gọi nếu instance không được truyền bằng <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>Callback cho phép phương thức không tham số và phương thức <code>ref reader/writer, ref T value</code>. Ví dụ, callback ref có thể ghi/đọc header tùy chỉnh trước quá trình tuần tự hóa.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, sử dụng where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // ghi GUID vào header.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // đọc header tùy chỉnh trước khi giải tuần tự
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>Nếu gán giá trị cho <code>ref value</code>, bạn có thể thay đổi giá trị được sử dụng cho quá trình tuần tự hóa/giải tuần tự. Ví dụ, khởi tạo từ ServiceProvider.</p><pre><code class="language-csharp">// trước khi sử dụng formatter này, đặt ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>Định nghĩa collection tùy chỉnh
<hr>
Theo mặc định, kiểu được đánh dấu <code>[MemoryPackObject]</code> sẽ cố gắng tuần tự hóa các thành viên của nó. Tuy nhiên, nếu một kiểu là collection (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), hãy sử dụng <code>GenerateType.Collection</code> để tuần tự hóa chính xác.</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Static constructor
<hr>
Lớp MemoryPackable không thể định nghĩa static constructor vì partial class được sinh ra sẽ sử dụng nó. Thay vào đó, bạn có thể định nghĩa một <code>static partial void StaticConstructor()</code> để thực hiện cùng chức năng.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Đa hình (Union)
<hr>
MemoryPack hỗ trợ tuần tự hóa các object của interface và abstract class để phục vụ tuần tự hóa đa hình. Trong MemoryPack, tính năng này được gọi là Union. Chỉ interface và abstract class mới được phép đánh dấu thuộc tính <code>[MemoryPackUnion]</code>. Tag của union phải là duy nhất.</p><pre><code class="language-csharp">// Đánh dấu [MemoryPackable] và các kiểu kế thừa với [MemoryPackUnion]
// Union cũng hỗ trợ abstract class
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Tuần tự hóa dưới dạng kiểu interface.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Giải tuần tự dưới dạng kiểu interface.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p><code>tag</code> cho phép giá trị từ <code>0</code> ~ <code>65535</code>, đặc biệt hiệu quả với giá trị nhỏ hơn <code>250</code>.
<pre><code class="language-">Nếu một interface và các kiểu dẫn xuất nằm ở các assembly khác nhau, bạn có thể sử dụng <code>MemoryPackUnionFormatterAttribute</code> thay thế. Các formatter được sinh ra sẽ tự động được đăng ký thông qua <code>ModuleInitializer</code> trong C# 9.0 trở lên.</p><blockquote>Lưu ý rằng <code>ModuleInitializer</code> không được hỗ trợ trong Unity, do đó formatter phải được đăng ký thủ công. Để đăng ký union formatter của bạn, hãy gọi <code>{tên union formatter của bạn}Initializer.RegisterFormatter()</code> một cách thủ công trong Startup. Ví dụ <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB định nghĩa formatter bên ngoài kiểu mục tiêu
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
Union có thể được lắp ráp trong code thông qua <code>DynamicUnionFormatter<T></code>.
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
Serialize API
<hr>
<code>Serialize</code> có ba overload.
</code></pre>csharp
// API không generic cũng có sẵn, phiên bản này tham số đầu tiên là Type và value là object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
Để đạt hiệu suất tốt nhất, nên sử dụng API với <code>BufferWriter</code>. API này sẽ serialize trực tiếp vào buffer. Có thể áp dụng với <code>PipeWriter</code> trong <code>System.IO.Pipelines</code>, <code>BodyWriter</code> trong ASP .NET Core, v.v.</p><p>Nếu cần một <code>byte[]</code> (ví dụ <code>RedisValue</code> trong <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), API trả về <code>byte[]</code> rất đơn giản và gần như nhanh tương đương.</p><p>Lưu ý rằng <code>SerializeAsync</code> cho <code>Stream</code> chỉ thực sự bất đồng bộ khi Flush; nó serialize tất cả vào buffer nội bộ của MemoryPack rồi mới ghi bằng <code>WriteAsync</code>. Do đó, overload <code>BufferWriter</code> cho phép tách biệt và kiểm soát buffer và flush sẽ tốt hơn.</p><p>Nếu bạn muốn thực hiện ghi streaming hoàn chỉnh, xem phần <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> cấu hình việc chuỗi ký tự được serialize ở dạng UTF16 hay UTF8. Có thể cấu hình bằng cách truyền <code>MemoryPackSerializerOptions.Utf8</code> cho mã hóa UTF8, <code>MemoryPackSerializerOptions.Utf16</code> cho mã hóa UTF16 hoặc <code>MemoryPackSerializerOptions.Default</code> (mặc định là UTF8). Truyền null hoặc dùng tham số mặc định sẽ dùng mã hóa UTF8.</p><p>Vì biểu diễn chuỗi nội bộ của C# là UTF16 nên UTF16 cho hiệu suất tốt hơn. Tuy nhiên, payload thường lớn hơn; với UTF8, chuỗi ASCII chỉ chiếm một byte, còn UTF16 là hai byte. Do sự khác biệt kích thước payload này khá lớn nên mặc định là UTF8.</p><p>Nếu dữ liệu là non-ASCII (ví dụ tiếng Nhật có thể hơn 3 byte và UTF8 sẽ lớn hơn), hoặc nếu bạn cần nén riêng, UTF16 có thể cho kết quả tốt hơn.</p><p>Dù có thể chọn UTF8 hoặc UTF16 khi serialize, khi deserialize không cần chỉ định; sẽ tự động phát hiện và giải mã bình thường.</p><p>Ngoài ra, bạn có thể get/set <code>IServiceProvider? ServiceProvider { get; init; }</code> từ options. Điều này hữu ích để lấy DI object (như <code>ILogger<T></code>) từ quá trình serialization (<code>MemoryPackReader/MemoryPackWriter</code> có thuộc tính .Options).</p><p>Deserialize API
<hr>
<code>Deserialize</code> có overload cho <code>ReadOnlySpan<byte></code> và <code>ReadOnlySequence<byte></code>, <code>Stream</code> và hỗ trợ <code>ref</code>.
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
Overload <code>ref</code> sẽ ghi đè lên instance hiện có, chi tiết xem phần <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a>.</p><p><code>DeserializeAsync(Stream)</code> không phải là một thao tác đọc streaming hoàn chỉnh, đầu tiên nó đọc vào pool nội bộ của MemoryPack đến hết stream, sau đó mới giải mã.</p><p>Nếu bạn muốn thực hiện đọc streaming hoàn chỉnh, xem phần <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><p>Overwrite
<hr>
Để giảm việc cấp phát bộ nhớ, MemoryPack hỗ trợ deserialize vào một instance đã có sẵn, ghi đè lên nó. Có thể sử dụng với overload <code>Deserialize(ref T? value)</code>.
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// ghi đè dữ liệu lên instance đã có
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack sẽ cố gắng ghi đè tối đa có thể, nhưng nếu các điều kiện sau không thỏa mãn thì sẽ tạo instance mới (như deserialization thông thường).</p><ul><li>ref value (bao gồm các thành viên trong object graph) là null, thì tạo instance mới</li>
<li>chỉ cho phép constructor không tham số, nếu dùng constructor có tham số sẽ tạo instance mới</li>
<li>nếu value là <code>T[]</code>, chỉ reuse nếu độ dài giống nhau, ngược lại sẽ tạo instance mới</li>
<li>nếu value là collection có phương thức <code>.Clear()</code> (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>) sẽ gọi Clear() và reuse, ngược lại tạo instance mới</li></p><p></ul>Version tolerant
<hr>
Ở mặc định (<code>GenerateType.Object</code>), MemoryPack hỗ trợ tiến hóa schema ở mức giới hạn.</p><ul><li>unmanaged struct không thể thay đổi nữa</li>
<li>có thể thêm thành viên, nhưng không được xóa</li>
<li>có thể đổi tên thành viên</li>
<li>không thể thay đổi thứ tự thành viên</li>
<li>không thể thay đổi kiểu thành viên</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Thêm thành viên thì OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// Xóa thành viên thì KHÔNG được.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Đổi thứ tự thì KHÔNG được.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
Trong trường hợp sử dụng, việc lưu dữ liệu cũ (vào file, redis, v.v...) và đọc bằng schema mới luôn OK. Với RPC, schema tồn tại cả phía client và server, client phải được cập nhật trước server. Client đã cập nhật sẽ không gặp vấn đề khi kết nối với server cũ, nhưng client cũ không thể kết nối server mới.</p><p>Theo mặc định, khi dữ liệu cũ đọc bằng schema mới, các thành viên không có trong dữ liệu sẽ được khởi tạo với literal <code>default</code>.
Nếu bạn muốn tránh điều này và sử dụng giá trị khởi tạo của field/property, có thể dùng <code>[SuppressDefaultInitialization]</code>.
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < nếu dữ liệu cũ thiếu, sẽ set <code>111</code>.
    
    public int Prop3 { get; set; } = 222; // < nếu dữ liệu cũ thiếu, sẽ set <code>default</code>.
}
<pre><code class="language-">
 <code>[SuppressDefaultInitialization]</code> có các hạn chế sau:
<ul><li>Không được dùng với readonly, init-only, và required modifier.</li></p><p></ul>Phần tiếp theo <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> sẽ hướng dẫn cách kiểm tra sự thay đổi schema, ví dụ bằng CI, để tránh sự cố.</p><p>Khi sử dụng <code>GenerateType.VersionTolerant</code>, sẽ hỗ trợ version-tolerant hoàn chỉnh.</p><ul><li>unmanaged struct không thể thay đổi nữa</li>
<li>tất cả thành viên phải thêm <code>[MemoryPackOrder]</code> rõ ràng (trừ khi dùng <code>SerializeLayout.Sequential</code>)</li>
<li>có thể thêm, xóa thành viên nhưng không được reuse order (có thể bỏ qua order bị thiếu)</li>
<li>có thể đổi tên thành viên</li>
<li>không thể thay đổi thứ tự thành viên</li>
<li>không thể thay đổi kiểu thành viên</li>
</ul></code></pre>csharp
// Có thể serialize/deserialize cả hai chiều
// VersionTolerantObject1 -> VersionTolerantObject2 và 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// đã xóa
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// đã thêm
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// Nếu đặt SerializeLayout.Sequential một cách tường minh, sẽ cho phép tự động sắp xếp thứ tự.
// Tuy nhiên, không thể xóa bất kỳ thành viên nào đối với version-tolerant.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> chậm hơn <code>GenerateType.Object</code> khi tuần tự hóa. Ngoài ra, kích thước payload sẽ hơi lớn hơn một chút.</p><p>Thông tin tuần tự hóa
----
Bạn có thể kiểm tra trong IntelliSense các thành viên nào của kiểu dữ liệu được tuần tự hóa. Có một tùy chọn để ghi thông tin đó ra file khi biên dịch. Thiết lập <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> như sau.</p><pre><code class="language-xml"><!-- xuất thông tin tuần tự hóa memorypack ra thư mục -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>Thông tin sau sẽ được ghi vào file.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>Nếu kiểu là unmanaged, sẽ hiển thị <code>unmanaged</code> trước tên kiểu.</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>Bằng cách kiểm tra sự khác biệt trong file này, có thể ngăn chặn các thay đổi schema nguy hiểm. Ví dụ, bạn có thể sử dụng CI để phát hiện các quy tắc sau</p><ul><li>chỉnh sửa kiểu unmanaged</li>
<li>thay đổi thứ tự thành viên</li>
<li>xóa thành viên</li></p><p></ul>Tham chiếu vòng lặp (Circular Reference)
<hr>
MemoryPack cũng hỗ trợ tham chiếu vòng lặp. Điều này cho phép các đối tượng dạng cây được tuần tự hóa giữ nguyên cấu trúc.</p><pre><code class="language-csharp">// để bật circular-reference, sử dụng GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p> Ví dụ, đoạn code <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> sẽ trở thành như sau.</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> có đặc điểm tương tự version-tolerant. Tuy nhiên, như một ràng buộc bổ sung, chỉ được phép sử dụng constructor không tham số. Ngoài ra, việc theo dõi tham chiếu đối tượng chỉ được thực hiện cho các đối tượng được đánh dấu với <code>GenerateType.CircularReference</code>. Nếu bạn muốn theo dõi đối tượng khác, hãy bọc nó lại.</p><p>CustomFormatter
<hr>
Nếu triển khai <code>MemoryPackCustomFormatterAttribute<T></code> hoặc <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (hiệu năng cao hơn, nhưng phức tạp hơn), bạn có thể cấu hình để sử dụng custom formatter cho thành viên của MemoryPackObject.</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack cung cấp các thuộc tính định dạng sau: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // tuần tự hóa thành viên này dưới dạng UTF16 String, hiệu năng cao hơn UTF8 nhưng với ASCII thì kích thước lớn hơn (nhưng với non-ASCII, đôi khi lại nhỏ hơn).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // Khi giải tuần tự, Dictionary được khởi tạo với StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // Khi giải tuần tự, tất cả chuỗi đều được intern (xem: String.Intern). Nếu giá trị tương tự lặp lại nhiều, sẽ tiết kiệm bộ nhớ.
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>Để cấu hình equality comparer cho set/dictionary, tất cả các formatter tích hợp sẵn đều có overload constructor với comparer. Bạn có thể dễ dàng tạo custom equality-comparer formatter.</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> chỉ nén các kiểu <code>bool[]</code>. Thông thường <code>bool[]</code> được tuần tự hóa với 1 byte cho mỗi giá trị boolean, nhưng <code>BitPackFormatter</code> sẽ tuần tự hóa <code>bool[]</code> như <code>BitArray</code> lưu mỗi bool chỉ 1 bit. Khi dùng <code>BitPackFormatter</code>, 8 giá trị bool chỉ tốn 1 byte thay vì 8 byte, giảm kích thước đi 8 lần.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> dùng cho <code>byte[]</code>, ví dụ bạn có thể nén payload lớn bằng Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> dùng cho <code>string</code>, tuần tự hóa chuỗi đã nén (UTF16) bằng Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre></p><p><code>BrotliFormatter<T></code> dành cho bất kỳ kiểu dữ liệu nào, dữ liệu được nén bằng Brotli khi tuần tự hóa. Nếu kiểu dữ liệu là <code>byte[]</code> hoặc <code>string</code>, bạn nên sử dụng <code>BrotliFormatter</code> hoặc <code>BrotliStringFormatter</code> để đạt hiệu năng tốt nhất.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}</code></pre></p><p>Giải tuần tự với array pooling
<hr>
Để giải tuần tự một mảng lớn (bất kỳ kiểu <code>T</code> nào), MemoryPack cung cấp nhiều phương pháp pooling hiệu quả. Cách hiệu quả nhất là sử dụng chức năng <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a>. Đặc biệt, <code>List<T></code> luôn được tái sử dụng.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> được tái sử dụng, không cấp phát bộ nhớ mới khi giải tuần tự.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// để vận hành hiệu quả, bạn có thể lấy Span<T> bằng CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);</code></pre></p><p>Một cách tiện lợi là giải tuần tự vào một ArrayPool tại thời điểm giải tuần tự. MemoryPack cung cấp <code>MemoryPoolFormatter<T></code> và <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // Bạn phải tự viết mã trả về, đây là ví dụ.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // thực hiện các thao tác...
}   // trả lại ArrayPool</code></pre></p><p>Hiệu năng
<hr>
Xem bài viết trên blog của tôi <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Kích thước payload và nén
<hr>
Kích thước payload phụ thuộc vào giá trị mục tiêu; không giống JSON, không có khóa và là định dạng nhị phân, do đó kích thước payload thường nhỏ hơn JSON.</p><p>Với các định dạng mã hóa varint như MessagePack và Protobuf, MemoryPack thường lớn hơn nếu sử dụng nhiều kiểu int (trong MemoryPack, int luôn chiếm 4 byte do mã hóa kích thước cố định, trong khi MessagePack là 1~5 byte).</p><p>float và double lần lượt là 4 byte và 8 byte trong MemoryPack, nhưng là 5 byte và 9 byte trong MessagePack. Do đó, MemoryPack nhỏ hơn, ví dụ với mảng Vector3 (float, float, float).</p><p>Chuỗi mặc định là UTF8, giống như các serializer khác, nhưng nếu chọn tùy chọn UTF16 thì sẽ có tính chất khác biệt.</p><p>Trong mọi trường hợp, nếu kích thước payload lớn, nên cân nhắc nén. Khuyến nghị sử dụng LZ4, ZStandard hoặc Brotli.</p><h3>Nén</h3></p><p>MemoryPack cung cấp tiện ích hiệu quả cho nén <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> thông qua <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> và <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. <code>BrotliCompressor</code> và <code>BrotliDecompressor</code> của MemoryPack cung cấp nén/giải nén tối ưu cho hành vi nội bộ của MemoryPack.</p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Nén (cần using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Lấy mảng byte[] đã nén
var compressedBytes = compressor.ToArray();</p><p>// Hoặc ghi vào IBufferWriter<byte> khác (ví dụ PipeWriter)
compressor.CopyTo(response.BodyWriter);</code></pre></p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Giải nén (cần using)
using var decompressor = new BrotliDecompressor();</p><p>// Lấy ReadOnlySequence<byte> đã giải nén từ ReadOnlySpan<byte> hoặc ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);</code></pre></p><p>Cả <code>BrotliCompressor</code> và <code>BrotliDecompressor</code> đều là struct, không cấp phát bộ nhớ trên heap. Cả hai lưu trữ dữ liệu đã nén hoặc giải nén trong một memory pool nội bộ cho Serialize/Deserialize. Do đó, cần giải phóng memory pooling, đừng quên sử dụng <code>using</code>.</p><p>Mức độ nén rất quan trọng. Mặc định là quality-1 (CompressionLevel.Fastest), khác với mặc định của .NET (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) sẽ gần với tốc độ của <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, nhưng quality-4 thì chậm hơn nhiều. Điều này rất quan trọng trong kịch bản sử dụng serializer. Hãy cẩn thận khi sử dụng <code>BrotliStream</code> chuẩn (mặc định là quality-4). Trong mọi trường hợp, tốc độ nén/giải nén và kích thước sẽ rất khác nhau tùy vào dữ liệu. Vui lòng chuẩn bị dữ liệu phù hợp với ứng dụng của bạn và tự kiểm tra.</p><p>Lưu ý có sự chênh lệch tốc độ nhiều lần giữa MemoryPack không nén và MemoryPack có nén Brotli.</p><p>Brotli cũng được hỗ trợ trong custom formatter. <code>BrotliFormatter</code> có thể nén một thành viên cụ thể.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p>Tuần tự hóa các kiểu external
<hr>
Nếu bạn muốn tuần tự hóa các kiểu external, bạn có thể tạo custom formatter và đăng ký vào provider, xem <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> để biết chi tiết. Tuy nhiên, việc tạo custom formatter là khó. Do đó, chúng tôi khuyến nghị tạo một kiểu wrapper. Ví dụ, nếu bạn muốn tuần tự hóa một kiểu external tên là <code>AnimationCurve</code>.</p><pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}</code></pre></p><p>Kiểu cần wrap là public, nhưng được loại trừ khỏi tuần tự hóa (<code>MemoryPackIgnore</code>). Các thuộc tính cần tuần tự hóa là private, nhưng được đưa vào (<code>MemoryPackInclude</code>). Nên chuẩn bị hai mẫu constructor. Constructor dùng cho serializer nên là private.</p><p>Tuy nhiên, như vậy thì mỗi lần đều phải wrap, khá bất tiện. Ngoài ra, struct wrapper không thể biểu diễn null. Do đó, hãy tạo một custom formatter.</p><pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity không hỗ trợ scoped và TBufferWriter nên cần đổi chữ ký thành <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)</code></pre>csharp
{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
<pre><code class="language-">
Cuối cùng, đăng ký formatter trong phần khởi động.
</code></pre>csharp
MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());
<pre><code class="language-">> Lưu ý: AnimationCurve của Unity mặc định đã có thể tuần tự hóa nên không cần formatter tùy chỉnh này cho AnimationCurve</p><p>Các gói (Packages)
<hr>
MemoryPack có các gói sau.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> là thư viện chính, cung cấp đầy đủ hỗ trợ cho việc tuần tự hóa và giải tuần tự hóa nhị phân hiệu năng cao. Thư viện này phụ thuộc vào <code>MemoryPack.Core</code> cho các thư viện cơ bản và <code>MemoryPack.Generator</code> cho việc sinh mã. <code>MemoryPack.Streaming</code> bổ sung các phần mở rộng cho <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.  <code>MemoryPack.AspNetCoreMvcFormatter</code> thêm các input/output formatter cho ASP.NET Core. <code>MemoryPack.UnityShims</code> bổ sung các loại shim và formatter cho Unity để chia sẻ kiểu giữa .NET và Unity.</p><p>TypeScript và ASP.NET Core Formatter
<hr>
MemoryPack hỗ trợ sinh mã TypeScript. Nó sinh class và mã tuần tự hóa từ C#, nói cách khác, bạn có thể chia sẻ kiểu dữ liệu với trình duyệt mà không cần dùng OpenAPI, proto, v.v.</p><p>Việc sinh mã tích hợp với Source Generator, các tùy chọn sau (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) sẽ thiết lập thư mục xuất mã TypeScript. Mã runtime sẽ được xuất đồng thời, vì vậy không cần thêm bất kỳ phụ thuộc nào khác.
</code></pre>xml
<!-- xuất mã memorypack TypeScript vào thư mục -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
Một kiểu MemoryPackable C# phải được gắn chú thích <code>[GenerateTypeScript]</code>.
</code></pre>csharp
[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}
<pre><code class="language-">
Mã runtime và kiểu TypeScript sẽ được sinh ra trong thư mục đích.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>Mã được sinh ra như sau, với các trường đơn giản và các phương thức tĩnh cho serialize/serializeArray và deserialize/deserializeArray.
</code></pre>typescript
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
<pre><code class="language-">
Bạn có thể sử dụng kiểu này như sau.
</code></pre>typescript
let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// tuần tự hóa thành Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// giải tuần tự từ ArrayBuffer 
let person2 = Person.deserialize(buffer);
<pre><code class="language-">
Gói <code>MemoryPack.AspNetCoreMvcFormatter</code> bổ sung input và output formatter <code>MemoryPack</code> cho ASP.NET Core MVC. Bạn có thể thêm <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> vào ASP.NET Core MVC với đoạn mã sau.
</code></pre>csharp
var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Nếu checkContentType: true thì có thể output nhiều định dạng (JSON/MemoryPack, v.v...). Mặc định là false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
<pre><code class="language-">
Nếu bạn gọi từ HttpClient, bạn có thể thiết lập <code>application/x-memorypack</code> cho content-header.
</code></pre>csharp
var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");
<pre><code class="language-">
<h3>Ánh xạ kiểu TypeScript</h3></p><p>Có một vài hạn chế về các kiểu có thể sinh ra. Trong các kiểu nguyên thủy, <code>char</code> và <code>decimal</code> không được hỗ trợ. Ngoài ra, không thể sử dụng kiểu OpenGenerics.</p><p>|  C#  |  TypeScript  | Mô tả |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</code></pre>
| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | Trong TypeScript, thể hiện dưới dạng chuỗi nhưng tuần tự hóa/giải tuần tự dưới dạng nhị phân 16 byte
| <code>DateTime</code> | <code>Date</code> | DateTimeKind sẽ bị bỏ qua
| <code>enum</code> | <code>const enum</code> | Kiểu nền <code>long</code> và <code>ulong</code> không được hỗ trợ
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Hỗ trợ tất cả các kiểu triển khai <code>ICollection<T></code> như <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Hỗ trợ tất cả các kiểu triển khai <code>ISet<T></code> như <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Hỗ trợ tất cả các kiểu triển khai <code>IDictionary<K,V></code> như <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Chỉ hỗ trợ class
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> chỉ có thể áp dụng cho class và hiện tại chưa hỗ trợ cho struct.</p><h3>Cấu hình phần mở rộng file import và kiểu đặt tên thành viên</h3></p><p>Mặc định, MemoryPack tạo phần mở rộng file là <code>.js</code> như <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. Nếu bạn muốn thay đổi phần mở rộng khác hoặc để trống, hãy sử dụng <code>MemoryPackGenerator_TypeScriptImportExtension</code> để cấu hình.
Ngoài ra, tên thành viên sẽ tự động được chuyển sang camelCase. Nếu bạn muốn giữ nguyên tên gốc, đặt <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> thành <code>false</code>.</p><pre><code class="language-xml"><ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- cho phép để trống -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- mặc định là true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- mặc định là false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup></code></pre></p><p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> cho phép chú thích nullable của C# được phản ánh vào mã TypeScript. Mặc định là false, làm cho mọi thứ đều có thể null.</p><p>Streaming Serialization
<hr>
<code>MemoryPack.Streaming</code> cung cấp <code>MemoryPackStreamingSerializer</code>, bổ sung hỗ trợ cho việc tuần tự hóa và giải tuần tự hóa các collection với stream.</p><pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}</code></pre></p><p>Formatter/Provider API
<hr>
Nếu bạn muốn tự triển khai formatter, kế thừa <code>MemoryPackFormatter<T></code> và override các phương thức <code>Serialize</code> và <code>Deserialize</code>.</p><pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // sử dụng phương thức của writer.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // sử dụng phương thức của reader.
    }
}</code></pre>
Formatter vừa tạo sẽ được đăng ký với <code>MemoryPackFormatterProvider</code>.</p><pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());</code></pre></p><p>Lưu ý: <code>unmanged struct</code> (không chứa kiểu tham chiếu) không thể sử dụng custom formatter, nó luôn tuần tự hóa theo cấu trúc bộ nhớ gốc.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
Khởi tạo <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> cần OptionalState. Đây là wrapper của <code>MemoryPackSerializerOptions</code>, có thể tạo từ <code>MemoryPackWriterOptionalStatePool</code>.</p><pre><code class="language-csharp">// khi dispose, OptionalState sẽ trả về pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// cho Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}</code></pre></p><p>Phụ thuộc framework mục tiêu
<hr>
MemoryPack cung cấp <code>netstandard2.1</code> và <code>net7.0</code> nhưng cả hai không tương thích với nhau. Ví dụ, các kiểu MemoryPackable dưới project <code>netstandard2.1</code> và sử dụng từ project <code>net7.0</code> sẽ ném ra ngoại lệ runtime như sau</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Vì net7.0 sử dụng static abstract members (<code>Virtual static method</code>), điều này không được hỗ trợ bởi netstandard2.1, đây là hành vi theo đặc tả.</p><p>Project .NET 7 không nên sử dụng dll netstandard 2.1. Nói cách khác, nếu ứng dụng là dự án .NET 7, tất cả các phụ thuộc sử dụng MemoryPack phải hỗ trợ .NET 7. Vì vậy, nếu nhà phát triển thư viện phụ thuộc vào MemoryPack, bạn cần cấu hình dual target framework.</p><pre><code class="language-xml"><TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks></code></pre></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> là framework grpc-dotnet code-first sử dụng MessagePack thay vì protobuf. MagicOnion hiện đã hỗ trợ MemoryPack như một lớp tuần tự hóa qua package <code>MagicOnion.Serialization.MemoryPack</code> (bản preview). Xem chi tiết: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>Phiên bản Unity tối thiểu được hỗ trợ là <code>2022.3.12f1</code>.</p><p>Gói core <code>MemoryPack</code> được cung cấp qua nuget. Nó cũng có sẵn cho Unity. Nếu bạn muốn có hỗ trợ kiểu dựng sẵn của Unity, chúng tôi còn cung cấp thêm extension MemoryPack.Unity.</p><ul><li>Cài đặt <code>MemoryPack</code> từ NuGet bằng <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Mở cửa sổ từ NuGet -> Manage NuGet Packages, tìm kiếm "MemoryPack" và nhấn Install.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>Nếu bạn gặp lỗi conflict version, vui lòng tắt xác thực version trong Player Settings (Edit -> Project Settings -> Player -> Kéo xuống và mở rộng "Other Settings" sau đó bỏ chọn "Assembly Version Validation" trong phần "Configuration").</li></p><p><li>Cài đặt package <code>MemoryPack.Unity</code> bằng cách tham chiếu git URL</li></p><p><li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack sử dụng tag phát hành <em>.</em>.*, bạn có thể chỉ định phiên bản như #1.0.0. Ví dụ: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p><p>
Tương tự phiên bản .NET, mã được sinh bởi code generator (<code>MemoryPack.Generator.dll</code>). Triển khai không dùng reflection cũng mang lại hiệu năng tốt nhất cho IL2CPP.</p><p>Để biết thêm thông tin về Unity và Source Generator, vui lòng tham khảo <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">Unity documentation</a>.</p><p>Source Generator cũng được Unity sử dụng chính thức qua <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> và <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. Nói cách khác, đây là tiêu chuẩn cho sinh mã trong Unity thế hệ kế tiếp.</p><p>Bạn có thể tuần tự hóa tất cả các kiểu unmanaged (như <code>Vector3</code>, <code>Rect</code>, v.v...) và một số class (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>). Nếu bạn muốn tuần tự hóa các kiểu đặc thù khác của Unity, xem phần <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a>.</p><p>Về hiệu năng Unity, MemoryPack nhanh hơn JsonUtility khoảng x3~x10 lần.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>Nếu mã dùng chung có kiểu của Unity (<code>Vector2</code>, v.v...), MemoryPack cung cấp gói <code>MemoryPack.UnityShims</code> trên NuGet.</p><p>Gói <code>MemoryPack.UnityShims</code> cung cấp các shim cho các struct chuẩn của Unity (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) và một số class (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p><blockquote>[!WARNING]</blockquote>
<blockquote>Hiện tại có các giới hạn sau khi sử dụng trong Unity</blockquote></p><ul><li>Phiên bản Unity không hỗ trợ CustomFormatter.</li>
<li>Nếu bạn đang sử dụng .NET7 trở lên, định dạng nhị phân của MemoryPack không hoàn toàn tương thích với Unity.</li>
    <li>Vấn đề này xảy ra với các kiểu value mà <code>[StructLayout(LayoutKind.Auto)]</code> được chỉ định rõ ràng. (Mặc định cho struct là <code>LayoutKind.Sequencial</code>.) Với các kiểu này, nhị phân được tuần tự hóa trong .NET sẽ không giải tuần tự được ở Unity. Tương tự, nhị phân tuần tự hóa ở Unity sẽ không tuần tự hóa được ở phía .NET.</li>
    <li>Các kiểu bị ảnh hưởng thường bao gồm những kiểu sau.</li>
        <li><code>DateTimeOffset</code></li>
        <li><code>ValueTuple</code></li>
    <li>Hiện tại, giải pháp đơn giản là không sử dụng các kiểu này.</li></p><p>
</ul>Native AOT
<hr>
Đáng tiếc, .NET 7 Native AOT sẽ gây crash (<code>Generic virtual method pointer lookup failure</code>) khi sử dụng MemoryPack do bug runtime. 
Sẽ được sửa trong .NET 8. Sử dụng bản preview của `<code>Microsoft.DotNet.ILCompiler</code><code> sẽ khắc phục trên .NET 7. Vui lòng xem <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">bình luận của issue</a> để biết cách thiết lập.</p><p>Đặc tả định dạng nhị phân wire
<hr>
Kiểu </code>T<code> được định nghĩa trong </code>Serialize<T><code> và </code>Deserialize<T><code> được gọi là schema C#. Định dạng MemoryPack không phải là định dạng tự mô tả. Giải tuần tự hóa cần schema C# tương ứng. Các kiểu này tồn tại như biểu diễn nội bộ của nhị phân, nhưng không thể xác định kiểu nếu không có schema C#.</p><p>Endian phải là </code>Little Endian<code>. Tuy nhiên, bản C# tham chiếu không quan tâm đến endianness nên không thể dùng trên máy big-endian. Tuy nhiên, các máy tính hiện đại thường là little-endian.</p><p>Có tám loại định dạng.</p><ul><li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Đối tượng Tham chiếu Vòng lặp (Circular Reference Object)</li>
<li>Tuple</li>
<li>Collection</li>
<li>Chuỗi (String)</li>
<li>Union</li></p><p></ul><h3>struct không quản lý (Unmanaged struct)</h3></p><p>Unmanaged struct là struct trong C# không chứa các kiểu tham chiếu, có ràng buộc tương tự như <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">kiểu không quản lý trong C#</a>. Việc tuần tự hóa sẽ giữ nguyên bố cục struct, bao gồm cả phần đệm (padding).</p><h3>Đối tượng (Object)</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Đối tượng có 1 byte không dấu ở phần đầu để biểu diễn số lượng thành viên. Số lượng thành viên cho phép từ </code>0<code> đến </code>249<code>, </code>255<code> biểu diễn đối tượng là </code>null<code>. Các giá trị lưu trữ giá trị memorypack cho số lượng thành viên tương ứng.</p><h3>Đối tượng chịu được phiên bản (Version Tolerant Object)</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Đối tượng chịu được phiên bản tương tự như Đối tượng nhưng có thêm chiều dài tính theo byte của các giá trị ở phần header. varint tuân theo quy tắc sau: sbyte đầu tiên là giá trị hoặc typeCode, và X byte tiếp theo là giá trị. 0 đến 127 = giá trị unsigned byte, -1 đến -120 = giá trị signed byte, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Đối tượng Tham chiếu Vòng lặp (Circular Reference Object)</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Đối tượng Tham chiếu Vòng lặp tương tự như Đối tượng chịu được phiên bản, nhưng nếu memberCount là 250, varint(unsigned-int32) tiếp theo là referenceId. Nếu không, sau phần byte-length-of-values, varint referenceId sẽ được ghi.</p><h3>Tuple</h3></p><p></code>(values...)<code></p><p>Tuple là một tập hợp giá trị cố định, không thể là null. Trong .NET, </code>KeyValuePair<TKey, TValue><code> và </code>ValueTuple<T,...><code> được tuần tự hóa dưới dạng Tuple.</p><h3>Collection</h3></p><p></code>(int length, [values...])<code></p><p>Collection có một số nguyên 4 byte có dấu ở phần header đại diện cho số lượng dữ liệu, </code>-1<code> biểu diễn </code>null<code>. Các giá trị lưu trữ giá trị memorypack cho số lượng phần tử tương ứng với length.</p><h3>Chuỗi (String)</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>Chuỗi có hai dạng, UTF16 và UTF8. Nếu số nguyên 4 byte đầu tiên là </code>-1<code>, biểu diễn null. </code>0<code>, biểu diễn chuỗi rỗng. UTF16 giống như collection (tuần tự hóa như </code>ReadOnlySpan<char><code>, số byte của utf16-value là utf16-length * 2). Nếu số nguyên đầu tiên <= </code>-2<code>, giá trị được mã hóa bằng UTF8. utf8-byte-count được mã hóa ở dạng bù, sử dụng </code>~utf8-byte-count<code> để lấy số byte. Số nguyên tiếp theo là utf16-length, cho phép giá trị </code>-1<code> để biểu diễn độ dài không xác định. utf8-bytes lưu trữ các byte với số lượng là utf8-byte-count.</p><h3>Union</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>Byte không dấu đầu tiên là tag dùng cho kiểu giá trị phân biệt hoặc cờ, </code>0<code> đến </code>249<code> biểu diễn tag, </code>250<code> biểu diễn unsigned short tiếp theo là tag, </code>255<code> biểu diễn union là </code>null`.</p><p>Giấy phép
<hr>
Thư viện này được cấp phép theo Giấy phép MIT.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-09-16 
    </div>
    
</body>
</html>