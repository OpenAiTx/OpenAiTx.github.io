<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Read MemoryPack documentation in Italian. This project has 3835 stars on GitHub.</title>
    <meta name="description" content="Read MemoryPack documentation in Italian. This project has 3835 stars on GitHub.">
    <meta name="keywords" content="MemoryPack, Italian, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "MemoryPack",
  "description": "Read MemoryPack documentation in Italian. This project has 3835 stars on GitHub.",
  "author": {
    "@type": "Person",
    "name": "Cysharp"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 3835
  },
  "url": "https://OpenAiTx.github.io/projects/Cysharp/MemoryPack/README-it.html",
  "sameAs": "https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md",
  "datePublished": "2025-07-24",
  "dateModified": "2025-07-24"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/Cysharp/MemoryPack" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    MemoryPack
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 3835 stars</span>
                <span class="language">Italian</span>
                <span>by Cysharp</span>
            </div>
        </div>
        
        <div class="content">
            <h1>MemoryPack</h1></p><p><a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a>
<a href="https://github.com/Cysharp/MemoryPack/actions" target="_blank" rel="noopener noreferrer"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a>
<a href="https://github.com/Cysharp/MemoryPack/releases" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p><p>Serializer binario a prestazioni estreme con zero encoding per C# e Unity.</p><p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p><blockquote>Confrontato con <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json" target="_blank" rel="noopener noreferrer">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net" target="_blank" rel="noopener noreferrer">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/" target="_blank" rel="noopener noreferrer">Orleans.Serialization</a>. Misurato su macchina .NET 7 / Ryzen 9 5950X. Questi serializer hanno il metodo <code>IBufferWriter<byte></code>, serializzato usando <code>ArrayBufferWriter<byte></code> e riutilizzato per evitare la misurazione della copia del buffer.</blockquote></p><p>Per gli oggetti standard, MemoryPack è x10 più veloce e da x2 a x5 più veloce rispetto ad altri serializer binari. Per array di struct, MemoryPack è ancora più potente, con velocità fino a x50 ~ x200 rispetto agli altri serializer.</p><p>MemoryPack è il mio quarto serializer, precedentemente ho creato serializer ben noti, ~~<a href="https://github.com/neuecc/ZeroFormatter" target="_blank" rel="noopener noreferrer">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json" target="_blank" rel="noopener noreferrer">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp" target="_blank" rel="noopener noreferrer">MessagePack for C#</a>. Il motivo della velocità di MemoryPack è dovuto al suo formato binario specifico e ottimizzato per C# e a un'implementazione ben calibrata basata sulla mia esperienza passata. È anche un design completamente nuovo che utilizza .NET 7 e C# 11 e l'Incremental Source Generator (supporta anche .NET Standard 2.1 (.NET 5, 6) e Unity).</p><p>Altri serializer eseguono molte operazioni di codifica come VarInt, tag, stringhe, ecc. Il formato MemoryPack utilizza un design zero-encoding che copia quanta più memoria C# possibile. Lo zero-encoding è simile a FlatBuffers, ma non necessita di un tipo speciale, il target della serializzazione MemoryPack è POCO.</p><p>Oltre alle prestazioni, MemoryPack offre queste funzionalità.</p><ul><li>Supporto alle moderne API di I/O (<code>IBufferWriter<byte></code>, <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>)</li>
<li>Generazione di codice tramite Source Generator nativo AOT friendly, senza Dynamic CodeGen (IL.Emit)</li>
<li>API non generiche senza riflessione</li>
<li>Deserializzazione su istanza esistente</li>
<li>Serializzazione polimorfica (Union)</li>
<li>Supporto version-tolerant limitato (fast/default) e completo</li>
<li>Serializzazione di riferimenti circolari</li>
<li>Serializzazione streaming basata su PipeWriter/Reader</li>
<li>Generazione di codice TypeScript e ASP.NET Core Formatter</li>
<li>Supporto Unity (2021.3) IL2CPP tramite .NET Source Generator</li></p><p></ul>Installazione
<hr>
Questa libreria è distribuita tramite NuGet. Per le migliori prestazioni, si consiglia di usare <code>.NET 7</code>. Il requisito minimo è <code>.NET Standard 2.1</code>.</p><blockquote>PM> Install-Package <a href="https://www.nuget.org/packages/MemoryPack" target="_blank" rel="noopener noreferrer">MemoryPack</a></blockquote></p><p>Inoltre, l'editor di codice richiede il supporto Roslyn 4.3.1, ad esempio Visual Studio 2022 versione 17.3, .NET SDK 6.0.401. Per dettagli, consultare il documento <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support" target="_blank" rel="noopener noreferrer">Roslyn Version Support</a>.</p><p>Per Unity, i requisiti e il processo di installazione sono completamente diversi. Vedere la sezione <a href="#unity" target="_blank" rel="noopener noreferrer">Unity</a> per i dettagli.</p><p>Guida rapida
<hr>
Definire una struct o una classe da serializzare e annotarla con l'attributo <code>[MemoryPackable]</code> e la keyword <code>partial</code>.</p><pre><code class="language-csharp">using MemoryPack;</p><p>[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}</code></pre></p><p>Il codice di serializzazione è generato tramite la funzionalità C# source generator che implementa l'interfaccia <code>IMemoryPackable<T></code>. In Visual Studio puoi vedere il codice generato usando la scorciatoia <code>Ctrl+K, R</code> sul nome della classe e selezionando <code>*.MemoryPackFormatter.g.cs</code>.</p><p>Chiama <code>MemoryPackSerializer.Serialize<T>/Deserialize<T></code> per serializzare/deserializzare un'istanza oggetto.</p><pre><code class="language-csharp">var v = new Person { Age = 40, Name = "John" };</p><p>var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize<Person>(bin);</code></pre></p><p>Il metodo <code>Serialize</code> supporta il tipo di ritorno <code>byte[]</code> così come la serializzazione su <code>IBufferWriter<byte></code> o <code>Stream</code>. Il metodo <code>Deserialize</code> supporta <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code> e <code>Stream</code>. Esistono anche versioni non generiche.</p><p>Tipi supportati di default
<hr>
Questi tipi possono essere serializzati di default:</p><ul><li>Primitivi .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, ecc.)</li>
<li>Tipi unmanaged (Qualsiasi <code>enum</code>, qualsiasi <code>struct</code> definita dall'utente che non contiene tipi reference)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory<></code>, <code>ReadOnlyMemory<></code>, <code>ArraySegment<></code>, <code>ReadOnlySequence<></code></li>
<li><code>Nullable<></code>, <code>Lazy<></code>, <code>KeyValuePair<,></code>, <code>Tuple<,...></code>, <code>ValueTuple<,...></code></li>
<li><code>List<></code>, <code>LinkedList<></code>, <code>Queue<></code>, <code>Stack<></code>, <code>HashSet<></code>, <code>SortedSet<></code>, <code>PriorityQueue<,></code></li>
<li><code>Dictionary<,></code>, <code>SortedList<,></code>, <code>SortedDictionary<,></code>,  <code>ReadOnlyDictionary<,></code> </li>
<li><code>Collection<></code>, <code>ReadOnlyCollection<></code>, <code>ObservableCollection<></code>, <code>ReadOnlyObservableCollection<></code></li>
<li><code>IEnumerable<></code>, <code>ICollection<></code>, <code>IList<></code>, <code>IReadOnlyCollection<></code>, <code>IReadOnlyList<></code>, <code>ISet<></code></li>
<li><code>IDictionary<,></code>, <code>IReadOnlyDictionary<,></code>, <code>ILookup<,></code>, <code>IGrouping<,></code>,</li>
<li><code>ConcurrentBag<></code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentDictionary<,></code>, <code>BlockingCollection<></code></li>
<li>Collezioni immutable (<code>ImmutableList<></code>, ecc.) e interfacce (<code>IImmutableList<></code>, ecc.)</li></p><p></ul>Definire <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code>
<hr>
<code>[MemoryPackable]</code> può annotare qualsiasi <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> e <code>interface</code>. Se un tipo è <code>struct</code> o <code>record struct</code> che non contiene tipi reference (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">Tipi unmanaged in C#</a>), non viene utilizzata alcuna annotazione aggiuntiva (ignore, include, constructor, callbacks), serializzando/deserializzando direttamente dalla memoria.</p><p>Altrimenti, di default, <code>[MemoryPackable]</code> serializza le proprietà o i campi pubblici di istanza. Puoi usare <code>[MemoryPackIgnore]</code> per escludere un membro dalla serializzazione, <code>[MemoryPackInclude]</code> promuove un membro privato a target di serializzazione.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // questi tipi vengono serializzati di default
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }</p><p>    // questi tipi non vengono serializzati di default
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;</p><p>    // usa [MemoryPackIgnore] per rimuovere un membro pubblico dalla serializzazione
    [MemoryPackIgnore]
    public int PublicProperty2 => PublicProperty + PublicField;</p><p>    // usa [MemoryPackInclude] per promuovere un membro privato a target di serializzazione
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}</code></pre></p><p>Il code generator di <code>MemoryPack</code> aggiunge informazioni su quali membri sono serializzati nella sezione <code><remarks /></code>. Questo può essere visualizzato passando il mouse sul tipo con Intellisense.</p><p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p><p>Tutti i membri devono essere serializzabili da memorypack, altrimenti il code generator genererà un errore.</p><p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p><p>MemoryPack ha 35 regole diagnostiche (<code>MEMPACK001</code> a <code>MEMPACK035</code>) per una definizione confortevole.</p><p>Se il tipo target è definito per la serializzazione MemoryPack esternamente e registrato, usa <code>[MemoryPackAllowSerialize]</code> per silenziare la diagnostica.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}</code></pre></p><p>L'ordine dei membri è <strong>importante</strong>, MemoryPack non serializza il nome del membro o altre informazioni, ma serializza i campi nell'ordine in cui sono dichiarati. Se un tipo è ereditato, la serializzazione avviene nell'ordine genitore → figlio. L'ordine dei membri non può cambiare per la deserializzazione. Per l'evoluzione dello schema, vedere la sezione <a href="#version-tolerant" target="_blank" rel="noopener noreferrer">Version tolerant</a>.</p><p>L'ordine di default è sequenziale, ma puoi scegliere il layout esplicito con <code>[MemoryPackable(SerializeLayout.Explicit)]</code> e <code>[MemoryPackOrder()]</code>.</p><pre><code class="language-csharp">// serializza Prop0 -> Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}</code></pre></p><h3>Selezione del costruttore</h3></p><p>MemoryPack supporta sia costruttori parametrizzati che senza parametri. La selezione del costruttore segue queste regole. (Si applica a classi e struct).</p><ul><li>Se esiste <code>[MemoryPackConstructor]</code>, viene usato quello.</li>
<li>Se non ci sono costruttori espliciti (incluso privato), viene usato quello senza parametri.</li>
<li>Se c’è un solo costruttore senza parametri/parametrizzato (incluso privato), viene usato quello.</li>
<li>Se ci sono più costruttori, allora l’attributo <code>[MemoryPackConstructor]</code> deve essere applicato al costruttore desiderato (il generatore non ne sceglierà uno automaticamente), altrimenti verrà generato un errore.</li>
<li>Se si utilizza un costruttore parametrizzato, tutti i nomi dei parametri devono corrispondere ai nomi dei membri corrispondenti (case-insensitive).</li></p><p></ul><pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;</p><p>    // Si può usare un costruttore parametrizzato - i nomi dei parametri devono corrispondere ai nomi dei membri (case-insensitive)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}</p><p>// supporta anche il costruttore primario dei record
[MemoryPackable]
public partial record Person2(int Age, string Name);</p><p>public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }</p><p>    public Person3()
    {
    }</code></pre>
<pre><code class="language-csharp">// Se ci sono più costruttori, allora si dovrebbe usare [MemoryPackConstructor]
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}</code></pre></p><h3>Callback di serializzazione</h3></p><p>Durante la serializzazione/deserializzazione, MemoryPack può invocare un evento prima/dopo usando gli attributi <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. È possibile annotare sia metodi statici che di istanza (non statici), sia metodi pubblici che privati.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // l’ordine di chiamata dei metodi è statico -> istanza
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }</p><p>    // permette anche metodi privati
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }</p><p>    // serializing -> /<em> serialize </em>/ -> serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }</p><p>    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }</p><p>    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }</p><p>    // Nota: il metodo di istanza con MemoryPackOnDeserializing non viene chiamato se l’istanza non è passata tramite <code>ref</code>
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }</p><p>    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }</p><p>    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}</code></pre></p><p>I callback permettono sia metodi senza parametri sia metodi con <code>ref reader/writer, ref T value</code>. Ad esempio, i callback ref possono scrivere/leggere un header personalizzato prima del processo di serializzazione.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }</p><p>    [MemoryPackOnSerializing]
    static void WriteId<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter<byte> // .NET Standard 2.1, usa where TBufferWriter : class, IBufferWriter<byte>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // emette un GUID nell’header.
    }</p><p>    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // legge l’header personalizzato prima della deserializzazione
        var guid = reader.ReadUnmanaged<Guid>();
        Console.WriteLine(guid);
    }
}</code></pre></p><p>Se si assegna un valore a <code>ref value</code>, è possibile cambiare il valore utilizzato per la serializzazione/deserializzazione. Ad esempio, istanziare da un ServiceProvider.</p><pre><code class="language-csharp">// prima di usare questo formatter, impostare ServiceProvider
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);</p><p>[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;</p><p>    public int MyProperty { get; private set; }</p><p>    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService<InstantiateFromServiceProvider>();
    }
}</code></pre></p><p>Definire una collezione personalizzata
<hr>
Per impostazione predefinita, un tipo annotato con <code>[MemoryPackObject]</code> cerca di serializzare i suoi membri. Tuttavia, se un tipo è una collezione (<code>ICollection<></code>, <code>ISet<></code>, <code>IDictionary<,></code>), usa <code>GenerateType.Collection</code> per serializzarlo correttamente.</p><pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList<T> : List<T>
{
}</p><p>[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary<TValue> : Dictionary<string, TValue>
{</p><p>}</code></pre></p><p>Costruttore statico
<hr>
Una classe MemoryPackable non può definire un costruttore statico perché la classe partial generata lo utilizza. In alternativa, si può definire un metodo <code>static partial void StaticConstructor()</code> per ottenere lo stesso risultato.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}</code></pre></p><p>Polimorfismo (Union)
<hr>
MemoryPack supporta la serializzazione di oggetti interfaccia e classi astratte per la serializzazione polimorfica. In MemoryPack questa funzionalità è chiamata Union. Solo interfacce e classi astratte possono essere annotate con l’attributo <code>[MemoryPackUnion]</code>. Sono richiesti tag univoci di union.</p><pre><code class="language-csharp">// Annotare [MemoryPackable] e i tipi derivati con [MemoryPackUnion]
// Union supporta anche classi astratte
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}</p><p>[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}</p><p>[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---</p><p>IUnionSample data = new FooClass() { XYZ = 999 };</p><p>// Serializza come tipo interfaccia.
var bin = MemoryPackSerializer.Serialize(data);</p><p>// Deserializza come tipo interfaccia.
var reData = MemoryPackSerializer.Deserialize<IUnionSample>(bin);</p><p>switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}</code></pre></p><p>Il <code>tag</code> consente valori da <code>0</code> a <code>65535</code>, ed è particolarmente efficiente per valori inferiori a <code>250</code>.
<pre><code class="language-">Se un'interfaccia e i tipi derivati si trovano in assembly diversi, puoi utilizzare invece <code>MemoryPackUnionFormatterAttribute</code>. I formatter vengono generati in modo che siano automaticamente registrati tramite <code>ModuleInitializer</code> in C# 9.0 e versioni successive.</p><blockquote>Nota che <code>ModuleInitializer</code> non è supportato in Unity, quindi il formatter deve essere registrato manualmente. Per registrare il tuo union formatter invoca manualmente <code>{nome del tuo union formatter}Initializer.RegisterFormatter()</code> all'avvio. Ad esempio, <code>UnionSampleFormatterInitializer.RegisterFormatter()</code>.</blockquote>
</code></pre>csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}</p><p>// AssemblyB definisce la definizione al di fuori del tipo target
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
<pre><code class="language-">
Un'unione può essere assemblata nel codice tramite <code>DynamicUnionFormatter<T></code>.
</code></pre>csharp
// (ushort, Type)[]
var formatter = new DynamicUnionFormatter<IFooBarBaz>(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);</p><p>MemoryPackFormatterProvider.Register(formatter);
<pre><code class="language-">
API Serialize
<hr>
<code>Serialize</code> ha tre overload.
</code></pre>csharp
// È disponibile anche una API non generica, in cui il primo argomento è Type e il valore è object?
byte[] Serialize<T>(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize<T, TBufferWriter>(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync<T>(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
<pre><code class="language-">
Per motivi di prestazioni, l'API consigliata utilizza <code>BufferWriter</code>. Questa serializza direttamente nel buffer. Può essere applicata a <code>PipeWriter</code> in <code>System.IO.Pipelines</code>, <code>BodyWriter</code> in ASP .NET Core, ecc.</p><p>Se è richiesto un <code>byte[]</code> (ad esempio <code>RedisValue</code> in <a href="https://github.com/StackExchange/StackExchange.Redis" target="_blank" rel="noopener noreferrer">StackExchange.Redis</a>), l'API che restituisce <code>byte[]</code> è semplice e quasi altrettanto veloce.</p><p>Nota che <code>SerializeAsync</code> per <code>Stream</code> è asincrona solo per Flush; serializza tutto in una volta nel buffer interno di MemoryPack e poi scrive utilizzando <code>WriteAsync</code>. Pertanto, la versione con overload <code>BufferWriter</code>, che separa e controlla buffer e flush, è preferibile.</p><p>Se desideri eseguire una scrittura streaming completa, consulta la sezione <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><h3>MemoryPackSerializerOptions</h3></p><p><code>MemoryPackSerializerOptions</code> configura se le stringhe vengono serializzate come UTF16 o UTF8. Può essere configurato passando <code>MemoryPackSerializerOptions.Utf8</code> per la codifica UTF8, <code>MemoryPackSerializerOptions.Utf16</code> per la codifica UTF16 oppure <code>MemoryPackSerializerOptions.Default</code> che di default usa UTF8. Passare null o usare il parametro di default comporta la codifica UTF8.</p><p>Poiché la rappresentazione interna delle stringhe in C# è UTF16, UTF16 ha prestazioni migliori. Tuttavia, il payload tende a essere più grande; in UTF8, una stringa ASCII è un byte, mentre in UTF16 sono due byte. Poiché la differenza di dimensione di questo payload è così grande, UTF8 è impostato come default.</p><p>Se i dati non sono ASCII (ad esempio giapponese, che può richiedere più di 3 byte e con UTF8 è più grande), o se devi comprimerli separatamente, UTF16 può dare risultati migliori.</p><p>Mentre UTF8 o UTF16 possono essere selezionati durante la serializzazione, non è necessario specificarlo durante la deserializzazione. Verrà rilevato automaticamente e deserializzato normalmente.</p><p>Inoltre puoi ottenere/impostare <code>IServiceProvider? ServiceProvider { get; init; }</code> dalle opzioni. È utile per ottenere oggetti DI (come <code>ILogger<T></code>) dal processo di serializzazione (<code>MemoryPackReader/MemoryPackWriter</code> ha la proprietà .Options).</p><p>API Deserialize
<hr>
<code>Deserialize</code> ha overload per <code>ReadOnlySpan<byte></code>, <code>ReadOnlySequence<byte></code>, <code>Stream</code> e supporto per <code>ref</code>.
</code></pre>csharp
T? Deserialize<T>(ReadOnlySpan<byte> buffer)
int Deserialize<T>(ReadOnlySpan<byte> buffer, ref T? value)
T? Deserialize<T>(in ReadOnlySequence<byte> buffer)
int Deserialize<T>(in ReadOnlySequence<byte> buffer, ref T? value)
async ValueTask<T?> DeserializeAsync<T>(Stream stream)
<pre><code class="language-">
L'overload <code>ref</code> sovrascrive un'istanza esistente, per dettagli vedi la sezione <a href="#overwrite" target="_blank" rel="noopener noreferrer">Overwrite</a>.</p><p><code>DeserializeAsync(Stream)</code> non è una lettura streaming completa: prima legge nel pool interno di MemoryPack fino alla fine dello stream, poi deserializza.</p><p>Se vuoi eseguire una lettura streaming completa, consulta la sezione <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>.</p><p>Overwrite
<hr>
Per ridurre le allocazioni, MemoryPack supporta la deserializzazione su un'istanza esistente, sovrascrivendola. Questo può essere usato con l'overload <code>Deserialize(ref T? value)</code>.
</code></pre>csharp
var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);</p><p>// sovrascrive i dati nell'istanza esistente.
MemoryPackSerializer.Deserialize(bin, ref person);
<pre><code class="language-">
MemoryPack tenterà di sovrascrivere il più possibile, ma se non si verificano le seguenti condizioni, verrà creata una nuova istanza (come nella deserializzazione normale).</p><ul><li>il valore ref (inclusi i membri nel grafo degli oggetti) è null, viene impostata una nuova istanza</li>
<li>consente solo il costruttore senza parametri, se viene usato un costruttore parametrico, crea una nuova istanza</li>
<li>se il valore è <code>T[]</code>, viene riutilizzato solo se la lunghezza è la stessa, altrimenti viene creata una nuova istanza</li>
<li>se il valore è una collezione che ha il metodo <code>.Clear()</code> (<code>List<></code>, <code>Stack<></code>, <code>Queue<></code>, <code>LinkedList<></code>, <code>HashSet<></code>, <code>PriorityQueue<,></code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue<></code>, <code>ConcurrentStack<></code>, <code>ConcurrentBag<></code>, <code>Dictionary<,></code>, <code>SortedDictionary<,></code>, <code>SortedList<,></code>, <code>ConcurrentDictionary<,></code>), viene chiamato Clear() e la collezione viene riutilizzata, altrimenti viene creata una nuova istanza</li></p><p></ul>Version tolerant
<hr>
Di default (<code>GenerateType.Object</code>), MemoryPack supporta un'evoluzione limitata dello schema.</p><ul><li>una struct non gestita non può più essere modificata</li>
<li>i membri possono essere aggiunti, ma non possono essere eliminati</li>
<li>è possibile cambiare il nome del membro</li>
<li>non è possibile cambiare l'ordine dei membri</li>
<li>non è possibile cambiare il tipo del membro</li>
</ul></code></pre>csharp
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// L'aggiunta è OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}</p><p>// La rimozione NON è consentita.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}</p><p>// Cambiare ordine NON è consentito.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
<pre><code class="language-">
Nell'uso pratico, salvare dati vecchi (su file, su redis, ecc...) e leggerli con uno schema nuovo è sempre consentito. Nello scenario RPC, lo schema esiste sia lato client che lato server, il client deve essere aggiornato prima del server. Un client aggiornato può connettersi senza problemi a un server vecchio, ma un client vecchio non può connettersi a un server nuovo.</p><p>Di default, quando i dati vecchi vengono letti su uno schema nuovo, tutti i membri non presenti nei dati sono inizializzati con il valore letterale <code>default</code>.
Se vuoi evitare questo comportamento e usare i valori iniziali dei campi/proprietà, puoi usare <code>[SuppressDefaultInitialization]</code>.
</code></pre>cs
[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }</p><p>    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // < se i dati vecchi mancano, imposta <code>111</code>.
    
    public int Prop3 { get; set; } = 222; // < se i dati vecchi mancano, imposta <code>default</code>.
}
<pre><code class="language-">
 <code>[SuppressDefaultInitialization]</code> ha le seguenti limitazioni:
<ul><li>Non può essere usato con readonly, init-only e modificatore required.</li></p><p></ul>La prossima sezione <a href="#serialization-info" target="_blank" rel="noopener noreferrer">Serialization info</a> mostra come verificare le modifiche allo schema, ad esempio tramite CI, per prevenire errori.</p><p>Quando si utilizza <code>GenerateType.VersionTolerant</code>, viene supportata la piena tolleranza di versione.</p><ul><li>una struct non gestita non può più essere modificata</li>
<li>tutti i membri devono aggiungere <code>[MemoryPackOrder]</code> esplicitamente (tranne se si annota <code>SerializeLayout.Sequential</code>)</li>
<li>i membri possono essere aggiunti, possono essere eliminati ma non si può riutilizzare l'ordine (è possibile usare ordini mancanti)</li>
<li>è possibile cambiare il nome del membro</li>
<li>non è possibile cambiare l'ordine dei membri</li>
<li>non è possibile cambiare il tipo del membro</li>
</ul></code></pre>csharp
// Ok per serializzare/deserializzare sia 
// VersionTolerantObject1 -> VersionTolerantObject2 che 
// VersionTolerantObject2 -> VersionTolerantObject1</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;</p><p>    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;</p><p>    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}</p><p>[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
<pre><code class="language-csharp">[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;</p><p>// eliminato
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;</p><p>[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;</p><p>// aggiunto
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}</code></pre></p><pre><code class="language-csharp">// Se si imposta esplicitamente SerializeLayout.Sequential, consente l'ordinamento automatico.
// Tuttavia, non è possibile rimuovere alcun membro per la tolleranza alle versioni.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}</code></pre></p><p><code>GenerateType.VersionTolerant</code> è più lento di <code>GenerateType.Object</code> durante la serializzazione. Inoltre, la dimensione del payload sarà leggermente maggiore.</p><p>Informazioni sulla serializzazione
----
Puoi verificare tramite IntelliSense quali membri di un tipo vengono serializzati. Esiste un'opzione per scrivere queste informazioni su un file in fase di compilazione. Imposta <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> come segue.</p><pre><code class="language-xml"><!-- output memorypack serialization info to directory -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_SerializationInfoOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_SerializationInfoOutputDirectory>$(MSBuildProjectDirectory)\MemoryPackLogs</MemoryPackGenerator_SerializationInfoOutputDirectory>
</PropertyGroup></code></pre></p><p>Le seguenti informazioni vengono scritte nel file.</p><p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p><p>Se il tipo è unmanaged, viene visualizzato <code>unmanaged</code> prima del nome del tipo.</p><pre><code class="language-txt">unmanaged FooStruct
<hr>
int x
int y</code></pre></p><p>Controllando le differenze in questo file, è possibile prevenire cambiamenti pericolosi dello schema. Ad esempio, potresti voler utilizzare la CI per rilevare le seguenti regole</p><ul><li>modifica di un tipo unmanaged</li>
<li>cambio dell'ordine dei membri</li>
<li>eliminazione di un membro</li></p><p></ul>Riferimento Circolare
<hr>
MemoryPack supporta anche il riferimento circolare. Questo consente di serializzare gli oggetti ad albero così come sono.</p><pre><code class="language-csharp">// per abilitare il riferimento circolare, usare GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}</code></pre></p><p>Ad esempio, il codice <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references" target="_blank" rel="noopener noreferrer">System.Text.Json preserve-references</a> diventerà così.</p><pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = "Tyler Stein"
};</p><p>Employee adrian = new()
{
    Name = "Adrian King"
};</p><p>tyler.DirectReports = new List<Employee> { adrian };
adrian.Manager = tyler;</p><p>var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize<Employee>(bin);</p><p>Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true</p><p>[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List<Employee>? DirectReports { get; set; }
}</code></pre></p><p><code>GenerateType.CircularReference</code> ha le stesse caratteristiche della tolleranza alle versioni. Tuttavia, come vincolo aggiuntivo, sono consentiti solo costruttori senza parametri. Inoltre, il tracciamento dei riferimenti agli oggetti viene effettuato solo per gli oggetti contrassegnati con <code>GenerateType.CircularReference</code>. Se desideri tracciare altri oggetti, incapsulali.</p><p>CustomFormatter
<hr>
Se implementi <code>MemoryPackCustomFormatterAttribute<T></code> oppure <code>MemoryPackCustomFormatterAttribute<TFormatter, T></code> (più performante, ma complesso), puoi configurare un formatter personalizzato per i membri di MemoryPackObject.</p><pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute<T> : Attribute
{
    public abstract IMemoryPackFormatter<T> GetFormatter();
}</code></pre></p><p>MemoryPack fornisce i seguenti attributi di formattazione: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute<TValue></code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter<T></code>, <code>MemoryPoolFormatter<T></code>, <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // serializza questo membro come String UTF16, è più performante di UTF8 ma in ASCII la dimensione è maggiore (ma per caratteri non ASCII, talvolta è più piccola).
    [Utf16StringFormatter]
    public string? Text { get; set; }</p><p>    // In deserializzazione, il Dictionary viene inizializzato con StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter<int>]
    public Dictionary<string, int>? Ids { get; set; }
    
    // In deserializzazione, tutte le stringhe vengono internate (vedi: String.Intern). Se valori simili si ripetono, si risparmia memoria.
    [InternStringFormatter]
    public string? Flag { get; set; }
}</code></pre></p><p>Per configurare l'equality comparer di un set/dictionary, tutti i formatter integrati dispongono di un overload del costruttore con comparer. Puoi creare facilmente formatter personalizzati per equality comparer.</p><pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter<TValue> : MemoryPackCustomFormatterAttribute<Dictionary<string, TValue?>>
{
    static readonly DictionaryFormatter<string, TValue?> formatter = new DictionaryFormatter<string, TValue?>(StringComparer.OrdinalIgnoreCase);</p><p>    public override IMemoryPackFormatter<Dictionary<string, TValue?>> GetFormatter()
    {
        return formatter;
    }
}</code></pre></p><p><code>BitPackFormatter</code> comprime solo i tipi <code>bool[]</code>. <code>bool[]</code> normalmente viene serializzato come 1 byte per ogni valore booleano, tuttavia <code>BitPackFormatter</code> serializza <code>bool[]</code> come una <code>BitArray</code> memorizzando ogni bool come 1 bit. Usando <code>BitPackFormatter</code>, 8 bool diventano 1 byte dove normalmente sarebbero 8 byte, ottenendo una dimensione 8 volte inferiore.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BitPackFormatter]
    public bool[]? Data { get; set; }
}</code></pre></p><p><code>BrotliFormatter</code> è per <code>byte[]</code>, ad esempio puoi comprimere un payload di grandi dimensioni con Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p><code>BrotliStringFormatter</code> è per <code>string</code>, serializza stringhe compresse (UTF16) con Brotli.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}</code></pre></p><p><code>BrotliFormatter<T></code> è per qualsiasi tipo, i dati serializzati vengono compressi tramite Brotli. Se un tipo è <code>byte[]</code> o <code>string</code>, dovresti utilizzare <code>BrotliFormatter</code> o <code>BrotliStringFormatter</code> per motivi di performance.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter<ChildType>]
    public ChildType? Child { get; set; }
}</code></pre></p><p>Deserialize array pooling
<hr>
Per deserializzare un grande array (qualsiasi <code>T</code>), MemoryPack offre diversi metodi di pooling efficienti. Il modo più efficace è usare la funzione <a href="#overwrite" target="_blank" rel="noopener noreferrer">#Overwrite</a>. In particolare <code>List<T></code> viene sempre riutilizzata.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List<byte> Payload { get; set; }
}</p><p>// ----</p><p>// List<byte> viene riutilizzata, nessuna allocazione in deserializzazione.
MemoryPackSerializer.Deserialize<ListBytesSample>(bin, ref reuseObject);</p><p>// per un'operazione efficiente, puoi ottenere Span<T> tramite CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);</code></pre></p><p>Un modo conveniente è deserializzare su un ArrayPool al momento della deserializzazione. MemoryPack fornisce <code>MemoryPoolFormatter<T></code> e <code>ReadOnlyMemoryPoolFormatter<T></code>.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }</p><p>    [MemoryPoolFormatter<byte>]
    public Memory<byte> Payload { get; private set; }</p><p>    public PoolModelSample(int id, Memory<byte> payload)
    {
        Id = id;
        Payload = payload;
    }</p><p>    // Devi scrivere tu stesso il codice di rilascio, qui un esempio.</p><p>    bool usePool;</p><p>    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }</p><p>    public void Dispose()
    {
        if (!usePool) return;</p><p>        Return(Payload); Payload = default;
    }</p><p>    static void Return<T>(Memory<T> memory) => Return((ReadOnlyMemory<T>)memory);</p><p>    static void Return<T>(ReadOnlyMemory<T> memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) && segment.Array is { Length: > 0 })
        {
            ArrayPool<T>.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences<T>());
        }
    }
}</p><p>// ---</p><p>using(var value = MemoryPackSerializer.Deserialize<PoolModelSample>(bin))
{
    // fai qualsiasi cosa...
}   // ritorna all'ArrayPool</code></pre></p><p>Performance
<hr>
Vedi il mio post sul blog <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516" target="_blank" rel="noopener noreferrer">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p><p>Dimensione del payload e compressione
<hr>
La dimensione del payload dipende dal valore di destinazione; a differenza di JSON, non ci sono chiavi ed è un formato binario, quindi la dimensione del payload sarà probabilmente più piccola rispetto a JSON.</p><p>Per chi utilizza la codifica varint, come MessagePack e Protobuf, MemoryPack tende ad essere più grande se si usano molti interi (in MemoryPack, gli int sono sempre 4 byte a causa della codifica a dimensione fissa, mentre in MessagePack sono 1~5 byte).</p><p>float e double sono 4 byte e 8 byte in MemoryPack, ma 5 byte e 9 byte in MessagePack. Quindi MemoryPack è più piccolo, ad esempio, per array di Vector3 (float, float, float).</p><p>Le stringhe sono in UTF8 di default, il che è simile ad altri serializer, ma se viene scelta l'opzione UTF16, sarà di natura diversa.</p><p>In ogni caso, se la dimensione del payload è grande, si dovrebbe considerare la compressione. Sono raccomandati LZ4, ZStandard e Brotli.</p><h3>Compressione</h3></p><p>MemoryPack fornisce un helper efficiente per la compressione <a href="https://github.com/google/brotli" target="_blank" rel="noopener noreferrer">Brotli</a> tramite <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder" target="_blank" rel="noopener noreferrer">BrotliEncoder</a> e <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder" target="_blank" rel="noopener noreferrer">BrotliDecoder</a>. <code>BrotliCompressor</code> e <code>BrotliDecompressor</code> di MemoryPack offrono compressione/decompressione ottimizzata per il comportamento interno di MemoryPack.</p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Compressione (richiede using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);</p><p>// Ottieni byte[] compresso
var compressedBytes = compressor.ToArray();</p><p>// Oppure scrivi su un altro IBufferWriter<byte> (ad esempio PipeWriter)
compressor.CopyTo(response.BodyWriter);</code></pre></p><pre><code class="language-csharp">using MemoryPack.Compression;</p><p>// Decompressione (richiede using)
using var decompressor = new BrotliDecompressor();</p><p>// Ottieni ReadOnlySequence<byte> decompresso da ReadOnlySpan<byte> o ReadOnlySequence<byte>
var decompressedBuffer = decompressor.Decompress(buffer);</p><p>var value = MemoryPackSerializer.Deserialize<T>(decompressedBuffer);</code></pre></p><p>Sia <code>BrotliCompressor</code> che <code>BrotliDecompressor</code> sono struct, non allocano memoria sull'heap. Entrambi memorizzano i dati compressi o decompressi in un memory pool interno per Serialize/Deserialize. Pertanto, è necessario rilasciare il pooling della memoria, non dimenticare di usare <code>using</code>.</p><p>Il livello di compressione è molto importante. Il valore predefinito è impostato su quality-1 (CompressionLevel.Fastest), che è diverso dal valore predefinito di .NET (CompressionLevel.Optimal, quality-4).</p><p>Fastest (quality-1) sarà vicino alla velocità di <a href="https://github.com/lz4/lz4" target="_blank" rel="noopener noreferrer">LZ4</a>, ma 4 è molto più lento. Questo è stato ritenuto critico nello scenario d'uso del serializer. Fai attenzione quando usi <code>BrotliStream</code> standard (quality-4 è il valore predefinito). In ogni caso, le velocità di compressione/decompressione e le dimensioni varieranno molto a seconda dei dati. Prepara i dati da gestire per la tua applicazione e testa personalmente.</p><p>Nota che c'è una penalità di velocità di vari ordini di grandezza tra l'uso di MemoryPack non compresso e la compressione aggiuntiva di Brotli.</p><p>Brotli è supportato anche in un formatter personalizzato. <code>BrotliFormatter</code> può comprimere un membro specifico.</p><pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }</p><p>    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}</code></pre></p><p>Serializzare tipi esterni
<hr>
Se vuoi serializzare tipi esterni, puoi creare un formatter personalizzato e registrarlo nel provider, vedi <a href="#formatterprovider-api" target="_blank" rel="noopener noreferrer">Formatter/Provider API</a> per dettagli. Tuttavia, creare un formatter personalizzato è difficile. Perciò, si consiglia di creare un tipo wrapper. Ad esempio, se vuoi serializzare un tipo esterno chiamato <code>AnimationCurve</code>.</p><pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;</p><p>    [MemoryPackInclude]
    WrapMode preWrapMode => AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode => AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys => AnimationCurve.keys;</p><p>    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }</p><p>    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}</code></pre></p><p>Il tipo da wrappare è pubblico, ma escluso dalla serializzazione (<code>MemoryPackIgnore</code>). Le proprietà che vuoi serializzare sono private, ma incluse (<code>MemoryPackInclude</code>). Devono essere preparati anche due tipi di costruttori. Il costruttore usato dal serializer dovrebbe essere privato.</p><p>Così com'è, deve essere wrappato ogni volta, il che è scomodo. Inoltre, lo struct wrapper non può rappresentare null. Quindi creiamo un formatter personalizzato.</p><pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter<AnimationCurve>
{
    // Unity non supporta scoped e TBufferWriter quindi cambia la firma in <code>Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)</code>
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref AnimationCurve? value)
    {
        if (value == null)</code></pre>csharp
{
    writer.WriteNullObjectHeader();
    return;
}</p><p>writer.WritePackable(new SerializableAnimationCurve(value));
}</p><p>public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable<SerializableAnimationCurve>();
    value = wrapped.AnimationCurve;
}
}
<pre><code class="language-">
Infine, registra il formatter nell’avvio dell’applicazione.
</code></pre>csharp
MemoryPackFormatterProvider.Register<AnimationCurve>(new AnimationCurveFormatter());
<pre><code class="language-">> Nota: AnimationCurve di Unity è serializzabile di default, quindi non necessita di questo custom formatter per AnimationCurve.</p><p>Pacchetti
<hr>
MemoryPack include questi pacchetti.</p><ul><li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li></p><p></ul><code>MemoryPack</code> è la libreria principale, fornisce il pieno supporto per la serializzazione e deserializzazione ad alte prestazioni di oggetti binari. Dipende da <code>MemoryPack.Core</code> per le librerie base core e da <code>MemoryPack.Generator</code> per la generazione del codice. <code>MemoryPack.Streaming</code> aggiunge estensioni aggiuntive per la <a href="#streaming-serialization" target="_blank" rel="noopener noreferrer">Streaming Serialization</a>. <code>MemoryPack.AspNetCoreMvcFormatter</code> aggiunge formatter di input/output per ASP.NET Core. <code>MemoryPack.UnityShims</code> aggiunge tipi shim e formatter per la condivisione di tipi tra .NET e Unity.</p><p>TypeScript e ASP.NET Core Formatter
<hr>
MemoryPack supporta la generazione di codice TypeScript. Genera classi e codice di serializzazione da C#, in altre parole, puoi condividere tipi con il browser senza utilizzare OpenAPI, proto, ecc.</p><p>La generazione del codice è integrata con Source Generator, le seguenti opzioni (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) impostano la directory di output per il codice TypeScript. Il codice runtime viene generato contemporaneamente, quindi non sono necessarie dipendenze aggiuntive.
</code></pre>xml
<!-- output memorypack TypeScript code to directory -->
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
</PropertyGroup>
<pre><code class="language-">
Un tipo C# MemoryPackable deve essere annotato con <code>[GenerateTypeScript]</code>.
</code></pre>csharp
[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}</p><p>public enum Gender
{
    Male, Female, Other
}
<pre><code class="language-">
Il codice runtime e il tipo TypeScript verranno generati nella directory di destinazione.</p><p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p><p>Il codice generato è il seguente, con campi semplici e metodi statici per serialize/serializeArray e deserialize/deserializeArray.
</code></pre>typescript
import { MemoryPackWriter } from "./MemoryPackWriter.js";
import { MemoryPackReader } from "./MemoryPackReader.js";
import { Gender } from "./Gender.js"; </p><p>export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;</p><p>    constructor() {
        // snip...
    }</p><p>    static serialize(value: Person | null): Uint8Array {
        // snip...
    }</p><p>    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }</p><p>    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }</p><p>    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }</p><p>    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }</p><p>    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }</p><p>    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
<pre><code class="language-">
Puoi utilizzare questo tipo come segue.
</code></pre>typescript
let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = "foo";
person.lastName = "bar";
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = ["foo@bar.com", "zoo@bar.net"];</p><p>// serializza in Uint8Array
let bin = Person.serialize(person);</p><p>let blob = new Blob([bin.buffer], { type: "application/x-memorypack" })</p><p>let response = await fetch("http://localhost:5260/api",
    { method: "POST", body: blob, headers: { "Content-Type": "application/x-memorypack" } });</p><p>let buffer = await response.arrayBuffer();</p><p>// deserializza da ArrayBuffer 
let person2 = Person.deserialize(buffer);
<pre><code class="language-">
Il pacchetto <code>MemoryPack.AspNetCoreMvcFormatter</code> aggiunge formatter di input e output <code>MemoryPack</code> per ASP.NET Core MVC. Puoi aggiungere <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> ad ASP.NET Core MVC con il seguente codice.
</code></pre>csharp
var builder = WebApplication.CreateBuilder(args);</p><p>builder.Services.AddRazorPages();</p><p>builder.Services.AddControllers(options =>
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Se checkContentType: true allora è possibile produrre output in più formati (JSON/MemoryPack, ecc...). Il valore predefinito è false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
<pre><code class="language-">
Se chiami da HttpClient, puoi impostare <code>application/x-memorypack</code> come content-header.
</code></pre>csharp
var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue("application/x-memorypack");
<pre><code class="language-">
<h3>TypeScript Type Mapping</h3></p><p>Ci sono alcune restrizioni sui tipi che possono essere generati. Tra i tipi primitivi, <code>char</code> e <code>decimal</code> non sono supportati. Inoltre, non è possibile utilizzare tipi OpenGenerics.</p><p>|  C#  |  TypeScript  | Descrizione |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |
| <code>ulong</code> |  <code>bigint</code> |
| <code>float</code> |  <code>number</code> |
| <code>double</code> |  <code>number</code> |
| <code>string</code> |  <code>string \| null</code>  | 
| <code>Guid</code> |  <code>string</code>  | In TypeScript, rappresentato come stringa ma serializzato/deserializzato come binario a 16 byte
| <code>DateTime</code> | <code>Date</code> | DateTimeKind verrà ignorato
| <code>enum</code> | <code>const enum</code> | Il tipo sottostante <code>long</code> e <code>ulong</code> non è supportato
| <code>T?</code> | <code>T \| null</code> |
| <code>T[]</code> | <code>T[] \| null</code> |
| <code>byte[]</code> | <code>Uint8Array \| null</code> |
| <code>: ICollection<T></code> | <code>T[] \| null</code> | Supporta tutti i tipi che implementano <code>ICollection<T></code>, come <code>List<T></code>
| <code>: ISet<T></code> | <code>Set<T> \| null</code> | Supporta tutti i tipi che implementano <code>ISet<T></code>, come <code>HashSet<T></code>
| <code>: IDictionary<K,V></code> | <code>Map<K, V> \| null</code> | Supporta tutti i tipi che implementano <code>IDictionary<K,V></code>, come <code>Dictionary<K,V></code>.
| <code>[MemoryPackable]</code> | <code>class</code> | Supporta solo classi
| <code>[MemoryPackUnion]</code> | <code>abstract class</code> |</p><p><code>[GenerateTypeScript]</code> può essere applicato solo alle classi e attualmente non è supportato per le struct.</p><h3>Configurare l'estensione del file di import e il casing dei nomi dei membri</h3></p><p>Di default, MemoryPack genera l'estensione dei file come <code>.js</code>, ad esempio <code>import { MemoryPackWriter } from "./MemoryPackWriter.js";</code>. Se vuoi cambiare l'estensione o lasciarla vuota, usa <code>MemoryPackGenerator_TypeScriptImportExtension</code> per configurarla.
Inoltre, il nome dei membri viene automaticamente convertito in camelCase. Se vuoi usare il nome originale, imposta <code>MemoryPackGenerator_TypeScriptConvertPropertyName</code> a <code>false</code>.
</code></pre>xml
<ItemGroup>
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptOutputDirectory" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptImportExtension" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptConvertPropertyName" />
    <CompilerVisibleProperty Include="MemoryPackGenerator_TypeScriptEnableNullableTypes" />
</ItemGroup>
<PropertyGroup>
    <MemoryPackGenerator_TypeScriptOutputDirectory>$(MSBuildProjectDirectory)\wwwroot\js\memorypack</MemoryPackGenerator_TypeScriptOutputDirectory>
    <!-- permette vuoto -->
    <MemoryPackGenerator_TypeScriptImportExtension></MemoryPackGenerator_TypeScriptImportExtension>
    <!-- default è true -->
    <MemoryPackGenerator_TypeScriptConvertPropertyName>false</MemoryPackGenerator_TypeScriptConvertPropertyName>
    <!-- default è false -->
    <MemoryPackGenerator_TypeScriptEnableNullableTypes>true</MemoryPackGenerator_TypeScriptEnableNullableTypes>
</PropertyGroup>
<pre><code class="language-">
<code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> permette che le annotazioni nullable di C# siano riflesse nel codice TypeScript. Il default è false, rendendo tutto nullable.</p><p>Serializzazione Streaming
<hr>
<code>MemoryPack.Streaming</code> fornisce <code>MemoryPackStreamingSerializer</code>, che aggiunge supporto aggiuntivo per la serializzazione e deserializzazione di collezioni tramite stream.
</code></pre>csharp
public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync<T>(PipeWriter pipeWriter, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync<T>(Stream stream, int count, IEnumerable<T> source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable<T?> DeserializeAsync<T>(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable<T?> DeserializeAsync<T>(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}
<pre><code class="language-">
API Formatter/Provider
<hr>
Se vuoi implementare manualmente un formatter, eredita da <code>MemoryPackFormatter<T></code> e sovrascrivi i metodi <code>Serialize</code> e <code>Deserialize</code>.
</code></pre>csharp
public class SkeltonFormatter : MemoryPackFormatter<Skelton>
{
    public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }</p><p>        // usa il metodo writer.
    }</p><p>    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }</p><p>        // usa il metodo reader.
    }
}
<pre><code class="language-">Il formatter creato viene registrato con <code>MemoryPackFormatterProvider</code>.
</code></pre>csharp
MemoryPackFormatterProvider.Register(new SkeltonFormatter());
<pre><code class="language-">
Nota: le <code>unmanaged struct</code> (che non contengono tipi reference) non possono usare custom formatter, vengono sempre serializzate con layout di memoria nativo.</p><p>MemoryPackWriter/ReaderOptionalState
<hr>
L'inizializzazione di <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> richiede OptionalState. È un wrapper di <code>MemoryPackSerializerOptions</code> e può essere creato da <code>MemoryPackWriterOptionalStatePool</code>.
</code></pre>csharp
// quando viene eliminato, OptionalState tornerà al pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter<T>(ref t, state);
}</p><p>// per Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}
<pre><code class="language-">
Dipendenza dal framework di destinazione
<hr>
MemoryPack fornisce <code>netstandard2.1</code> e <code>net7.0</code> ma entrambi non sono compatibili. Ad esempio, tipi MemoryPackable sotto un progetto <code>netstandard2.1</code> e usati da un progetto <code>net7.0</code> generano una eccezione a runtime come questa</p><blockquote>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</blockquote></p><p>Poiché net7.0 usa membri statici astratti (<code>Virtual static method</code>), che non sono supportati da netstandard2.1, questo comportamento è una specifica.</p><p>Un progetto .NET 7 non dovrebbe usare la dll netstandard 2.1. In altre parole, se l'applicazione è un progetto .NET 7, tutte le dipendenze che usano MemoryPack devono supportare .NET 7. Quindi, se uno sviluppatore di librerie ha una dipendenza su MemoryPack, è necessario configurare il doppio target framework.
</code></pre>xml
<TargetFrameworks>netstandard2.1;net7.0</TargetFrameworks>
``<code></p><p>RPC
<hr>
<a href="https://github.com/Cysharp/MagicOnion" target="_blank" rel="noopener noreferrer">Cysharp/MagicOnion</a> è un framework grpc-dotnet code-first che utilizza MessagePack invece di protobuf. MagicOnion ora supporta MemoryPack come layer di serializzazione tramite il pacchetto </code>MagicOnion.Serialization.MemoryPack<code> (in anteprima). Vedi dettagli: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support" target="_blank" rel="noopener noreferrer">MagicOnion#MemoryPack support</a></p><p>Unity
<hr></p><p>La versione minima supportata di Unity è </code>2022.3.12f1<code>.</p><p>Il pacchetto core </code>MemoryPack<code> è fornito tramite nuget. È disponibile anche in Unity. Se vuoi ottenere il supporto per i tipi integrati di Unity, forniamo inoltre l'estensione MemoryPack.Unity.</p><ul><li>Installa </code>MemoryPack<code> da NuGet usando <a href="https://github.com/GlitchEnzo/NuGetForUnity" target="_blank" rel="noopener noreferrer">NuGetForUnity</a></li></p><p><li>Apri la finestra da NuGet -> Gestisci Pacchetti NuGet, cerca "MemoryPack" e premi Installa.</li>
</ul><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p><ul><li>Se incontri errori di conflitto di versione, disabilita la validazione delle versioni nelle Impostazioni del Player (Modifica -> Impostazioni Progetto -> Player -> Scorri verso il basso ed espandi "Other Settings" quindi deseleziona "Assembly Version Validation" sotto la sezione "Configuration").</li></p><p><li>Installa il pacchetto </code>MemoryPack.Unity<code> facendo riferimento all'URL git</li></p><p><li></code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity<code></li>
</ul><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot">
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></p><p>
MemoryPack usa il tag di rilascio <em>.</em>.* quindi puoi specificare una versione come #1.0.0. Ad esempio: </code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0<code></p><p>
Come nella versione .NET, il codice è generato da un code generator (</code>MemoryPack.Generator.dll<code>). L'implementazione senza reflection fornisce anche le migliori prestazioni in IL2CPP.</p><p>Per maggiori informazioni su Unity e Source Generator, fai riferimento alla <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html" target="_blank" rel="noopener noreferrer">documentazione Unity</a>.</p><p>Source Generator è utilizzato ufficialmente anche da Unity tramite <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html" target="_blank" rel="noopener noreferrer">com.unity.properties</a> e <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html" target="_blank" rel="noopener noreferrer">com.unity.entities</a>. In altre parole, è lo standard per la generazione di codice nella prossima generazione di Unity.</p><p>Puoi serializzare tutti i tipi unmanaged (come </code>Vector3<code>, </code>Rect<code>, ecc...) e alcune classi (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>). Se vuoi serializzare altri tipi specifici di Unity, vedi la sezione <a href="#serialize-external-types" target="_blank" rel="noopener noreferrer">Serialize external types</a>.</p><p>In termini di performance su Unity, MemoryPack è da 3 a 10 volte più veloce di JsonUtility.</p><p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p><p>Se il codice condiviso contiene tipi di Unity (</code>Vector2<code>, ecc...), MemoryPack fornisce il pacchetto </code>MemoryPack.UnityShims<code> su NuGet.</p><p>Il pacchetto </code>MemoryPack.UnityShims<code> fornisce shims per gli struct standard di Unity (</code>Vector2<code>, </code>Vector3<code>, </code>Vector4<code>, </code>Quaternion<code>, </code>Color<code>, </code>Bounds<code>, </code>Rect<code>, </code>Keyframe<code>, </code>WrapMode<code>, </code>Matrix4x4<code>, </code>GradientColorKey<code>, </code>GradientAlphaKey<code>, </code>GradientMode<code>, </code>Color32<code>, </code>LayerMask<code>, </code>Vector2Int<code>, </code>Vector3Int<code>, </code>RangeInt<code>, </code>RectInt<code>, </code>BoundsInt<code>) e alcune classi (</code>AnimationCurve<code>, </code>Gradient<code>, </code>RectOffset<code>).</p><blockquote>[!WARNING]</blockquote>
<blockquote>Attualmente, esistono le seguenti limitazioni per l'utilizzo in Unity</blockquote></p><ul><li>La versione Unity non supporta CustomFormatter.</li>
<li>Se usi .NET7 o successivi, il formato binario di MemoryPack non è pienamente compatibile con Unity.</li>
    <li>Questo problema si verifica con i tipi value cui è stato specificato esplicitamente </code>[StructLayout(LayoutKind.Auto)]<code>. (Il default per struct è </code>LayoutKind.Sequential<code>.) Per questi tipi, i binari serializzati in .NET non possono essere deserializzati in Unity. Allo stesso modo, un binario serializzato in Unity non può essere serializzato lato .NET.</li>
    <li>I tipi interessati includono tipicamente i seguenti tipi.</li>
        <li></code>DateTimeOffset<code></li>
        <li></code>ValueTuple<code></li>
    <li>Al momento, la soluzione più semplice è non utilizzare questi tipi.</li></p><p>
</ul>Native AOT
<hr>
Sfortunatamente, .NET 7 Native AOT causa un crash (</code>Generic virtual method pointer lookup failure<code>) quando si usa MemoryPack a causa di un bug del runtime. 
Verrà corretto in .NET 8. Usando la versione preview di </code><code>Microsoft.DotNet.ILCompiler</code><code>, il problema sarà risolto anche in .NET 7. Vedi il <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611" target="_blank" rel="noopener noreferrer">commento all'issue</a> per sapere come configurarlo.</p><p>Specifiche del formato binario wire
<hr>
Il tipo di </code>T<code> definito in </code>Serialize<T><code> e </code>Deserialize<T><code> è chiamato schema C#. Il formato MemoryPack non è un formato auto-descrivente. La deserializzazione richiede il relativo schema C#. Questi tipi esistono come rappresentazioni interne dei binari, ma i tipi non possono essere determinati senza uno schema C#.</p><p>L'endianness deve essere </code>Little Endian<code>. Tuttavia, l'implementazione C# di riferimento non si preoccupa dell'endianness quindi non può essere usata su macchine big-endian. Tuttavia, i computer moderni sono solitamente little-endian.</p><p>Esistono otto tipi di formato.</p><ul><li>Struct unmanaged</li>
<li>Oggetto</li>
<li>Oggetto tollerante alle versioni</li>
<li>Oggetto con Riferimento Circolare</li>
<li>Tupla</li>
<li>Collezione</li>
<li>Stringa</li>
<li>Unione</li></p><p></ul><h3>Struttura Unmanaged</h3></p><p>Una struttura unmanaged è una struct C# che non contiene tipi riferimento, con un vincolo simile a <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" target="_blank" rel="noopener noreferrer">C# Unmanaged types</a>. La serializzazione avviene secondo il layout della struct così com’è, inclusi eventuali padding.</p><h3>Oggetto</h3></p><p></code>(byte memberCount, [values...])<code></p><p>Un oggetto ha 1 byte non firmato come conteggio dei membri nell’header. Il conteggio dei membri consente valori da </code>0<code> a </code>249<code>, </code>255<code> rappresenta che l’oggetto è </code>null<code>. I valori memorizzano valori memorypack per il numero di membri.</p><h3>Oggetto Tollerante alle Versioni</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], [values...])<code></p><p>Un Oggetto Tollerante alle Versioni è simile a Oggetto ma nell’header contiene la lunghezza in byte dei valori. Il varint segue queste specifiche: il primo sbyte è valore o typeCode, i successivi X byte sono il valore. Da 0 a 127 = valore unsigned byte, da -1 a -120 = valore signed byte, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p><h3>Oggetto con Riferimento Circolare</h3></p><p></code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])<code>  
</code>(250, varint referenceId)<code></p><p>Un Oggetto con Riferimento Circolare è simile a Oggetto Tollerante alle Versioni ma se memberCount è 250, il varint(unsigned-int32) successivo è referenceId. Altrimenti, dopo byte-length-of-values, viene scritto varint referenceId.</p><h3>Tupla</h3></p><p></code>(values...)<code></p><p>Una tupla è una collezione di valori di dimensione fissa e non nullable. In .NET, </code>KeyValuePair<TKey, TValue><code> e </code>ValueTuple<T,...><code> sono serializzati come Tuple.</p><h3>Collezione</h3></p><p></code>(int length, [values...])<code></p><p>Una Collezione ha un intero a 4 byte firmato come conteggio dati nell’header, </code>-1<code> rappresenta </code>null<code>. I valori memorizzano valori memorypack per il numero di length.</p><h3>Stringa</h3></p><p></code>(int utf16-length, utf16-value)<code>  
</code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)<code></p><p>Una stringa ha due forme, UTF16 e UTF8. Se il primo intero a 4 byte firmato è </code>-1<code>, rappresenta null. </code>0<code> rappresenta vuota. UTF16 è uguale a collezione (serializzata come </code>ReadOnlySpan<char><code>, il numero di byte di utf16-value è utf16-length * 2). Se il primo intero firmato <= </code>-2<code>, il valore è codificato in UTF8. utf8-byte-count è codificato in complemento, </code>~utf8-byte-count<code> per recuperare il conteggio dei byte. Il prossimo intero firmato è utf16-length, può essere </code>-1<code> che rappresenta una lunghezza sconosciuta. utf8-bytes memorizza i byte per il numero di utf8-byte-count.</p><h3>Unione</h3></p><p></code>(byte tag, value)<code>  
</code>(250, ushort tag, value)<code></p><p>Il primo byte non firmato è tag, che discrimina il tipo di valore o flag, da </code>0<code> a </code>249<code> rappresenta il tag, </code>250<code> indica che il prossimo unsigned short è il tag, </code>255<code> rappresenta che l’unione è </code>null`.</p><p>License
<hr>
Questa libreria è concessa in licenza sotto la licenza MIT.

---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-06-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/Cysharp/MemoryPack/main/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-07-24 
    </div>
    
</body>
</html>