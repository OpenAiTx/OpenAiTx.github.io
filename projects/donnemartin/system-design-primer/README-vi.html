<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>system-design-primer - Học c&#225;ch thiết kế hệ thống quy m&#244; lớn. Chuẩn bị cho phỏng vấn thiết kế hệ thống. Bao gồm thẻ ghi nhớ Anki.</title>
    <meta name="description" content="Học c&#225;ch thiết kế hệ thống quy m&#244; lớn. Chuẩn bị cho phỏng vấn thiết kế hệ thống. Bao gồm thẻ ghi nhớ Anki.">
    <meta name="keywords" content="system-design-primer, Vietnamese, documentation, GitHub, open source">
    <meta name="author" content="OpenAiTx">
    <meta name="robots" content="index, follow">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "system-design-primer",
  "description": "Học cách thiết kế hệ thống quy mô lớn. Chuẩn bị cho phỏng vấn thiết kế hệ thống. Bao gồm thẻ ghi nhớ Anki.",
  "author": {
    "@type": "Person",
    "name": "donnemartin"
  },
  "applicationCategory": "DeveloperApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": 314803
  },
  "url": "https://OpenAiTx.github.io/projects/donnemartin/system-design-primer/README-vi.html",
  "sameAs": "https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md",
  "datePublished": "2025-08-09",
  "dateModified": "2025-08-09"
}
    </script>
    
    <!-- GitHub-style CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #ffffff;
            max-width: 980px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: #ffffff;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .header {
            border-bottom: 1px solid #e1e4e8;
            padding-bottom: 16px;
            margin-bottom: 24px;
        }
        
        .project-title {
            font-size: 2em;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .project-title a {
            color: #24292e;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }
        
        .project-title a:hover {
            color: #0366d6;
            text-decoration: none;
        }
        
        .project-title .github-icon {
            width: 1em;
            height: 1em;
            fill: currentColor;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .project-title a:hover .github-icon {
            opacity: 1;
        }
        
        .project-meta {
            color: #586069;
            font-size: 14px;
            margin-bottom: 16px;
        }
        
        .stars {
            display: inline-block;
            margin-right: 16px;
        }
        
        .language {
            display: inline-block;
            background-color: #f1f8ff;
            color: #0366d6;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .content {
            font-size: 16px;
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            color: #24292e;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        
        p {
            margin-bottom: 16px;
        }
        
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        ul, ol {
            margin-bottom: 16px;
            padding-left: 2em;
        }
        
        li {
            margin-bottom: 0.25em;
        }
        
        blockquote {
            border-left: 4px solid #dfe2e5;
            color: #6a737d;
            margin: 0 0 16px 0;
            padding: 0 1em;
        }
        
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e4e8;
            color: #586069;
            font-size: 14px;
            text-align: center;
        }
        
        .footer a {
            color: #0366d6;
        }
        
        .original-link {
            margin-top: 16px;
            padding: 12px;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 16px;
            }
            
            .project-title {
                font-size: 1.5em;
            }
        }
    </style>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Bing Count -->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "sh95yd6uwt");
    </script>        

    <!-- Statcounter -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>    
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="project-title">
                <a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener noreferrer">
                    <svg class="github-icon" viewBox="0 0 16 16" aria-hidden="true">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                    </svg>
                    system-design-primer
                </a>
            </h1>
            <div class="project-meta">
                <span class="stars">⭐ 314803 stars</span>
                <span class="language">Vietnamese</span>
                <span>by donnemartin</span>
            </div>
        </div>
        
        <div class="content">
            <p><em><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md" target="_blank" rel="noopener noreferrer">English</a> ∙ <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-ja.md" target="_blank" rel="noopener noreferrer">日本語</a> ∙ <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-Hans.md" target="_blank" rel="noopener noreferrer">简体中文</a> ∙ <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README-zh-TW.md" target="_blank" rel="noopener noreferrer">繁體中文</a> | <a href="https://github.com/donnemartin/system-design-primer/issues/170" target="_blank" rel="noopener noreferrer">العَرَبِيَّة‎</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/220" target="_blank" rel="noopener noreferrer">বাংলা</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/40" target="_blank" rel="noopener noreferrer">Português do Brasil</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/186" target="_blank" rel="noopener noreferrer">Deutsch</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/130" target="_blank" rel="noopener noreferrer">ελληνικά</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/272" target="_blank" rel="noopener noreferrer">עברית</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/104" target="_blank" rel="noopener noreferrer">Italiano</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/102" target="_blank" rel="noopener noreferrer">한국어</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/110" target="_blank" rel="noopener noreferrer">فارسی</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/68" target="_blank" rel="noopener noreferrer">Polski</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/87" target="_blank" rel="noopener noreferrer">русский язык</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/136" target="_blank" rel="noopener noreferrer">Español</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/187" target="_blank" rel="noopener noreferrer">ภาษาไทย</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/39" target="_blank" rel="noopener noreferrer">Türkçe</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/127" target="_blank" rel="noopener noreferrer">tiếng Việt</a> ∙ <a href="https://github.com/donnemartin/system-design-primer/issues/250" target="_blank" rel="noopener noreferrer">Français</a> | <a href="https://github.com/donnemartin/system-design-primer/issues/28" target="_blank" rel="noopener noreferrer">Add Translation</a></em></p><p><strong>Hãy <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/TRANSLATIONS.md" target="_blank" rel="noopener noreferrer">dịch</a> hướng dẫn này!</strong></p><h1>Hướng Dẫn Thiết Kế Hệ Thống</h1></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png">
  <br/>
</p></p><h2>Động lực</h2></p><blockquote>Học cách thiết kế các hệ thống quy mô lớn.</blockquote>
>
<blockquote>Chuẩn bị cho phỏng vấn thiết kế hệ thống.</blockquote></p><h3>Học cách thiết kế hệ thống quy mô lớn</h3></p><p>Học cách thiết kế các hệ thống có khả năng mở rộng sẽ giúp bạn trở thành một kỹ sư giỏi hơn.</p><p>Thiết kế hệ thống là một chủ đề rộng. Có <strong>rất nhiều tài nguyên phân tán trên web</strong> về các nguyên tắc thiết kế hệ thống.</p><p>Kho lưu trữ này là một <strong>bộ sưu tập tổ chức</strong> các tài nguyên để giúp bạn học cách xây dựng hệ thống ở quy mô lớn.</p><h3>Học hỏi từ cộng đồng mã nguồn mở</h3></p><p>Đây là một dự án mã nguồn mở, được cập nhật liên tục.</p><p><a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a> luôn được hoan nghênh!</p><h3>Chuẩn bị cho phỏng vấn thiết kế hệ thống</h3></p><p>Bên cạnh các cuộc phỏng vấn lập trình, thiết kế hệ thống là một <strong>thành phần bắt buộc</strong> trong <strong>quy trình phỏng vấn kỹ thuật</strong> tại nhiều công ty công nghệ.</p><p><strong>Thực hành các câu hỏi phỏng vấn thiết kế hệ thống phổ biến</strong> và <strong>so sánh</strong> kết quả của bạn với <strong>các giải pháp mẫu</strong>: thảo luận, mã nguồn và sơ đồ.</p><p>Các chủ đề bổ sung để chuẩn bị phỏng vấn:</p><ul><li><a href="#study-guide" target="_blank" rel="noopener noreferrer">Hướng dẫn học tập</a></li>
<li><a href="#how-to-approach-a-system-design-interview-question" target="_blank" rel="noopener noreferrer">Cách tiếp cận một câu hỏi phỏng vấn thiết kế hệ thống</a></li>
<li><a href="#system-design-interview-questions-with-solutions" target="_blank" rel="noopener noreferrer">Các câu hỏi phỏng vấn thiết kế hệ thống, <strong>có giải pháp</strong></a></li>
<li><a href="#object-oriented-design-interview-questions-with-solutions" target="_blank" rel="noopener noreferrer">Các câu hỏi phỏng vấn thiết kế hướng đối tượng, <strong>có giải pháp</strong></a></li>
<li><a href="#additional-system-design-interview-questions" target="_blank" rel="noopener noreferrer">Các câu hỏi phỏng vấn thiết kế hệ thống bổ sung</a></li></p><p></ul><h2>Thẻ ghi nhớ Anki</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/zdCAkB3.png">
  <br/>
</p></p><p>Bộ thẻ ghi nhớ <a href="https://apps.ankiweb.net/" target="_blank" rel="noopener noreferrer">Anki</a> được cung cấp sử dụng phương pháp lặp lại ngắt quãng giúp bạn ghi nhớ các khái niệm thiết kế hệ thống quan trọng.</p><ul><li><a href="https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg" target="_blank" rel="noopener noreferrer">Bộ thẻ thiết kế hệ thống</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg" target="_blank" rel="noopener noreferrer">Bộ thẻ bài tập thiết kế hệ thống</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg" target="_blank" rel="noopener noreferrer">Bộ thẻ bài tập thiết kế hướng đối tượng</a></li></p><p></ul>Rất tiện lợi khi sử dụng lúc di chuyển.</p><h3>Tài nguyên lập trình: Thử thách Lập trình Tương tác</h3></p><p>Bạn đang tìm kiếm tài nguyên để luyện tập cho <a href="https://github.com/donnemartin/interactive-coding-challenges" target="_blank" rel="noopener noreferrer"><strong>Phỏng vấn Lập trình</strong></a>?</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/b4YtAEN.png">
  <br/>
</p></p><p>Hãy xem kho lưu trữ chị em <a href="https://github.com/donnemartin/interactive-coding-challenges" target="_blank" rel="noopener noreferrer"><strong>Thử thách Lập trình Tương tác</strong></a>, trong đó có thêm một bộ thẻ Anki:</p><ul><li><a href="https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg" target="_blank" rel="noopener noreferrer">Bộ thẻ lập trình</a></li></p><p></ul><h2>Đóng góp</h2></p><blockquote>Học hỏi từ cộng đồng.</blockquote></p><p>Bạn hoàn toàn có thể gửi pull request để giúp:</p><ul><li>Sửa lỗi</li>
<li>Cải thiện các phần</li>
<li>Thêm các mục mới</li>
<li><a href="https://github.com/donnemartin/system-design-primer/issues/28" target="_blank" rel="noopener noreferrer">Dịch</a></li></p><p></ul>Nội dung cần hoàn thiện thêm được đặt <a href="#under-development" target="_blank" rel="noopener noreferrer">đang phát triển</a>.</p><p>Xem lại <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/CONTRIBUTING.md" target="_blank" rel="noopener noreferrer">Hướng dẫn đóng góp</a>.</p><h2>Mục lục các chủ đề thiết kế hệ thống</h2></p><blockquote>Tóm tắt các chủ đề thiết kế hệ thống khác nhau, bao gồm ưu và nhược điểm. <strong>Mọi thứ đều là sự đánh đổi</strong>.</blockquote>
>
<blockquote>Mỗi mục đều có liên kết đến các tài liệu chuyên sâu hơn.</blockquote></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png">
  <br/>
</p></p><ul><li><a href="#system-design-topics-start-here" target="_blank" rel="noopener noreferrer">Chủ đề thiết kế hệ thống: bắt đầu tại đây</a></li>
    <li><a href="#step-1-review-the-scalability-video-lecture" target="_blank" rel="noopener noreferrer">Bước 1: Xem lại bài giảng video về khả năng mở rộng</a></li>
    <li><a href="#step-2-review-the-scalability-article" target="_blank" rel="noopener noreferrer">Bước 2: Xem lại bài viết về khả năng mở rộng</a></li>
    <li><a href="#next-steps" target="_blank" rel="noopener noreferrer">Các bước tiếp theo</a></li>
<li><a href="#performance-vs-scalability" target="_blank" rel="noopener noreferrer">Hiệu năng so với khả năng mở rộng</a></li>
<li><a href="#latency-vs-throughput" target="_blank" rel="noopener noreferrer">Độ trễ so với thông lượng</a></li>
<li><a href="#availability-vs-consistency" target="_blank" rel="noopener noreferrer">Khả dụng so với tính nhất quán</a></li>
    <li><a href="#cap-theorem" target="_blank" rel="noopener noreferrer">Định lý CAP</a></li>
        <li><a href="#cp---consistency-and-partition-tolerance" target="_blank" rel="noopener noreferrer">CP - tính nhất quán và chịu phân vùng</a></li>
        <li><a href="#ap---availability-and-partition-tolerance" target="_blank" rel="noopener noreferrer">AP - khả dụng và chịu phân vùng</a></li>
<li><a href="#consistency-patterns" target="_blank" rel="noopener noreferrer">Các mẫu nhất quán</a></li>
    <li><a href="#weak-consistency" target="_blank" rel="noopener noreferrer">Nhất quán yếu</a></li>
    <li><a href="#eventual-consistency" target="_blank" rel="noopener noreferrer">Nhất quán cuối cùng</a></li>
    <li><a href="#strong-consistency" target="_blank" rel="noopener noreferrer">Nhất quán mạnh</a></li>
<li><a href="#availability-patterns" target="_blank" rel="noopener noreferrer">Các mẫu khả dụng</a></li>
    <li><a href="#fail-over" target="_blank" rel="noopener noreferrer">Chuyển đổi dự phòng</a></li>
    <li><a href="#replication" target="_blank" rel="noopener noreferrer">Sao chép dữ liệu</a></li>
    <li><a href="#availability-in-numbers" target="_blank" rel="noopener noreferrer">Khả dụng theo các con số</a></li>
<li><a href="#domain-name-system" target="_blank" rel="noopener noreferrer">Hệ thống tên miền</a></li>
<li><a href="#content-delivery-network" target="_blank" rel="noopener noreferrer">Mạng phân phối nội dung</a></li>
    <li><a href="#push-cdns" target="_blank" rel="noopener noreferrer">Push CDN</a></li>
    <li><a href="#pull-cdns" target="_blank" rel="noopener noreferrer">Pull CDN</a></li>
<li><a href="#load-balancer" target="_blank" rel="noopener noreferrer">Bộ cân bằng tải</a></li>
    <li><a href="#active-passive" target="_blank" rel="noopener noreferrer">Hoạt động chủ động - bị động</a></li>
    <li><a href="#active-active" target="_blank" rel="noopener noreferrer">Hoạt động chủ động - chủ động</a></li>
    <li><a href="#layer-4-load-balancing" target="_blank" rel="noopener noreferrer">Cân bằng tải tầng 4</a></li>
    <li><a href="#layer-7-load-balancing" target="_blank" rel="noopener noreferrer">Cân bằng tải tầng 7</a></li>
    <li><a href="#horizontal-scaling" target="_blank" rel="noopener noreferrer">Mở rộng theo chiều ngang</a></li>
<li><a href="#reverse-proxy-web-server" target="_blank" rel="noopener noreferrer">Proxy đảo chiều (máy chủ web)</a></li>
    <li><a href="#load-balancer-vs-reverse-proxy" target="_blank" rel="noopener noreferrer">Bộ cân bằng tải vs proxy đảo chiều</a></li>
<li><a href="#application-layer" target="_blank" rel="noopener noreferrer">Tầng ứng dụng</a></li>
    <li><a href="#microservices" target="_blank" rel="noopener noreferrer">Kiến trúc vi dịch vụ</a></li>
    <li><a href="#service-discovery" target="_blank" rel="noopener noreferrer">Khám phá dịch vụ</a></li>
<li><a href="#database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu</a></li>
    <li><a href="#relational-database-management-system-rdbms" target="_blank" rel="noopener noreferrer">Hệ quản trị cơ sở dữ liệu quan hệ (RDBMS)</a></li>
        <li><a href="#master-slave-replication" target="_blank" rel="noopener noreferrer">Sao chép chủ-tớ</a></li>
        <li><a href="#master-master-replication" target="_blank" rel="noopener noreferrer">Sao chép chủ-chủ</a></li>
        <li><a href="#federation" target="_blank" rel="noopener noreferrer">Liên kết liên bang</a></li>
        <li><a href="#sharding" target="_blank" rel="noopener noreferrer">Phân mảnh dữ liệu</a></li>
        <li><a href="#denormalization" target="_blank" rel="noopener noreferrer">Phi chuẩn hóa dữ liệu</a></li>
        <li><a href="#sql-tuning" target="_blank" rel="noopener noreferrer">Tối ưu hóa SQL</a></li>
    <li><a href="#nosql" target="_blank" rel="noopener noreferrer">NoSQL</a></li>
        <li><a href="#key-value-store" target="_blank" rel="noopener noreferrer">Lưu trữ dạng khóa-giá trị</a></li>
        <li><a href="#document-store" target="_blank" rel="noopener noreferrer">Lưu trữ tài liệu</a></li>
        <li><a href="#wide-column-store" target="_blank" rel="noopener noreferrer">Lưu trữ cột rộng</a></li>
        <li><a href="#graph-database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu đồ thị</a></li>
    <li><a href="#sql-or-nosql" target="_blank" rel="noopener noreferrer">SQL hay NoSQL</a></li>
<li><a href="#cache" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm</a></li>
    <li><a href="#client-caching" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm phía khách hàng</a></li>
    <li><a href="#cdn-caching" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm CDN</a></li>
    <li><a href="#web-server-caching" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm máy chủ web</a></li>
    <li><a href="#database-caching" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm cơ sở dữ liệu</a></li>
    <li><a href="#application-caching" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm ứng dụng</a></li>
    <li><a href="#caching-at-the-database-query-level" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm ở mức truy vấn cơ sở dữ liệu</a></li>
    <li><a href="#caching-at-the-object-level" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm ở mức đối tượng</a></li>
    <li><a href="#when-to-update-the-cache" target="_blank" rel="noopener noreferrer">Khi nào cập nhật bộ nhớ đệm</a></li>
        <li><a href="#cache-aside" target="_blank" rel="noopener noreferrer">Cache-aside</a></li>
        <li><a href="#write-through" target="_blank" rel="noopener noreferrer">Ghi-thẳng</a></li>
        <li><a href="#write-behind-write-back" target="_blank" rel="noopener noreferrer">Ghi-ngầm (ghi-lại)</a></li>
        <li><a href="#refresh-ahead" target="_blank" rel="noopener noreferrer">Làm mới trước</a></li>
<li><a href="#asynchronism" target="_blank" rel="noopener noreferrer">Tính phi đồng bộ</a></li>
    <li><a href="#message-queues" target="_blank" rel="noopener noreferrer">Hàng đợi tin nhắn</a></li>
    <li><a href="#task-queues" target="_blank" rel="noopener noreferrer">Hàng đợi tác vụ</a></li>
    <li><a href="#back-pressure" target="_blank" rel="noopener noreferrer">Áp lực ngược</a></li>
<li><a href="#communication" target="_blank" rel="noopener noreferrer">Giao tiếp</a></li>
    <li><a href="#transmission-control-protocol-tcp" target="_blank" rel="noopener noreferrer">Giao thức điều khiển truyền tải (TCP)</a></li>
    <li><a href="#user-datagram-protocol-udp" target="_blank" rel="noopener noreferrer">Giao thức datagram người dùng (UDP)</a></li>
    <li><a href="#remote-procedure-call-rpc" target="_blank" rel="noopener noreferrer">Gọi thủ tục từ xa (RPC)</a></li>
    <li><a href="#representational-state-transfer-rest" target="_blank" rel="noopener noreferrer">Chuyển trạng thái đại diện (REST)</a></li>
<li><a href="#security" target="_blank" rel="noopener noreferrer">Bảo mật</a></li>
<li><a href="#appendix" target="_blank" rel="noopener noreferrer">Phụ lục</a></li>
    <li><a href="#powers-of-two-table" target="_blank" rel="noopener noreferrer">Bảng lũy thừa của hai</a></li>
    <li><a href="#latency-numbers-every-programmer-should-know" target="_blank" rel="noopener noreferrer">Các số liệu độ trễ mà mọi lập trình viên nên biết</a></li>
    <li><a href="#additional-system-design-interview-questions" target="_blank" rel="noopener noreferrer">Các câu hỏi phỏng vấn thiết kế hệ thống bổ sung</a></li>
    <li><a href="#real-world-architectures" target="_blank" rel="noopener noreferrer">Kiến trúc thực tế</a></li>
    <li><a href="#company-architectures" target="_blank" rel="noopener noreferrer">Kiến trúc công ty</a></li>
    <li><a href="#company-engineering-blogs" target="_blank" rel="noopener noreferrer">Blog kỹ thuật công ty</a></li>
<li><a href="#under-development" target="_blank" rel="noopener noreferrer">Đang phát triển</a></li>
<li><a href="#credits" target="_blank" rel="noopener noreferrer">Ghi nhận</a></li>
<li><a href="#contact-info" target="_blank" rel="noopener noreferrer">Thông tin liên hệ</a></li>
<li><a href="#license" target="_blank" rel="noopener noreferrer">Giấy phép</a></li></p><p></ul><h2>Hướng dẫn học tập</h2></p><blockquote>Các chủ đề gợi ý để ôn tập dựa trên thời gian phỏng vấn của bạn (ngắn, trung bình, dài).</blockquote></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/OfVllex.png" alt="Imgur"></p><p><strong>Q: Để phỏng vấn, tôi có cần biết tất cả mọi thứ ở đây không?</strong></p><p><strong>A: Không, bạn không cần phải biết tất cả mọi thứ ở đây để chuẩn bị cho buổi phỏng vấn</strong>.</p><p>Những gì bạn được hỏi trong buổi phỏng vấn phụ thuộc vào các biến số như:</p><ul><li>Bạn có bao nhiêu kinh nghiệm</li>
<li>Nền tảng kỹ thuật của bạn là gì</li>
<li>Bạn đang phỏng vấn cho vị trí nào</li>
<li>Bạn đang phỏng vấn với công ty nào</li>
<li>May mắn</li></p><p></ul>Các ứng viên có kinh nghiệm thường được kỳ vọng biết nhiều hơn về thiết kế hệ thống.  Kiến trúc sư hoặc trưởng nhóm có thể được yêu cầu biết nhiều hơn các thành viên cá nhân.  Các công ty công nghệ hàng đầu thường có một hoặc nhiều vòng phỏng vấn về thiết kế.</p><p>Bắt đầu từ tổng quan và đi sâu vào một vài lĩnh vực nhất định. Việc biết một chút về các chủ đề thiết kế hệ thống quan trọng sẽ rất hữu ích. Điều chỉnh hướng dẫn dưới đây dựa trên thời gian, kinh nghiệm, vị trí bạn đang phỏng vấn và công ty bạn ứng tuyển.</p><ul><li><strong>Thời gian ngắn</strong> - Nhắm đến <strong>độ rộng</strong> với các chủ đề thiết kế hệ thống. Luyện tập bằng cách giải <strong>một số</strong> câu hỏi phỏng vấn.</li>
<li><strong>Thời gian trung bình</strong> - Nhắm đến <strong>độ rộng</strong> và <strong>một số chiều sâu</strong> với các chủ đề thiết kế hệ thống. Luyện tập bằng cách giải <strong>nhiều</strong> câu hỏi phỏng vấn.</li>
<li><strong>Thời gian dài</strong> - Nhắm đến <strong>độ rộng</strong> và <strong>nhiều chiều sâu hơn</strong> với các chủ đề thiết kế hệ thống. Luyện tập bằng cách giải <strong>hầu hết</strong> các câu hỏi phỏng vấn.</li></p><p></ul>| | Ngắn | Trung bình | Dài |
|---|---|---|---|
| Đọc qua <a href="#index-of-system-design-topics" target="_blank" rel="noopener noreferrer">Các chủ đề thiết kế hệ thống</a> để hiểu tổng quan về cách hệ thống hoạt động | :+1: | :+1: | :+1: |
| Đọc một vài bài viết trong <a href="#company-engineering-blogs" target="_blank" rel="noopener noreferrer">Blog kỹ thuật của công ty</a> tại các công ty bạn đang ứng tuyển | :+1: | :+1: | :+1: |
| Đọc qua một số <a href="#real-world-architectures" target="_blank" rel="noopener noreferrer">Kiến trúc thực tế</a> | :+1: | :+1: | :+1: |
| Xem lại <a href="#how-to-approach-a-system-design-interview-question" target="_blank" rel="noopener noreferrer">Cách tiếp cận câu hỏi phỏng vấn thiết kế hệ thống</a> | :+1: | :+1: | :+1: |
| Giải <a href="#system-design-interview-questions-with-solutions" target="_blank" rel="noopener noreferrer">Câu hỏi phỏng vấn thiết kế hệ thống có đáp án</a> | Một số | Nhiều | Hầu hết |
| Giải <a href="#object-oriented-design-interview-questions-with-solutions" target="_blank" rel="noopener noreferrer">Câu hỏi phỏng vấn thiết kế hướng đối tượng có đáp án</a> | Một số | Nhiều | Hầu hết |
| Xem lại <a href="#additional-system-design-interview-questions" target="_blank" rel="noopener noreferrer">Câu hỏi phỏng vấn thiết kế hệ thống bổ sung</a> | Một số | Nhiều | Hầu hết |</p><h2>Cách tiếp cận câu hỏi phỏng vấn thiết kế hệ thống</h2></p><blockquote>Cách giải quyết một câu hỏi phỏng vấn thiết kế hệ thống.</blockquote></p><p>Phỏng vấn thiết kế hệ thống là một <strong>cuộc trò chuyện mở</strong>. Bạn được mong đợi sẽ dẫn dắt buổi phỏng vấn.</p><p>Bạn có thể sử dụng các bước sau để định hướng cuộc thảo luận. Để củng cố quy trình này, hãy luyện tập với <a href="#system-design-interview-questions-with-solutions" target="_blank" rel="noopener noreferrer">Câu hỏi phỏng vấn thiết kế hệ thống có đáp án</a> sử dụng các bước sau.</p><h3>Bước 1: Phác thảo các trường hợp sử dụng, ràng buộc, và giả định</h3></p><p>Thu thập yêu cầu và xác định phạm vi vấn đề. Đặt câu hỏi để làm rõ trường hợp sử dụng và các ràng buộc. Thảo luận về các giả định.</p><ul><li>Ai sẽ sử dụng nó?</li>
<li>Họ sẽ sử dụng nó như thế nào?</li>
<li>Có bao nhiêu người dùng?</li>
<li>Hệ thống sẽ làm gì?</li>
<li>Đầu vào và đầu ra của hệ thống là gì?</li>
<li>Dự kiến sẽ xử lý bao nhiêu dữ liệu?</li>
<li>Dự kiến có bao nhiêu yêu cầu mỗi giây?</li>
<li>Tỷ lệ đọc/ghi dự kiến là bao nhiêu?</li></p><p></ul><h3>Bước 2: Tạo thiết kế cấp cao</h3></p><p>Phác thảo thiết kế tổng quan với tất cả các thành phần quan trọng.</p><ul><li>Phác thảo các thành phần chính và kết nối</li>
<li>Giải thích lý do cho các ý tưởng của bạn</li></p><p></ul><h3>Bước 3: Thiết kế các thành phần cốt lõi</h3></p><p>Đi sâu vào chi tiết cho từng thành phần cốt lõi. Ví dụ, nếu bạn được yêu cầu <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md" target="_blank" rel="noopener noreferrer">thiết kế dịch vụ rút gọn url</a>, hãy thảo luận:</p><ul><li>Tạo và lưu trữ một hash của toàn bộ url</li>
    <li><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md" target="_blank" rel="noopener noreferrer">MD5</a> và <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md" target="_blank" rel="noopener noreferrer">Base62</a></li>
    <li>Va chạm hash</li>
    <li>SQL hoặc NoSQL</li>
    <li>Lược đồ cơ sở dữ liệu</li>
<li>Chuyển đổi url đã băm về url đầy đủ</li>
    <li>Truy vấn cơ sở dữ liệu</li>
<li>Thiết kế API và hướng đối tượng</li></p><p></ul><h3>Bước 4: Mở rộng thiết kế</h3></p><p>Xác định và giải quyết các điểm nghẽn, dựa trên các ràng buộc. Ví dụ, bạn có cần các yếu tố sau để xử lý vấn đề mở rộng?</p><ul><li>Bộ cân bằng tải</li>
<li>Mở rộng ngang</li>
<li>Bộ nhớ đệm</li>
<li>Phân mảnh cơ sở dữ liệu</li></p><p></ul>Thảo luận về các giải pháp tiềm năng và các đánh đổi. Mọi thứ đều là sự đánh đổi. Giải quyết điểm nghẽn dựa trên <a href="#index-of-system-design-topics" target="_blank" rel="noopener noreferrer">nguyên tắc thiết kế hệ thống mở rộng</a>.</p><h3>Tính toán sơ bộ</h3></p><p>Bạn có thể được yêu cầu thực hiện một số ước tính bằng tay. Tham khảo <a href="#appendix" target="_blank" rel="noopener noreferrer">Phụ lục</a> cho các nguồn sau:</p><ul><li><a href="http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html" target="_blank" rel="noopener noreferrer">Sử dụng tính toán sơ bộ</a></li>
<li><a href="#powers-of-two-table" target="_blank" rel="noopener noreferrer">Bảng lũy thừa của hai</a></li>
<li><a href="#latency-numbers-every-programmer-should-know" target="_blank" rel="noopener noreferrer">Các con số độ trễ mà lập trình viên nào cũng nên biết</a></li></p><p></ul><h3>Nguồn và tài liệu đọc thêm</h3></p><p>Xem các liên kết sau để có ý tưởng rõ hơn về những gì sẽ gặp phải:</p><ul><li><a href="https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="noopener noreferrer">Cách vượt qua phỏng vấn thiết kế hệ thống</a></li>
<li><a href="http://www.hiredintech.com/system-design" target="_blank" rel="noopener noreferrer">Phỏng vấn thiết kế hệ thống</a></li>
<li><a href="https://www.youtube.com/watch?v=ZgdS0EUmn70" target="_blank" rel="noopener noreferrer">Giới thiệu về phỏng vấn kiến trúc và thiết kế hệ thống</a></li>
<li><a href="https://leetcode.com/discuss/career/229177/My-System-Design-Template" target="_blank" rel="noopener noreferrer">Mẫu thiết kế hệ thống</a></li></p><p></ul><h2>Các câu hỏi phỏng vấn thiết kế hệ thống kèm giải pháp</h2></p><blockquote>Các câu hỏi phỏng vấn thiết kế hệ thống phổ biến kèm thảo luận mẫu, mã nguồn, và sơ đồ.</blockquote>
>
<blockquote>Các giải pháp liên kết đến nội dung trong thư mục <code>solutions/</code>.</blockquote></p><p>| Câu hỏi | |
|---|---|
| Thiết kế Pastebin.com (hoặc Bit.ly) | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế dòng thời gian và tìm kiếm của Twitter (hoặc bảng tin và tìm kiếm của Facebook) | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế trình thu thập dữ liệu web | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế Mint.com | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế cấu trúc dữ liệu cho mạng xã hội | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế khoá-giá trị cho công cụ tìm kiếm | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế tính năng xếp hạng bán hàng theo danh mục của Amazon | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thiết kế hệ thống mở rộng cho hàng triệu người dùng trên AWS | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md" target="_blank" rel="noopener noreferrer">Giải pháp</a> |
| Thêm câu hỏi thiết kế hệ thống | <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a> |</p><h3>Thiết kế Pastebin.com (hoặc Bit.ly)</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/pastebin/README.md" target="_blank" rel="noopener noreferrer">Xem bài tập và giải pháp</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4edXG0T.png" alt="Imgur"></p><h3>Thiết kế dòng thời gian và tìm kiếm của Twitter (hoặc bảng tin và tìm kiếm của Facebook)</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/twitter/README.md" target="_blank" rel="noopener noreferrer">Xem bài tập và giải pháp</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jrUBAF7.png" alt="Imgur"></p><h3>Thiết kế trình thu thập dữ liệu web</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/web_crawler/README.md" target="_blank" rel="noopener noreferrer">Xem bài tập và giải pháp</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bWxPtQA.png" alt="Imgur"></p><h3>Design Mint.com</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/mint/README.md" target="_blank" rel="noopener noreferrer">View exercise and solution</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/V5q57vU.png" alt="Imgur"></p><h3>Design the data structures for a social network</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/social_graph/README.md" target="_blank" rel="noopener noreferrer">View exercise and solution</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/cdCv5g7.png" alt="Imgur"></p><h3>Design a key-value store for a search engine</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/query_cache/README.md" target="_blank" rel="noopener noreferrer">View exercise and solution</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/4j99mhe.png" alt="Imgur"></p><h3>Design Amazon's sales ranking by category feature</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/sales_rank/README.md" target="_blank" rel="noopener noreferrer">View exercise and solution</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/MzExP06.png" alt="Imgur"></p><h3>Design a system that scales to millions of users on AWS</h3></p><p><a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/system_design/scaling_aws/README.md" target="_blank" rel="noopener noreferrer">View exercise and solution</a></p><p><img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/jj3A5N8.png" alt="Imgur"></p><h2>Object-oriented design interview questions with solutions</h2></p><blockquote>Common object-oriented design interview questions with sample discussions, code, and diagrams.</blockquote>
>
<blockquote>Solutions linked to content in the <code>solutions/</code> folder.</blockquote></p><p>><strong>Note: This section is under development</strong></p><p>| Question | |
|---|---|
| Thiết kế một bảng băm | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/hash_table/hash_map.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế bộ nhớ đệm truy xuất gần nhất (LRU cache) | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế tổng đài điện thoại | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/call_center/call_center.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế bộ bài | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế bãi đậu xe | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế máy chủ chat | <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/solutions/object_oriented_design/online_chat/online_chat.ipynb" target="_blank" rel="noopener noreferrer">Giải pháp</a>  |
| Thiết kế mảng vòng tròn | <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a>  |
| Thêm một câu hỏi thiết kế hướng đối tượng | <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a> |</p><h2>Chủ đề thiết kế hệ thống: bắt đầu từ đây</h2></p><p>Bạn mới làm quen với thiết kế hệ thống?</p><p>Trước tiên, bạn cần hiểu cơ bản về các nguyên tắc phổ biến, tìm hiểu chúng là gì, cách sử dụng, và điểm mạnh/yếu của chúng.</p><h3>Bước 1: Xem bài giảng video về khả năng mở rộng</h3></p><p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener noreferrer">Bài giảng về khả năng mở rộng tại Harvard</a></p><ul><li>Các chủ đề bao gồm:</li>
    <li>Mở rộng theo chiều dọc</li>
    <li>Mở rộng theo chiều ngang</li>
    <li>Bộ nhớ đệm</li>
    <li>Cân bằng tải</li>
    <li>Nhân bản cơ sở dữ liệu</li>
    <li>Phân vùng cơ sở dữ liệu</li></p><p></ul><h3>Bước 2: Đọc bài viết về khả năng mở rộng</h3></p><p><a href="https://web.archive.org/web/20221030091841/http://www.lecloud.net/tagged/scalability/chrono" target="_blank" rel="noopener noreferrer">Khả năng mở rộng</a></p><ul><li>Các chủ đề bao gồm:</li>
    <li><a href="https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener noreferrer">Bản sao</a></li>
    <li><a href="https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu</a></li>
    <li><a href="https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener noreferrer">Bộ nhớ đệm</a></li>
    <li><a href="https://web.archive.org/web/20220926171507/https://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="noopener noreferrer">Tính bất đồng bộ</a></li></p><p></ul><h3>Các bước tiếp theo</h3></p><p>Tiếp theo, chúng ta sẽ xem xét các sự đánh đổi ở cấp độ cao:</p><ul><li><strong>Hiệu năng</strong> so với <strong>khả năng mở rộng</strong></li>
<li><strong>Độ trễ</strong> so với <strong>thông lượng</strong></li>
<li><strong>Khả dụng</strong> so với <strong>tính nhất quán</strong></li></p><p></ul>Hãy nhớ rằng <strong>mọi thứ đều là sự đánh đổi</strong>.</p><p>Sau đó, chúng ta sẽ đi sâu vào các chủ đề cụ thể hơn như DNS, CDN, và bộ cân bằng tải.</p><h2>Hiệu năng vs khả năng mở rộng</h2></p><p>Một dịch vụ được gọi là <strong>có khả năng mở rộng</strong> nếu nó có thể tăng <strong>hiệu năng</strong> theo tỷ lệ với tài nguyên được thêm vào. Thông thường, tăng hiệu năng nghĩa là phục vụ được nhiều đơn vị công việc hơn, nhưng nó cũng có thể là xử lý các đơn vị công việc lớn hơn, ví dụ như khi bộ dữ liệu tăng lên.<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup></p><p>Một cách khác để nhìn nhận về hiệu năng và khả năng mở rộng:</p><ul><li>Nếu bạn có vấn đề về <strong>hiệu năng</strong>, hệ thống của bạn chậm đối với một người dùng đơn lẻ.</li>
<li>Nếu bạn có vấn đề về <strong>khả năng mở rộng</strong>, hệ thống của bạn nhanh với một người dùng đơn lẻ nhưng chậm khi tải lớn.</li></p><p></ul><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html" target="_blank" rel="noopener noreferrer">Một từ về khả năng mở rộng</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">Khả năng mở rộng, khả dụng, ổn định, mẫu hình</a></li></p><p></ul><h2>Độ trễ vs thông lượng</h2></p><p><strong>Độ trễ</strong> là thời gian để thực hiện một hành động hoặc tạo ra một kết quả.</p><p><strong>Thông lượng</strong> là số lượng các hành động hoặc kết quả đó trên mỗi đơn vị thời gian.</p><p>Thông thường, bạn nên hướng tới <strong>thông lượng tối đa</strong> với <strong>độ trễ chấp nhận được</strong>.</p><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="https://community.cadence.com/cadence_blogs_8/b/fv/posts/understanding-latency-vs-throughput" target="_blank" rel="noopener noreferrer">Hiểu về độ trễ so với thông lượng</a></li></p><p></ul><h2>Khả dụng vs tính nhất quán</h2></p><h3>Định lý CAP</h3></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Nguồn: CAP theorem revisited</a></i>
</p></p><p>Trong một hệ thống máy tính phân tán, bạn chỉ có thể đảm bảo hai trong ba yếu tố sau:</p><ul><li><strong>Tính nhất quán (Consistency)</strong> - Mỗi lần đọc đều nhận được lần ghi mới nhất hoặc báo lỗi</li>
<li><strong>Tính sẵn sàng (Availability)</strong> - Mỗi yêu cầu đều nhận được phản hồi, nhưng không đảm bảo chứa phiên bản mới nhất của thông tin</li>
<li><strong>Chịu phân vùng (Partition Tolerance)</strong> - Hệ thống tiếp tục hoạt động mặc dù bị phân vùng tùy ý do lỗi mạng</li></p><p></ul><em>Mạng lưới không đáng tin cậy, do đó bạn cần hỗ trợ khả năng chịu phân vùng. Bạn sẽ cần phải đánh đổi phần mềm giữa tính nhất quán và tính sẵn sàng.</em></p><p>#### CP - nhất quán và chịu phân vùng</p><p>Chờ phản hồi từ nút bị phân vùng có thể dẫn đến lỗi quá thời gian. CP là lựa chọn tốt nếu yêu cầu kinh doanh của bạn đòi hỏi đọc và ghi nguyên tử.</p><p>#### AP - sẵn sàng và chịu phân vùng</p><p>Phản hồi trả về phiên bản dữ liệu có sẵn nhất trên bất kỳ nút nào, có thể không phải là phiên bản mới nhất. Các thao tác ghi có thể mất thời gian để lan truyền khi phân vùng được giải quyết.</p><p>AP là lựa chọn phù hợp nếu nhu cầu kinh doanh cho phép <a href="#eventual-consistency" target="_blank" rel="noopener noreferrer">tính nhất quán cuối cùng</a> hoặc khi hệ thống cần tiếp tục hoạt động dù xảy ra lỗi bên ngoài.</p><h3>Nguồn và tài liệu tham khảo</h3></p><ul><li><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" target="_blank" rel="noopener noreferrer">CAP theorem revisited</a></li>
<li><a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem" target="_blank" rel="noopener noreferrer">A plain english introduction to CAP theorem</a></li>
<li><a href="https://github.com/henryr/cap-faq" target="_blank" rel="noopener noreferrer">CAP FAQ</a></li>
<li><a href="https://www.youtube.com/watch?v=k-Yaq8AHlFA" target="_blank" rel="noopener noreferrer">The CAP theorem</a></li></p><p></ul><h2>Các mẫu nhất quán</h2></p><p>Khi có nhiều bản sao của cùng một dữ liệu, chúng ta phải lựa chọn cách đồng bộ để khách hàng có cái nhìn nhất quán về dữ liệu. Hãy nhớ lại định nghĩa về tính nhất quán từ <a href="#cap-theorem" target="_blank" rel="noopener noreferrer">định lý CAP</a> - Mỗi lần đọc nhận được lần ghi mới nhất hoặc báo lỗi.</p><h3>Nhất quán yếu</h3></p><p>Sau một lần ghi, các lần đọc có thể thấy hoặc không thấy kết quả đó. Một cách tiếp cận nỗ lực tốt nhất được áp dụng.</p><p>Cách tiếp cận này thường thấy ở các hệ thống như memcached. Tính nhất quán yếu hoạt động tốt trong các trường hợp thời gian thực như VoIP, video chat và trò chơi nhiều người chơi trực tuyến. Ví dụ, nếu bạn đang gọi điện thoại và mất sóng trong vài giây, khi kết nối lại bạn sẽ không nghe được những gì đã nói trong lúc mất kết nối.</p><h3>Tính nhất quán cuối cùng</h3></p><p>Sau một lần ghi, các lần đọc cuối cùng sẽ thấy nó (thường trong vòng mili giây). Dữ liệu được sao chép bất đồng bộ.</p><p>Cách tiếp cận này được sử dụng trong các hệ thống như DNS và email. Tính nhất quán cuối cùng hoạt động tốt trong các hệ thống có độ khả dụng cao.</p><h3>Tính nhất quán mạnh</h3></p><p>Sau một lần ghi, các lần đọc sẽ thấy nó. Dữ liệu được sao chép đồng bộ.</p><p>Cách tiếp cận này được sử dụng trong hệ thống tệp và các hệ quản trị cơ sở dữ liệu quan hệ (RDBMS). Tính nhất quán mạnh phù hợp với các hệ thống cần giao dịch.</p><h3>Nguồn và tài liệu đọc thêm</h3></p><ul><li><a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="noopener noreferrer">Giao dịch trên nhiều trung tâm dữ liệu</a></li></p><p></ul><h2>Mô hình khả dụng</h2></p><p>Có hai mô hình bổ trợ để hỗ trợ khả dụng cao: <strong>chuyển đổi dự phòng</strong> và <strong>sao chép dữ liệu</strong>.</p><h3>Chuyển đổi dự phòng</h3></p><p>#### Chủ động - bị động</p><p>Với chuyển đổi dự phòng chủ động - bị động, các tín hiệu nhịp tim được gửi giữa máy chủ chủ động và máy chủ bị động ở chế độ chờ. Nếu tín hiệu nhịp tim bị gián đoạn, máy chủ bị động sẽ tiếp nhận địa chỉ IP của máy chủ chủ động và tiếp tục dịch vụ.</p><p>Thời gian ngừng hoạt động phụ thuộc vào việc máy chủ bị động đã chạy ở chế độ chờ 'nóng' hay cần khởi động từ chế độ chờ 'lạnh'. Chỉ máy chủ chủ động xử lý lưu lượng.</p><p>Chuyển đổi dự phòng chủ động - bị động còn được gọi là chuyển đổi dự phòng chủ - tớ.</p><p>#### Chủ động - chủ động</p><p>Trong chuyển đổi dự phòng chủ động - chủ động, cả hai máy chủ đều xử lý lưu lượng, phân chia tải giữa chúng.</p><p>Nếu các máy chủ hướng ra công chúng, DNS cần biết về các địa chỉ IP công khai của cả hai máy chủ. Nếu các máy chủ hướng nội bộ, logic ứng dụng cần biết về cả hai máy chủ.</p><p>Chuyển đổi dự phòng chủ động - chủ động còn được gọi là chuyển đổi dự phòng chủ - chủ.</p><h3>Nhược điểm: chuyển đổi dự phòng</h3></p><ul><li>Chuyển đổi dự phòng (fail-over) yêu cầu thêm phần cứng và tăng độ phức tạp.</li>
<li>Có khả năng mất dữ liệu nếu hệ thống chủ động gặp sự cố trước khi dữ liệu mới được ghi được sao chép sang hệ thống bị động.</li></p><p></ul><h3>Sao chép dữ liệu (Replication)</h3></p><p>#### Mô hình chủ-tớ và chủ-chủ</p><p>Chủ đề này được thảo luận thêm trong phần <a href="#database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu</a>:</p><ul><li><a href="#master-slave-replication" target="_blank" rel="noopener noreferrer">Sao chép dữ liệu chủ-tớ</a></li>
<li><a href="#master-master-replication" target="_blank" rel="noopener noreferrer">Sao chép dữ liệu chủ-chủ</a></li></p><p></ul><h3>Tỷ lệ sẵn sàng dưới dạng số liệu</h3></p><p>Tỷ lệ sẵn sàng thường được định lượng bằng thời gian hoạt động (hoặc thời gian ngừng hoạt động) dưới dạng phần trăm thời gian dịch vụ có thể truy cập. Tỷ lệ sẵn sàng thường được đo bằng số lượng số 9--một dịch vụ có tỷ lệ sẵn sàng 99,99% được mô tả là có bốn số 9.</p><p>#### Tỷ lệ sẵn sàng 99,9% - ba số 9</p><p>| Thời lượng             | Thời gian ngừng hoạt động chấp nhận được|
|------------------------|-----------------------------------------|
| Ngừng hoạt động mỗi năm| 8 giờ 45 phút 57 giây                   |
| Ngừng hoạt động mỗi tháng| 43 phút 49,7 giây                    |
| Ngừng hoạt động mỗi tuần| 10 phút 4,8 giây                      |
| Ngừng hoạt động mỗi ngày| 1 phút 26,4 giây                      |</p><p>#### Tỷ lệ sẵn sàng 99,99% - bốn số 9</p><p>| Thời lượng             | Thời gian ngừng hoạt động chấp nhận được|
|------------------------|-----------------------------------------|
| Ngừng hoạt động mỗi năm| 52 phút 35,7 giây                       |
| Ngừng hoạt động mỗi tháng| 4 phút 23 giây                       |
| Ngừng hoạt động mỗi tuần| 1 phút 5 giây                         |
| Ngừng hoạt động mỗi ngày| 8,6 giây                              |</p><p>#### Tỷ lệ sẵn sàng song song so với tuần tự</p><p>Nếu một dịch vụ bao gồm nhiều thành phần có khả năng gặp sự cố, tỷ lệ sẵn sàng tổng thể của dịch vụ phụ thuộc vào việc các thành phần này được sắp xếp theo tuần tự hay song song.</p><p>###### Theo tuần tự</p><p>Tổng độ sẵn sàng giảm khi hai thành phần có độ sẵn sàng < 100% được kết nối nối tiếp:</p><pre><code class="language-">Availability (Total) = Availability (Foo) * Availability (Bar)</code></pre></p><p>Nếu cả <code>Foo</code> và <code>Bar</code> đều có độ sẵn sàng 99,9%, tổng độ sẵn sàng của chúng khi nối tiếp sẽ là 99,8%.</p><p>###### Song song</p><p>Độ sẵn sàng tổng thể tăng lên khi hai thành phần có độ sẵn sàng < 100% được kết nối song song:</p><pre><code class="language-">Availability (Total) = 1 - (1 - Availability (Foo)) * (1 - Availability (Bar))</code></pre>
Nếu cả <code>Foo</code> và <code>Bar</code> đều có mức độ sẵn sàng 99,9%, tổng mức độ sẵn sàng khi chạy song song của chúng sẽ là 99,9999%.</p><h2>Hệ thống tên miền (Domain name system)</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Nguồn: Bài thuyết trình về bảo mật DNS</a></i>
</p></p><p>Hệ thống tên miền (DNS) chuyển đổi một tên miền như www.example.com thành một địa chỉ IP.</p><p>DNS có cấu trúc phân cấp, với một vài máy chủ có thẩm quyền ở cấp cao nhất.  Bộ định tuyến hoặc nhà cung cấp dịch vụ internet (ISP) của bạn cung cấp thông tin về máy chủ DNS cần liên hệ khi thực hiện truy vấn.  Các máy chủ DNS cấp thấp hơn lưu bộ nhớ đệm các ánh xạ, có thể bị lỗi thời do độ trễ truyền bá DNS.  Kết quả DNS cũng có thể được trình duyệt hoặc hệ điều hành của bạn lưu vào bộ đệm trong một khoảng thời gian nhất định, được xác định bởi <a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener noreferrer">thời gian tồn tại (TTL)</a>.</p><ul><li><strong>Bản ghi NS (name server)</strong> - Chỉ định các máy chủ DNS cho miền/phụ miền của bạn.</li>
<li><strong>Bản ghi MX (mail exchange)</strong> - Chỉ định các máy chủ thư để nhận tin nhắn.</li>
<li><strong>Bản ghi A (address)</strong> - Trỏ một tên đến một địa chỉ IP.</li>
<li><strong>CNAME (canonical)</strong> - Trỏ một tên đến tên khác hoặc <code>CNAME</code> (example.com đến www.example.com) hoặc đến bản ghi <code>A</code>.</li></p><p></ul>Các dịch vụ như <a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener noreferrer">CloudFlare</a> và <a href="https://aws.amazon.com/route53/" target="_blank" rel="noopener noreferrer">Route 53</a> cung cấp dịch vụ DNS được quản lý.  Một số dịch vụ DNS có thể định tuyến lưu lượng thông qua các phương pháp khác nhau:</p><ul><li><a href="https://www.jscape.com/blog/load-balancing-algorithms" target="_blank" rel="noopener noreferrer">Vòng lặp trọng số</a></li>
    <li>Ngăn lưu lượng truy cập đến các máy chủ đang bảo trì</li>
    <li>Cân bằng giữa các cụm có kích thước khác nhau</li>
    <li>Kiểm thử A/B</li>
<li><a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-latency.html" target="_blank" rel="noopener noreferrer">Dựa trên độ trễ</a></li>
<li><a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html" target="_blank" rel="noopener noreferrer">Dựa trên vị trí địa lý</a></li></p><p></ul><h3>Nhược điểm: DNS</h3></p><ul><li>Truy cập một máy chủ DNS gây ra độ trễ nhỏ, mặc dù đã được giảm nhẹ bởi cơ chế lưu bộ nhớ đệm như trên.</li>
<li>Quản lý máy chủ DNS có thể phức tạp và thường được quản lý bởi <a href="http://superuser.com/questions/472695/who-controls-the-dns-servers/472729" target="_blank" rel="noopener noreferrer">chính phủ, ISP, và các công ty lớn</a>.</li>
<li>Các dịch vụ DNS gần đây đã bị <a href="http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/" target="_blank" rel="noopener noreferrer">tấn công DDoS</a>, ngăn người dùng truy cập các website như Twitter nếu không biết địa chỉ IP của Twitter.</li></p><p></ul><h3>Nguồn và tài liệu đọc thêm</h3></p><ul><li><a href="https://technet.microsoft.com/en-us/library/dd197427(v=ws.10" target="_blank" rel="noopener noreferrer">Kiến trúc DNS</a>.aspx)</li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener noreferrer">Wikipedia</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/" target="_blank" rel="noopener noreferrer">Các bài viết về DNS</a></li></p><p>
</ul><h2>Mạng phân phối nội dung</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Nguồn: Tại sao sử dụng CDN</a></i>
</p></p><p>Mạng phân phối nội dung (CDN) là một mạng lưới các máy chủ proxy được phân phối toàn cầu, cung cấp nội dung từ các vị trí gần người dùng hơn. Thông thường, các tệp tĩnh như HTML/CSS/JS, ảnh và video được phục vụ từ CDN, mặc dù một số CDN như CloudFront của Amazon hỗ trợ cả nội dung động. Quá trình phân giải DNS của trang web sẽ cho khách truy cập biết nên liên hệ với máy chủ nào.</p><p>Việc cung cấp nội dung từ CDN có thể cải thiện hiệu suất đáng kể theo hai cách:</p><ul><li>Người dùng nhận nội dung từ trung tâm dữ liệu gần họ nhất</li>
<li>Máy chủ của bạn không phải phục vụ các yêu cầu mà CDN đã đáp ứng</li></p><p></ul><h3>Push CDN</h3></p><p>Push CDN nhận nội dung mới mỗi khi có thay đổi trên máy chủ của bạn. Bạn hoàn toàn chịu trách nhiệm cung cấp nội dung, tải trực tiếp lên CDN và viết lại URL để trỏ tới CDN. Bạn có thể cấu hình thời điểm nội dung hết hạn và được cập nhật. Nội dung chỉ được tải lên khi có mới hoặc thay đổi, giảm thiểu lưu lượng nhưng tối đa hóa lưu trữ.</p><p>Các trang web có lưu lượng nhỏ hoặc nội dung không thường xuyên thay đổi rất phù hợp với Push CDN. Nội dung được đặt lên CDN một lần, thay vì bị lấy lại định kỳ.</p><h3>Pull CDN</h3></p><p>Pull CDN lấy nội dung mới từ máy chủ của bạn khi người dùng đầu tiên yêu cầu nội dung đó. Bạn để nội dung trên máy chủ và viết lại URL để trỏ đến CDN. Điều này dẫn đến lần truy cập đầu tiên chậm hơn cho đến khi nội dung được cache trên CDN.</p><p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener noreferrer">Thời gian sống (TTL)</a> xác định thời gian nội dung được cache. Pull CDN giảm thiểu không gian lưu trữ trên CDN, nhưng có thể tạo ra lưu lượng dư thừa nếu các tệp hết hạn và bị lấy lại trước khi chúng thực sự thay đổi.</p><p>Các trang web có lưu lượng lớn hoạt động hiệu quả với Pull CDN, vì lưu lượng được phân tán đều hơn và chỉ những nội dung vừa được yêu cầu mới ở lại trên CDN.</p><h3>Nhược điểm: CDN</h3></p><ul><li>Chi phí CDN có thể đáng kể tùy theo lưu lượng, tuy nhiên nên cân nhắc với chi phí bổ sung nếu không sử dụng CDN.</li>
<li>Nội dung có thể bị lỗi thời nếu được cập nhật trước khi TTL hết hạn.</li>
<li>CDN yêu cầu thay đổi URL của nội dung tĩnh để trỏ tới CDN.</li></p><p></ul><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="https://figshare.com/articles/Globally_distributed_content_delivery/6605972" target="_blank" rel="noopener noreferrer">Phân phối nội dung toàn cầu</a></li>
<li><a href="http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa Push và Pull CDN</a></li>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener noreferrer">Wikipedia</a></li></p><p></ul><h2>Bộ cân bằng tải</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Nguồn: Các mẫu thiết kế hệ thống có khả năng mở rộng</a></i>
</p></p><p>Bộ cân bằng tải phân phối các yêu cầu từ khách hàng đến các tài nguyên tính toán như máy chủ ứng dụng và cơ sở dữ liệu. Trong mỗi trường hợp, bộ cân bằng tải trả về phản hồi từ tài nguyên tính toán đến đúng khách hàng. Bộ cân bằng tải hiệu quả trong việc:</p><ul><li>Ngăn chặn các yêu cầu đến các máy chủ không khỏe mạnh</li>
<li>Ngăn chặn việc quá tải tài nguyên</li>
<li>Giúp loại bỏ điểm lỗi đơn lẻ</li></p><p></ul>Bộ cân bằng tải có thể được triển khai bằng phần cứng (đắt tiền) hoặc phần mềm như HAProxy.</p><p>Các lợi ích bổ sung bao gồm:</p><ul><li><strong>Kết thúc SSL</strong> - Giải mã các yêu cầu đến và mã hóa phản hồi từ máy chủ để các máy chủ backend không phải thực hiện những tác vụ tốn kém này</li>
    <li>Loại bỏ nhu cầu cài đặt <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">chứng chỉ X.509</a> trên mỗi máy chủ</li>
<li><strong>Duy trì phiên</strong> - Phát hành cookie và định tuyến các yêu cầu của một khách hàng cụ thể đến cùng một phiên bản nếu ứng dụng web không lưu trữ phiên</li></p><p></ul>Để bảo vệ chống lại sự cố, thông thường sẽ thiết lập nhiều bộ cân bằng tải, ở chế độ <a href="#active-passive" target="_blank" rel="noopener noreferrer">active-passive</a> hoặc <a href="#active-active" target="_blank" rel="noopener noreferrer">active-active</a>.</p><p>Bộ cân bằng tải có thể định tuyến lưu lượng dựa trên nhiều chỉ số khác nhau, bao gồm:</p><ul><li>Ngẫu nhiên</li>
<li>Tải ít nhất</li>
<li>Phiên/cookie</li>
<li><a href="https://www.g33kinfo.com/info/round-robin-vs-weighted-round-robin-lb" target="_blank" rel="noopener noreferrer">Vòng luân phiên hoặc vòng luân phiên có trọng số</a></li>
<li><a href="#layer-4-load-balancing" target="_blank" rel="noopener noreferrer">Tầng 4</a></li>
<li><a href="#layer-7-load-balancing" target="_blank" rel="noopener noreferrer">Tầng 7</a></li></p><p></ul><h3>Cân bằng tải tầng 4</h3></p><p>Bộ cân bằng tải tầng 4 xem xét thông tin tại <a href="#communication" target="_blank" rel="noopener noreferrer">tầng vận chuyển</a> để quyết định cách phân phối yêu cầu. Thông thường, điều này liên quan đến địa chỉ IP nguồn, đích và các cổng trong phần đầu, nhưng không phải nội dung của gói tin. Bộ cân bằng tải tầng 4 chuyển tiếp các gói mạng đến và từ máy chủ upstream, thực hiện <a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener noreferrer">Chuyển đổi địa chỉ mạng (NAT)</a>.</p><h3>Cân bằng tải tầng 7</h3>
Bộ cân bằng tải tầng 7 kiểm tra <a href="#communication" target="_blank" rel="noopener noreferrer">tầng ứng dụng</a> để quyết định cách phân phối các yêu cầu. Điều này có thể liên quan đến nội dung của tiêu đề, thông điệp và cookie. Bộ cân bằng tải tầng 7 sẽ chấm dứt lưu lượng mạng, đọc thông điệp, đưa ra quyết định cân bằng tải, sau đó mở kết nối đến máy chủ đã được chọn. Ví dụ, bộ cân bằng tải tầng 7 có thể chuyển hướng lưu lượng video đến các máy chủ lưu trữ video trong khi chuyển hướng lưu lượng thanh toán người dùng nhạy cảm đến các máy chủ đã được tăng cường bảo mật.</p><p>Đổi lại cho sự linh hoạt, cân bằng tải tầng 4 yêu cầu ít thời gian và tài nguyên tính toán hơn tầng 7, mặc dù tác động đến hiệu suất có thể không đáng kể trên phần cứng phổ thông hiện đại.</p><h3>Mở rộng theo chiều ngang</h3></p><p>Bộ cân bằng tải cũng giúp mở rộng theo chiều ngang, cải thiện hiệu suất và độ sẵn sàng. Mở rộng bằng các máy phổ thông tiết kiệm chi phí hơn và mang lại độ sẵn sàng cao hơn so với mở rộng một máy chủ duy nhất trên phần cứng đắt tiền, gọi là <strong>Mở rộng theo chiều dọc</strong>. Việc tuyển dụng nhân sự làm việc với phần cứng phổ thông cũng dễ dàng hơn so với các hệ thống doanh nghiệp chuyên biệt.</p><p>#### Nhược điểm: mở rộng theo chiều ngang</p><ul><li>Mở rộng theo chiều ngang làm tăng độ phức tạp và liên quan đến việc nhân bản máy chủ</li>
    <li>Máy chủ nên là không trạng thái: không nên chứa dữ liệu liên quan đến người dùng như phiên hoặc ảnh đại diện</li>
    <li>Phiên có thể được lưu trong kho dữ liệu tập trung như <a href="#database" target="_blank" rel="noopener noreferrer">cơ sở dữ liệu</a> (SQL, NoSQL) hoặc <a href="#cache" target="_blank" rel="noopener noreferrer">bộ nhớ đệm</a> lâu dài (Redis, Memcached)</li>
<li>Các máy chủ phía dưới như bộ đệm và cơ sở dữ liệu cần xử lý nhiều kết nối đồng thời hơn khi các máy chủ phía trên mở rộng</li></p><p></ul><h3>Nhược điểm: bộ cân bằng tải</h3></p><ul><li>Bộ cân bằng tải có thể trở thành nút thắt về hiệu suất nếu không đủ tài nguyên hoặc cấu hình không đúng.</li>
<li>Việc thêm bộ cân bằng tải để loại bỏ điểm lỗi đơn lại làm tăng độ phức tạp.</li>
<li>Một bộ cân bằng tải đơn là một điểm lỗi đơn, cấu hình nhiều bộ cân bằng tải sẽ càng tăng độ phức tạp.</li></p><p></ul><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener noreferrer">Kiến trúc NGINX</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener noreferrer">Hướng dẫn kiến trúc HAProxy</a></li>
<li><a href="https://web.archive.org/web/20220530193911/https://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener noreferrer">Khả năng mở rộng</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing" target="_blank" rel="noopener noreferrer">Wikipedia</a>)</li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener noreferrer">Cân bằng tải tầng 4</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener noreferrer">Cân bằng tải tầng 7</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html" target="_blank" rel="noopener noreferrer">Cấu hình listener ELB</a></li></p><p></ul><h2>Reverse proxy (máy chủ web)</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Nguồn: Wikipedia</a></i>
  <br/>
</p></p><p>Reverse proxy là một máy chủ web tập trung các dịch vụ nội bộ và cung cấp giao diện thống nhất cho công chúng.  Các yêu cầu từ khách hàng sẽ được chuyển tiếp đến máy chủ có thể xử lý trước khi reverse proxy trả về phản hồi của máy chủ cho khách hàng.</p><p>Các lợi ích bổ sung bao gồm:</p><ul><li><strong>Tăng cường bảo mật</strong> - Ẩn thông tin về các máy chủ backend, chặn danh sách đen IP, giới hạn số lượng kết nối trên mỗi khách hàng</li>
<li><strong>Tăng khả năng mở rộng và linh hoạt</strong> - Khách hàng chỉ nhìn thấy IP của reverse proxy, cho phép bạn mở rộng máy chủ hoặc thay đổi cấu hình của chúng</li>
<li><strong>Chấm dứt SSL</strong> - Giải mã các yêu cầu đến và mã hóa phản hồi của máy chủ để các máy chủ backend không phải thực hiện những thao tác có thể tốn kém này</li>
    <li>Loại bỏ nhu cầu cài đặt <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">chứng chỉ X.509</a> trên mỗi máy chủ</li>
<li><strong>Nén</strong> - Nén phản hồi của máy chủ</li>
<li><strong>Bộ nhớ đệm</strong> - Trả về phản hồi cho các yêu cầu đã được lưu trong bộ nhớ đệm</li>
<li><strong>Nội dung tĩnh</strong> - Phục vụ trực tiếp nội dung tĩnh</li>
    <li>HTML/CSS/JS</li>
    <li>Ảnh</li>
    <li>Video</li>
    <li>V.v.</li></p><p></ul><h3>Bộ cân bằng tải vs reverse proxy</h3></p><ul><li>Triển khai bộ cân bằng tải rất hữu ích khi bạn có nhiều máy chủ.  Thường thì các bộ cân bằng tải sẽ định tuyến lưu lượng đến một tập hợp các máy chủ phục vụ cùng chức năng.</li>
<li>Reverse proxy có thể hữu ích ngay cả khi chỉ có một máy chủ web hoặc máy chủ ứng dụng, mở ra các lợi ích như đã mô tả ở phần trước.</li>
<li>Các giải pháp như NGINX và HAProxy có thể hỗ trợ cả reverse proxy tầng 7 và cân bằng tải.</li></p><p></ul><h3>Bất lợi: reverse proxy</h3></p><ul><li>Việc giới thiệu reverse proxy làm tăng độ phức tạp.</li>
<li>Một reverse proxy duy nhất là điểm lỗi duy nhất, cấu hình nhiều reverse proxy (ví dụ như <a href="https://en.wikipedia.org/wiki/Failover" target="_blank" rel="noopener noreferrer">failover</a>) càng làm tăng độ phức tạp.</li></p><p></ul><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/" target="_blank" rel="noopener noreferrer">Reverse proxy vs load balancer</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener noreferrer">Kiến trúc NGINX</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener noreferrer">Hướng dẫn kiến trúc HAProxy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="noopener noreferrer">Wikipedia</a></li></p><p></ul><h2>Tầng ứng dụng</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yB5SYwm.png">
  <br/></p><p>  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Nguồn: Giới thiệu về kiến trúc hệ thống cho khả năng mở rộng</a></i>
</p></p><p>Tách biệt tầng web khỏi tầng ứng dụng (còn gọi là tầng nền tảng) cho phép bạn mở rộng và cấu hình cả hai tầng một cách độc lập. Việc thêm một API mới dẫn đến việc bổ sung máy chủ ứng dụng mà không nhất thiết phải thêm máy chủ web bổ sung. Nguyên tắc <strong>single responsibility</strong> khuyến khích các dịch vụ nhỏ và tự động làm việc cùng nhau. Các nhóm nhỏ với các dịch vụ nhỏ có thể lập kế hoạch phát triển nhanh chóng một cách tích cực hơn.</p><p>Các worker ở tầng ứng dụng cũng giúp kích hoạt <a href="#asynchronism" target="_blank" rel="noopener noreferrer">tính bất đồng bộ</a>.</p><h3>Microservices</h3></p><p>Liên quan đến chủ đề này là <a href="https://vi.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener noreferrer">microservices</a>, có thể được mô tả là một bộ các dịch vụ nhỏ, mô-đun, có thể triển khai độc lập. Mỗi dịch vụ chạy một tiến trình riêng biệt và giao tiếp qua một cơ chế nhẹ, được xác định rõ nhằm phục vụ mục tiêu kinh doanh. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup></p><p>Pinterest, ví dụ, có thể có các microservice như: hồ sơ người dùng, theo dõi, nguồn cấp, tìm kiếm, tải ảnh lên, v.v.</p><h3>Khám phá dịch vụ</h3></p><p>Các hệ thống như <a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener noreferrer">Consul</a>, <a href="https://coreos.com/etcd/docs/latest" target="_blank" rel="noopener noreferrer">Etcd</a>, và <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">Zookeeper</a> có thể giúp các dịch vụ tìm nhau bằng cách theo dõi tên, địa chỉ và cổng đã đăng ký. <a href="https://www.consul.io/intro/getting-started/checks.html" target="_blank" rel="noopener noreferrer">Kiểm tra sức khỏe</a> giúp xác minh tính toàn vẹn của dịch vụ và thường được thực hiện thông qua một endpoint <a href="#hypertext-transfer-protocol-http" target="_blank" rel="noopener noreferrer">HTTP</a>. Cả Consul và Etcd đều có <a href="#key-value-store" target="_blank" rel="noopener noreferrer">kho lưu trữ key-value</a> tích hợp sẵn, hữu ích để lưu giá trị cấu hình và dữ liệu chia sẻ khác.</p><h3>Nhược điểm: tầng ứng dụng</h3></p><ul><li>Thêm tầng ứng dụng với các dịch vụ liên kết lỏng lẻo đòi hỏi một cách tiếp cận khác về mặt kiến trúc, vận hành và quy trình (so với hệ thống nguyên khối).</li>
<li>Microservice có thể làm tăng độ phức tạp trong triển khai và vận hành.</li></p><p></ul><h3>Nguồn và tài liệu đọc thêm</h3></p><ul><li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale" target="_blank" rel="noopener noreferrer">Giới thiệu về kiến trúc hệ thống cho khả năng mở rộng</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">Crack the system design interview</a></li>
<li><a href="https://vi.wikipedia.org/wiki/Ki%E1%BA%BFn_tr%C3%BAc_h%C6%B0%E1%BB%9Bng_d%E1%BB%8Bch_v%E1%BB%A5" target="_blank" rel="noopener noreferrer">Kiến trúc hướng dịch vụ</a></li>
<li><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">Giới thiệu về Zookeeper</a></li>
<li><a href="https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/" target="_blank" rel="noopener noreferrer">Những điều bạn cần biết về xây dựng microservice</a></li></p><p></ul><h2>Cơ sở dữ liệu</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Nguồn: Mở rộng lên 10 triệu người dùng đầu tiên</a></i>
</p></p><h3>Hệ quản trị cơ sở dữ liệu quan hệ (RDBMS)</h3></p><p>Một cơ sở dữ liệu quan hệ như SQL là một tập hợp các mục dữ liệu được tổ chức trong các bảng.</p><p><strong>ACID</strong> là một tập hợp các thuộc tính của <a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener noreferrer">giao dịch</a> trong cơ sở dữ liệu quan hệ.</p><ul><li><strong>Atomicity</strong> - Mỗi giao dịch là tất cả hoặc không có gì</li>
<li><strong>Consistency</strong> - Bất kỳ giao dịch nào cũng sẽ đưa cơ sở dữ liệu từ một trạng thái hợp lệ này sang trạng thái hợp lệ khác</li>
<li><strong>Isolation</strong> - Việc thực thi đồng thời các giao dịch sẽ cho kết quả giống như khi các giao dịch được thực thi tuần tự</li>
<li><strong>Durability</strong> - Một khi giao dịch đã được cam kết, nó sẽ được giữ nguyên</li></p><p></ul>Có nhiều kỹ thuật để mở rộng quy mô cơ sở dữ liệu quan hệ: <strong>nhân bản chủ-tớ</strong>, <strong>nhân bản chủ-chủ</strong>, <strong>liên kết</strong>, <strong>phân mảnh</strong>, <strong>phi chuẩn hóa</strong>, và <strong>tối ưu hóa SQL</strong>.</p><p>#### Nhân bản chủ-tớ</p><p>Chủ phục vụ cả đọc và ghi, nhân bản các thao tác ghi đến một hoặc nhiều tớ, các tớ chỉ phục vụ đọc. Các tớ cũng có thể nhân bản đến các tớ bổ sung theo dạng cây. Nếu chủ bị ngắt kết nối, hệ thống có thể tiếp tục hoạt động ở chế độ chỉ đọc cho đến khi một tớ được nâng cấp thành chủ hoặc một chủ mới được cung cấp.</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Nguồn: Scalability, availability, stability, patterns</a></i>
</p></p><p>##### Nhược điểm: nhân bản chủ-tớ</p><ul><li>Cần bổ sung logic để nâng cấp một tớ thành chủ.</li>
<li>Xem <a href="#disadvantages-replication" target="_blank" rel="noopener noreferrer">Nhược điểm: replication</a> cho các điểm liên quan đến <strong>cả</strong> nhân bản chủ-tớ và chủ-chủ.</li></p><p></ul>#### Nhân bản chủ-chủ</p><p>Cả hai chủ đều phục vụ đọc và ghi và phối hợp với nhau về các thao tác ghi. Nếu một trong hai chủ gặp sự cố, hệ thống vẫn có thể tiếp tục hoạt động với cả đọc và ghi.</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Nguồn: Scalability, availability, stability, patterns</a></i>
</p></p><p>##### Nhược điểm: nhân bản chủ-chủ</p><ul><li>Bạn sẽ cần bộ cân bằng tải hoặc cần sửa đổi logic ứng dụng để xác định vị trí ghi dữ liệu.</li>
<li>Hầu hết các hệ thống chủ-chủ hoặc là nhất quán lỏng lẻo (vi phạm ACID) hoặc có độ trễ ghi tăng lên do đồng bộ hóa.</li>
<li>Việc giải quyết xung đột trở nên quan trọng hơn khi có nhiều node ghi hơn và khi độ trễ tăng lên.</li>
<li>Xem <a href="#disadvantages-replication" target="_blank" rel="noopener noreferrer">Nhược điểm: nhân bản</a> để biết các điểm liên quan đến <strong>cả</strong> master-slave và master-master.</li></p><p></ul>##### Nhược điểm: nhân bản</p><ul><li>Có khả năng mất dữ liệu nếu master bị lỗi trước khi bất kỳ dữ liệu mới nào được ghi có thể được nhân bản đến các node khác.</li>
<li>Các ghi lại được phát lại đến các bản sao đọc. Nếu có nhiều ghi, các bản sao đọc có thể bị quá tải bởi việc phát lại ghi và không thể thực hiện nhiều đọc.</li>
<li>Càng nhiều slave đọc thì càng phải nhân bản nhiều, dẫn đến độ trễ nhân bản lớn hơn.</li>
<li>Trên một số hệ thống, ghi vào master có thể sinh ra nhiều luồng để ghi song song, trong khi bản sao đọc chỉ hỗ trợ ghi tuần tự với một luồng duy nhất.</li>
<li>Nhân bản bổ sung thêm phần cứng và sự phức tạp.</li></p><p></ul>##### Nguồn và tài liệu tham khảo thêm: nhân bản</p><ul><li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">Scalability, availability, stability, patterns</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="noopener noreferrer">Nhân bản đa master</a></li></p><p></ul>#### Federation</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Nguồn: Scaling up to your first 10 million users</a></i>
</p></p><p>Federation (hoặc phân vùng chức năng) chia nhỏ cơ sở dữ liệu theo chức năng. Ví dụ, thay vì một cơ sở dữ liệu đơn lẻ, nguyên khối, bạn có thể có ba cơ sở dữ liệu: <strong>forums</strong>, <strong>users</strong>, và <strong>products</strong>, dẫn đến ít lưu lượng đọc và ghi đến mỗi cơ sở dữ liệu hơn và do đó ít độ trễ nhân bản hơn. Các cơ sở dữ liệu nhỏ hơn giúp nhiều dữ liệu có thể nằm trong bộ nhớ hơn, từ đó tăng số lần truy cập cache nhờ cải thiện tính cục bộ của cache. Không có master trung tâm duy nhất để tuần tự hóa ghi, bạn có thể ghi song song, tăng thông lượng.</p><p>##### Nhược điểm: federation</p><ul><li>Federation không hiệu quả nếu lược đồ của bạn yêu cầu các chức năng hoặc bảng quá lớn.</li>
<li>Bạn sẽ cần cập nhật logic ứng dụng để xác định cơ sở dữ liệu nào cần đọc và ghi.</li>
<li>Kết hợp dữ liệu từ hai cơ sở dữ liệu sẽ phức tạp hơn với một <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers" target="_blank" rel="noopener noreferrer">server link</a>.</li>
<li>Federation bổ sung thêm phần cứng và sự phức tạp.</li></p><p></ul>##### Nguồn và tài liệu tham khảo thêm: federation</p><ul><li><a href="https://www.youtube.com/watch?v=kKjm4ehYiMs" target="_blank" rel="noopener noreferrer">Scaling up to your first 10 million users</a></li></p><p></ul>#### Sharding</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Nguồn: Scalability, availability, stability, patterns</a></i>
</p></p><p>Sharding phân phối dữ liệu qua các cơ sở dữ liệu khác nhau sao cho mỗi cơ sở dữ liệu chỉ quản lý một phần của dữ liệu. Lấy ví dụ với cơ sở dữ liệu người dùng, khi số lượng người dùng tăng lên, nhiều shard hơn sẽ được thêm vào cụm.</p><p>Tương tự như lợi ích của <a href="#federation" target="_blank" rel="noopener noreferrer">federation</a>, sharding giúp giảm lưu lượng đọc và ghi, giảm việc nhân bản dữ liệu, và tăng tỷ lệ cache hit. Kích thước chỉ mục cũng được giảm, thường cải thiện hiệu năng với các truy vấn nhanh hơn. Nếu một shard gặp sự cố, các shard khác vẫn hoạt động, tuy nhiên bạn sẽ muốn thêm một số hình thức nhân bản để tránh mất dữ liệu. Giống như federation, không có một master trung tâm duy nhất serial hóa việc ghi, cho phép bạn ghi song song với thông lượng cao hơn.</p><p>Các cách phổ biến để shard bảng người dùng là dựa vào ký tự đầu của họ người dùng hoặc vị trí địa lý của người dùng.</p><p>##### Nhược điểm: sharding</p><ul><li>Bạn sẽ cần cập nhật logic ứng dụng để làm việc với các shard, điều này có thể dẫn đến các truy vấn SQL phức tạp.</li>
<li>Phân phối dữ liệu có thể trở nên mất cân đối trong một shard. Ví dụ, một nhóm người dùng mạnh trên một shard có thể dẫn đến tải tăng lên cho shard đó so với các shard khác.</li>
    <li>Cân bằng lại dữ liệu làm tăng độ phức tạp. Hàm sharding dựa trên <a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener noreferrer">consistent hashing</a> có thể giảm lượng dữ liệu cần chuyển.</li>
<li>Kết nối dữ liệu từ nhiều shard trở nên phức tạp hơn.</li>
<li>Sharding thêm nhiều phần cứng và độ phức tạp bổ sung.</li></p><p></ul>##### Nguồn và đọc thêm: sharding</p><ul><li><a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener noreferrer">Sự xuất hiện của shard</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shard_(database_architecture" target="_blank" rel="noopener noreferrer">Kiến trúc cơ sở dữ liệu shard</a>)</li>
<li><a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener noreferrer">Consistent hashing</a></li></p><p></ul>#### Denormalization</p><p>Denormalization cố gắng cải thiện hiệu năng đọc bằng cách hy sinh một phần hiệu năng ghi. Các bản sao dư thừa của dữ liệu được ghi vào nhiều bảng để tránh các phép nối đắt đỏ. Một số RDBMS như <a href="https://en.wikipedia.org/wiki/PostgreSQL" target="_blank" rel="noopener noreferrer">PostgreSQL</a> và Oracle hỗ trợ <a href="https://en.wikipedia.org/wiki/Materialized_view" target="_blank" rel="noopener noreferrer">materialized views</a> giúp lưu trữ thông tin dư thừa và giữ các bản sao dư thừa nhất quán.</p><p>Khi dữ liệu được phân phối bằng các kỹ thuật như <a href="#federation" target="_blank" rel="noopener noreferrer">federation</a> và <a href="#sharding" target="_blank" rel="noopener noreferrer">sharding</a>, việc quản lý các phép nối qua các trung tâm dữ liệu càng làm tăng độ phức tạp. Denormalization có thể giúp tránh được nhu cầu thực hiện các phép nối phức tạp như vậy.</p><p>Trong hầu hết các hệ thống, số lần đọc có thể vượt xa số lần ghi với tỷ lệ 100:1 hoặc thậm chí 1000:1. Một lần đọc dẫn đến phép nối dữ liệu phức tạp có thể rất tốn kém, tiêu tốn nhiều thời gian cho các thao tác ổ đĩa.</p><p>##### Nhược điểm: denormalization</p><ul><li>Dữ liệu bị trùng lặp.</li>
<li>Các ràng buộc có thể giúp các bản sao dư thừa của thông tin luôn đồng bộ, làm tăng độ phức tạp của thiết kế cơ sở dữ liệu.</li>
<li>Cơ sở dữ liệu denormalized dưới tải ghi lớn có thể hoạt động kém hơn so với cơ sở dữ liệu normalized.</li></p><p></ul>###### Nguồn và đọc thêm: denormalization</p><ul><li><a href="https://vi.wikipedia.org/wiki/Denormalization" target="_blank" rel="noopener noreferrer">Phi chuẩn hóa (Denormalization)</a></li></p><p></ul>#### Tinh chỉnh SQL</p><p>Tinh chỉnh SQL là một chủ đề rộng lớn và nhiều <a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning" target="_blank" rel="noopener noreferrer">sách</a> đã được viết làm tài liệu tham khảo.</p><p>Điều quan trọng là phải <strong>kiểm thử hiệu năng</strong> và <strong>phân tích hồ sơ</strong> để mô phỏng và phát hiện các nút thắt cổ chai.</p><ul><li><strong>Kiểm thử hiệu năng</strong> - Mô phỏng tình huống tải cao với các công cụ như <a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener noreferrer">ab</a>.</li>
<li><strong>Phân tích hồ sơ</strong> - Kích hoạt các công cụ như <a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener noreferrer">slow query log</a> để giúp theo dõi các vấn đề về hiệu năng.</li></p><p></ul>Kiểm thử hiệu năng và phân tích hồ sơ có thể giúp bạn xác định các tối ưu hóa sau.</p><p>##### Siết chặt lược đồ</p><ul><li>MySQL ghi ra đĩa thành các khối liên tiếp để truy cập nhanh.</li>
<li>Dùng <code>CHAR</code> thay vì <code>VARCHAR</code> cho các trường có độ dài cố định.</li>
    <li><code>CHAR</code> thực sự cho phép truy cập ngẫu nhiên nhanh, trong khi với <code>VARCHAR</code>, bạn phải tìm điểm kết thúc của chuỗi trước khi chuyển sang chuỗi tiếp theo.</li>
<li>Dùng <code>TEXT</code> cho các khối văn bản lớn như bài đăng blog. <code>TEXT</code> cũng cho phép tìm kiếm kiểu boolean. Dùng trường <code>TEXT</code> sẽ lưu một con trỏ trên đĩa để xác định vị trí khối văn bản.</li>
<li>Dùng <code>INT</code> cho các số lớn lên đến 2^32 hoặc 4 tỷ.</li>
<li>Dùng <code>DECIMAL</code> cho tiền tệ để tránh lỗi biểu diễn số thực.</li>
<li>Tránh lưu trữ các <code>BLOB</code> lớn, thay vào đó lưu vị trí lấy đối tượng.</li>
<li><code>VARCHAR(255)</code> là số lượng ký tự lớn nhất có thể được đếm trong một số 8 bit, thường tối đa hóa việc sử dụng một byte ở một số Hệ quản trị CSDL.</li>
<li>Đặt ràng buộc <code>NOT NULL</code> khi áp dụng để <a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener noreferrer">cải thiện hiệu suất tìm kiếm</a>.</li></p><p></ul>##### Sử dụng chỉ mục tốt</p><ul><li>Các cột mà bạn truy vấn (<code>SELECT</code>, <code>GROUP BY</code>, <code>ORDER BY</code>, <code>JOIN</code>) có thể nhanh hơn với chỉ mục.</li>
<li>Chỉ mục thường được biểu diễn dưới dạng <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener noreferrer">B-tree</a> tự cân bằng giúp dữ liệu được sắp xếp và cho phép tìm kiếm, truy cập tuần tự, chèn, xóa trong thời gian logarit.</li>
<li>Đặt chỉ mục có thể giữ dữ liệu trong bộ nhớ, yêu cầu thêm không gian lưu trữ.</li>
<li>Việc ghi dữ liệu cũng có thể chậm hơn vì cần cập nhật chỉ mục.</li>
<li>Khi tải lượng lớn dữ liệu, có thể nhanh hơn nếu tắt chỉ mục, tải dữ liệu, rồi xây dựng lại chỉ mục.</li></p><p></ul>##### Tránh các phép nối tốn kém</p><ul><li><a href="#denormalization" target="_blank" rel="noopener noreferrer">Phi chuẩn hóa</a> khi hiệu năng yêu cầu.</li></p><p></ul>##### Phân vùng bảng</p><ul><li>Chia nhỏ một bảng bằng cách đưa các điểm nóng vào một bảng riêng biệt để giúp giữ nó trong bộ nhớ.</li></p><p></ul>##### Tinh chỉnh bộ nhớ đệm truy vấn</p><ul><li>Trong một số trường hợp, <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener noreferrer">bộ nhớ đệm truy vấn</a> có thể dẫn đến <a href="https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/" target="_blank" rel="noopener noreferrer">vấn đề hiệu năng</a>.</li></p><p></ul>##### Nguồn và tài liệu đọc thêm: Tinh chỉnh SQL</p><ul><li><a href="http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/" target="_blank" rel="noopener noreferrer">Mẹo tối ưu hóa truy vấn MySQL</a></li>
<li><a href="http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l" target="_blank" rel="noopener noreferrer">Có lý do gì để VARCHAR(255) được sử dụng phổ biến như vậy?</a></li>
<li><a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener noreferrer">Giá trị null ảnh hưởng đến hiệu suất như thế nào?</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener noreferrer">Nhật ký truy vấn chậm</a></li></p><p></ul><h3>NoSQL</h3></p><p>NoSQL là tập hợp các mục dữ liệu được thể hiện bằng <strong>key-value store</strong>, <strong>document store</strong>, <strong>wide column store</strong>, hoặc <strong>graph database</strong>. Dữ liệu được phi chuẩn hóa và các phép nối thường được thực hiện trong mã ứng dụng. Hầu hết các kho NoSQL không có giao dịch ACID thực sự và ưu tiên <a href="#eventual-consistency" target="_blank" rel="noopener noreferrer">tính nhất quán cuối cùng</a>.</p><p><strong>BASE</strong> thường được dùng để mô tả các đặc tính của cơ sở dữ liệu NoSQL. So với <a href="#cap-theorem" target="_blank" rel="noopener noreferrer">Định lý CAP</a>, BASE chọn tính sẵn sàng thay vì tính nhất quán.</p><ul><li><strong>Basically available</strong> - hệ thống đảm bảo tính sẵn sàng.</li>
<li><strong>Soft state</strong> - trạng thái của hệ thống có thể thay đổi theo thời gian, ngay cả khi không có đầu vào.</li>
<li><strong>Eventual consistency</strong> - hệ thống sẽ trở nên nhất quán sau một khoảng thời gian, miễn là hệ thống không nhận thêm đầu vào trong khoảng thời gian đó.</li></p><p></ul>Ngoài việc lựa chọn giữa <a href="#sql-or-nosql" target="_blank" rel="noopener noreferrer">SQL hoặc NoSQL</a>, việc hiểu loại cơ sở dữ liệu NoSQL nào phù hợp nhất với trường hợp sử dụng của bạn cũng rất hữu ích. Chúng ta sẽ xem xét <strong>key-value store</strong>, <strong>document store</strong>, <strong>wide column store</strong>, và <strong>graph database</strong> ở phần tiếp theo.</p><p>#### Key-value store</p><blockquote>Trừu tượng: bảng băm</blockquote></p><p>Một key-value store thường cho phép đọc và ghi với độ phức tạp O(1), thường được hỗ trợ bởi bộ nhớ hoặc SSD. Các kho dữ liệu có thể duy trì khóa theo <a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener noreferrer">thứ tự từ điển</a>, cho phép truy xuất phạm vi khóa hiệu quả. Key-value store có thể lưu trữ siêu dữ liệu cùng với giá trị.</p><p>Key-value store cung cấp hiệu năng cao và thường được dùng cho các mô hình dữ liệu đơn giản hoặc dữ liệu thay đổi nhanh, như lớp bộ nhớ đệm trong RAM. Vì chúng chỉ cung cấp một tập hợp thao tác hạn chế, độ phức tạp sẽ chuyển sang tầng ứng dụng nếu cần thêm thao tác.</p><p>Key-value store là nền tảng cho các hệ thống phức tạp hơn như document store, và trong một số trường hợp, graph database.</p><p>##### Nguồn và tài liệu đọc thêm: key-value store</p><ul><li><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu key-value</a></li>
<li><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener noreferrer">Nhược điểm của key-value store</a></li>
<li><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener noreferrer">Kiến trúc Redis</a></li>
<li><a href="https://adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener noreferrer">Kiến trúc Memcached</a></li></p><p></ul>#### Kho lưu trữ tài liệu</p><blockquote>Trừu tượng: kho lưu trữ key-value với tài liệu được lưu trữ dưới dạng giá trị</blockquote></p><p>Kho lưu trữ tài liệu tập trung vào các tài liệu (XML, JSON, nhị phân, v.v.), trong đó một tài liệu lưu trữ toàn bộ thông tin cho một đối tượng nhất định. Kho lưu trữ tài liệu cung cấp API hoặc ngôn ngữ truy vấn để truy vấn dựa trên cấu trúc nội bộ của chính tài liệu đó. <em>Lưu ý, nhiều kho key-value cũng bao gồm các chức năng làm việc với siêu dữ liệu của giá trị, làm mờ ranh giới giữa hai loại lưu trữ này.</em></p><p>Tùy thuộc vào cách triển khai bên dưới, tài liệu được tổ chức theo bộ sưu tập, thẻ, siêu dữ liệu hoặc thư mục. Mặc dù tài liệu có thể được tổ chức hoặc nhóm lại, các trường của tài liệu có thể hoàn toàn khác nhau giữa các tài liệu.</p><p>Một số kho lưu trữ tài liệu như <a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener noreferrer">MongoDB</a> và <a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener noreferrer">CouchDB</a> còn cung cấp ngôn ngữ giống SQL để thực hiện các truy vấn phức tạp. <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="noopener noreferrer">DynamoDB</a> hỗ trợ cả key-value và tài liệu.</p><p>Kho lưu trữ tài liệu mang lại tính linh hoạt cao và thường được sử dụng cho dữ liệu thay đổi không thường xuyên.</p><p>##### Nguồn và đọc thêm: kho lưu trữ tài liệu</p><ul><li><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu hướng tài liệu</a></li>
<li><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc MongoDB</a></li>
<li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener noreferrer">Kiến trúc CouchDB</a></li>
<li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener noreferrer">Kiến trúc Elasticsearch</a></li></p><p></ul>#### Kho lưu trữ cột rộng</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Nguồn: SQL & NoSQL, lịch sử ngắn gọn</a></i>
</p></p><blockquote>Trừu tượng: bản đồ lồng nhau <code>ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>></code></blockquote></p><p>Đơn vị dữ liệu cơ bản của kho lưu trữ cột rộng là một cột (cặp tên/giá trị). Một cột có thể được nhóm thành các họ cột (tương tự như bảng trong SQL). Họ siêu cột tiếp tục nhóm các họ cột. Bạn có thể truy cập từng cột độc lập bằng khóa dòng, và các cột có cùng khóa dòng tạo thành một dòng. Mỗi giá trị chứa một dấu thời gian để phân phiên bản và giải quyết xung đột.</p><p>Google đã giới thiệu <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">Bigtable</a> là kho lưu trữ cột rộng đầu tiên, ảnh hưởng đến <a href="https://www.edureka.co/blog/hbase-architecture/" target="_blank" rel="noopener noreferrer">HBase</a> mã nguồn mở thường dùng trong hệ sinh thái Hadoop, và <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html" target="_blank" rel="noopener noreferrer">Cassandra</a> của Facebook. Các kho như BigTable, HBase, và Cassandra duy trì các khóa theo thứ tự từ điển, cho phép truy xuất hiệu quả các dải khóa lựa chọn.</p><p>Kho lưu trữ cột rộng cung cấp tính sẵn sàng cao và khả năng mở rộng lớn. Chúng thường được sử dụng cho bộ dữ liệu rất lớn.</p><p>##### Nguồn và đọc thêm: kho lưu trữ cột rộng</p><ul><li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener noreferrer">SQL & NoSQL, lịch sử ngắn gọn</a></li>
<li><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">Kiến trúc Bigtable</a></li>
<li><a href="https://www.edureka.co/blog/hbase-architecture/" target="_blank" rel="noopener noreferrer">Kiến trúc HBase</a></li>
<li><a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html" target="_blank" rel="noopener noreferrer">Kiến trúc Cassandra</a></li></p><p></ul>#### Cơ sở dữ liệu đồ thị</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Nguồn: Cơ sở dữ liệu đồ thị</a></i>
</p></p><blockquote>Trừu tượng: đồ thị</blockquote></p><p>Trong cơ sở dữ liệu đồ thị, mỗi nút là một bản ghi và mỗi cung là một mối quan hệ giữa hai nút. Cơ sở dữ liệu đồ thị được tối ưu hóa để biểu diễn các mối quan hệ phức tạp với nhiều khóa ngoại hoặc các quan hệ nhiều-nhiều.</p><p>Cơ sở dữ liệu đồ thị cung cấp hiệu năng cao cho các mô hình dữ liệu có mối quan hệ phức tạp, ví dụ như mạng xã hội. Chúng còn khá mới và chưa được sử dụng rộng rãi; có thể sẽ khó tìm công cụ và tài nguyên phát triển. Nhiều cơ sở dữ liệu đồ thị chỉ có thể truy cập qua <a href="#representational-state-transfer-rest" target="_blank" rel="noopener noreferrer">REST APIs</a>.</p><p>##### Nguồn và tài liệu đọc thêm: đồ thị</p><ul><li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener noreferrer">Cơ sở dữ liệu đồ thị</a></li>
<li><a href="https://neo4j.com/" target="_blank" rel="noopener noreferrer">Neo4j</a></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener noreferrer">FlockDB</a></li></p><p></ul>#### Nguồn và tài liệu đọc thêm: NoSQL</p><ul><li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology" target="_blank" rel="noopener noreferrer">Giải thích các thuật ngữ cơ bản</a></li>
<li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq" target="_blank" rel="noopener noreferrer">Khảo sát và hướng dẫn quyết định về cơ sở dữ liệu NoSQL</a></li>
<li><a href="https://web.archive.org/web/20220602114024/https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener noreferrer">Khả năng mở rộng</a></li>
<li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I" target="_blank" rel="noopener noreferrer">Giới thiệu về NoSQL</a></li>
<li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener noreferrer">Mẫu NoSQL</a></li></p><p></ul><h3>SQL hay NoSQL</h3></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Nguồn: Chuyển đổi từ RDBMS sang NoSQL</a></i>
</p></p><p>Lý do chọn <strong>SQL</strong>:</p><ul><li>Dữ liệu có cấu trúc</li>
<li>Lược đồ nghiêm ngặt</li>
<li>Dữ liệu quan hệ</li>
<li>Cần kết hợp phức tạp (joins)</li>
<li>Giao dịch</li>
<li>Có các mô hình mở rộng rõ ràng</li>
<li>Được sử dụng lâu đời: nhiều lập trình viên, cộng đồng, mã nguồn, công cụ, v.v.</li>
<li>Tìm kiếm theo chỉ mục rất nhanh</li></p><p></ul>Lý do chọn <strong>NoSQL</strong>:</p><ul><li>Dữ liệu bán cấu trúc</li>
<li>Lược đồ động hoặc linh hoạt</li>
<li>Dữ liệu phi quan hệ</li>
<li>Không cần kết hợp phức tạp (joins)</li>
<li>Lưu trữ nhiều TB (hoặc PB) dữ liệu</li>
<li>Khối lượng công việc dữ liệu rất lớn</li>
<li>Thông lượng IOPS rất cao</li></p><p></ul>Dữ liệu mẫu phù hợp với NoSQL:</p><ul><li>Tiếp nhận nhanh dữ liệu clickstream và log</li>
<li>Dữ liệu bảng xếp hạng hoặc điểm số</li>
<li>Dữ liệu tạm thời, như giỏ hàng mua sắm</li>
<li>Các bảng truy cập thường xuyên ('nóng')</li>
<li>Bảng metadata/tra cứu</li></p><p></ul>##### Nguồn và đọc thêm: SQL hay NoSQL</p><ul><li><a href="https://www.youtube.com/watch?v=kKjm4ehYiMs" target="_blank" rel="noopener noreferrer">Mở rộng lên đến 10 triệu người dùng đầu tiên</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa SQL và NoSQL</a></li></p><p></ul><h2>Bộ nhớ đệm (Cache)</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Nguồn: Các mẫu thiết kế hệ thống có khả năng mở rộng</a></i>
</p></p><p>Bộ nhớ đệm giúp cải thiện thời gian tải trang và có thể giảm tải cho máy chủ và cơ sở dữ liệu của bạn. Trong mô hình này, bộ phân phối sẽ kiểm tra xem yêu cầu đã được thực hiện trước đó chưa và cố gắng tìm kết quả trước đó để trả về, nhằm tiết kiệm việc thực thi thực tế.</p><p>Cơ sở dữ liệu thường hưởng lợi từ việc phân phối đều các thao tác đọc và ghi trên các phân vùng của nó. Những mục phổ biến có thể làm lệch phân phối, gây ra điểm nghẽn. Đặt bộ nhớ đệm phía trước cơ sở dữ liệu có thể giúp hấp thụ tải không đều và các đợt tăng đột biến lưu lượng truy cập.</p><h3>Bộ nhớ đệm phía khách</h3></p><p>Bộ nhớ đệm có thể được đặt ở phía khách (hệ điều hành hoặc trình duyệt), <a href="#reverse-proxy-web-server" target="_blank" rel="noopener noreferrer">phía máy chủ</a>, hoặc trong một tầng bộ nhớ đệm riêng biệt.</p><h3>Bộ nhớ đệm CDN</h3></p><p><a href="#content-delivery-network" target="_blank" rel="noopener noreferrer">CDN</a> được xem là một loại bộ nhớ đệm.</p><h3>Bộ nhớ đệm máy chủ web</h3></p><p><a href="#reverse-proxy-web-server" target="_blank" rel="noopener noreferrer">Reverse proxy</a> và các bộ nhớ đệm như <a href="https://www.varnish-cache.org/" target="_blank" rel="noopener noreferrer">Varnish</a> có thể phục vụ nội dung tĩnh và động trực tiếp. Máy chủ web cũng có thể lưu bộ nhớ đệm các yêu cầu, trả về phản hồi mà không cần liên hệ với máy chủ ứng dụng.</p><h3>Bộ nhớ đệm cơ sở dữ liệu</h3></p><p>Cơ sở dữ liệu của bạn thường bao gồm một mức bộ nhớ đệm nào đó trong cấu hình mặc định, được tối ưu cho trường hợp sử dụng tổng quát. Tinh chỉnh các thiết lập này cho các mẫu sử dụng cụ thể có thể tăng hiệu suất hơn nữa.</p><h3>Bộ nhớ đệm ứng dụng</h3></p><p>Các bộ nhớ đệm trong RAM như Memcached và Redis là các kho lưu trữ key-value nằm giữa ứng dụng của bạn và bộ lưu trữ dữ liệu. Vì dữ liệu được giữ trong RAM, nó nhanh hơn nhiều so với các cơ sở dữ liệu thông thường nơi dữ liệu được lưu trên ổ đĩa. RAM bị giới hạn hơn so với ổ đĩa, vì vậy các thuật toán <a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener noreferrer">hủy bộ nhớ đệm</a> như <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU" target="_blank" rel="noopener noreferrer">ít được sử dụng gần đây nhất (LRU)</a>) có thể giúp loại bỏ các mục 'lạnh' và giữ dữ liệu 'nóng' trong RAM.</p><p>Redis có các tính năng bổ sung sau:</p><ul><li>Tùy chọn lưu trữ bền vững</li>
<li>Các cấu trúc dữ liệu tích hợp như tập hợp có thứ tự và danh sách</li></p><p></ul>Có nhiều cấp độ bạn có thể lưu bộ nhớ đệm, chia thành hai loại chính: <strong>truy vấn cơ sở dữ liệu</strong> và <strong>đối tượng</strong>:</p><ul><li>Cấp độ dòng</li>
<li>Cấp độ truy vấn</li>
<li>Đối tượng đã được tuần tự hóa hoàn chỉnh</li>
<li>HTML đã được render hoàn chỉnh</li></p><p></ul>Thông thường, bạn nên tránh sử dụng bộ nhớ đệm dựa trên tệp, vì nó làm cho việc nhân bản và tự động mở rộng trở nên khó khăn hơn.</p><h3>Bộ nhớ đệm ở cấp độ truy vấn cơ sở dữ liệu</h3></p><p>Bất cứ khi nào bạn truy vấn cơ sở dữ liệu, hãy băm truy vấn thành một khóa và lưu kết quả vào bộ nhớ đệm. Cách tiếp cận này gặp phải các vấn đề về hết hạn:</p><ul><li>Khó xóa một kết quả đã lưu trong bộ nhớ đệm với các truy vấn phức tạp</li>
<li>Nếu một phần dữ liệu thay đổi như một ô trong bảng, bạn cần xóa tất cả các truy vấn đã lưu trong bộ nhớ đệm có thể chứa ô đã thay đổi</li></p><p></ul><h3>Bộ nhớ đệm ở cấp độ đối tượng</h3></p><p>Xem dữ liệu của bạn như một đối tượng, giống như cách bạn làm với mã ứng dụng của mình.  Hãy để ứng dụng của bạn tập hợp bộ dữ liệu từ cơ sở dữ liệu thành một thể hiện lớp hoặc một cấu trúc dữ liệu:</p><ul><li>Xóa đối tượng khỏi bộ nhớ đệm nếu dữ liệu cơ bản của nó đã thay đổi</li>
<li>Cho phép xử lý bất đồng bộ: các worker tập hợp đối tượng bằng cách lấy đối tượng đã lưu trong bộ nhớ đệm mới nhất</li></p><p></ul>Các đề xuất về những gì nên lưu trong bộ nhớ đệm:</p><ul><li>Phiên người dùng</li>
<li>Các trang web đã được render đầy đủ</li>
<li>Luồng hoạt động</li>
<li>Dữ liệu đồ thị người dùng</li></p><p></ul><h3>Khi nào cập nhật bộ nhớ đệm</h3></p><p>Vì bạn chỉ có thể lưu một lượng dữ liệu giới hạn trong bộ nhớ đệm, bạn sẽ cần xác định chiến lược cập nhật bộ nhớ đệm nào phù hợp nhất với trường hợp sử dụng của mình.</p><p>#### Cache-aside</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Nguồn: From cache to in-memory data grid</a></i>
</p></p><p>Ứng dụng chịu trách nhiệm đọc và ghi từ bộ lưu trữ. Bộ nhớ đệm không tương tác trực tiếp với bộ lưu trữ.  Ứng dụng sẽ thực hiện các bước sau:</p><ul><li>Tìm kiếm mục trong bộ nhớ đệm, dẫn đến cache miss</li>
<li>Tải mục từ cơ sở dữ liệu</li>
<li>Thêm mục vào bộ nhớ đệm</li>
<li>Trả về mục</li></p><p></ul><pre><code class="language-python">def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user</code></pre></p><p><a href="https://memcached.org/" target="_blank" rel="noopener noreferrer">Memcached</a> thường được sử dụng theo cách này.</p><p>Các lần đọc dữ liệu tiếp theo được thêm vào bộ nhớ đệm sẽ rất nhanh. Cache-aside còn được gọi là lazy loading. Chỉ dữ liệu được yêu cầu mới được lưu vào cache, tránh làm đầy bộ nhớ đệm với dữ liệu không được yêu cầu.</p><p>##### Nhược điểm: cache-aside</p><ul><li>Mỗi lần cache miss sẽ tạo ra ba lượt truy cập, có thể gây ra độ trễ rõ rệt.</li>
<li>Dữ liệu có thể trở nên lỗi thời nếu được cập nhật trong cơ sở dữ liệu. Vấn đề này được giảm nhẹ bằng cách đặt thời gian sống (TTL) để buộc cập nhật lại mục trong cache, hoặc sử dụng write-through.</li>
<li>Khi một node bị lỗi, nó sẽ được thay thế bằng một node mới, rỗng, làm tăng độ trễ.</li></p><p></ul>#### Write-through</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Nguồn: Scalability, availability, stability, patterns</a></i>
</p></p><p>Ứng dụng sử dụng bộ nhớ đệm như kho lưu trữ dữ liệu chính, đọc và ghi dữ liệu vào đó, trong khi bộ nhớ đệm chịu trách nhiệm đọc và ghi vào cơ sở dữ liệu:</p><ul><li>Ứng dụng thêm/cập nhật mục trong bộ nhớ đệm</li>
<li>Bộ nhớ đệm ghi mục vào kho dữ liệu một cách đồng bộ</li>
<li>Trả về</li></p><p></ul>Mã ứng dụng:</p><pre><code class="language-python">set_user(12345, {"foo":"bar"})</code></pre></p><p>Mã bộ nhớ đệm: </p><pre><code class="language-python">def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)</code></pre>
Ghi trực tiếp là một thao tác tổng thể chậm do thao tác ghi, nhưng các lần đọc sau đó đối với dữ liệu vừa được ghi thì nhanh. Người dùng thường dễ chấp nhận độ trễ khi cập nhật dữ liệu hơn là khi đọc dữ liệu. Dữ liệu trong bộ nhớ đệm không bị lỗi thời.</p><p>##### Bất lợi: ghi trực tiếp</p><ul><li>Khi một node mới được tạo ra do sự cố hoặc mở rộng, node mới sẽ không lưu vào bộ nhớ đệm các mục cho đến khi mục đó được cập nhật trong cơ sở dữ liệu. Kết hợp cache-aside với ghi trực tiếp có thể giảm thiểu vấn đề này.</li>
<li>Hầu hết dữ liệu được ghi có thể không bao giờ được đọc, điều này có thể được giảm thiểu với TTL.</li></p><p></ul>#### Ghi phía sau (ghi lại)</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Nguồn: Scalability, availability, stability, patterns</a></i>
</p></p><p>Trong ghi phía sau, ứng dụng thực hiện các bước sau:</p><ul><li>Thêm/cập nhật mục trong bộ nhớ đệm</li>
<li>Ghi mục vào kho dữ liệu một cách bất đồng bộ, cải thiện hiệu năng ghi</li></p><p></ul>##### Bất lợi: ghi phía sau</p><ul><li>Có thể mất dữ liệu nếu bộ nhớ đệm bị sập trước khi nội dung của nó được ghi vào kho dữ liệu.</li>
<li>Việc triển khai ghi phía sau phức tạp hơn so với cache-aside hoặc ghi trực tiếp.</li></p><p></ul>#### Làm mới trước (refresh-ahead)</p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Nguồn: From cache to in-memory data grid</a></i>
</p></p><p>Bạn có thể cấu hình bộ nhớ đệm để tự động làm mới bất kỳ mục bộ nhớ đệm nào vừa được truy cập trước khi nó hết hạn.</p><p>Làm mới trước có thể giảm độ trễ so với đọc thông qua nếu bộ nhớ đệm dự đoán chính xác các mục sẽ cần trong tương lai.</p><p>##### Bất lợi: làm mới trước</p><ul><li>Việc không dự đoán chính xác các mục nào có khả năng cần thiết trong tương lai có thể dẫn đến hiệu suất giảm hơn so với khi không sử dụng refresh-ahead.</li></p><p></ul><h3>Nhược điểm: bộ nhớ đệm</h3></p><ul><li>Cần duy trì tính nhất quán giữa các bộ nhớ đệm và nguồn dữ liệu gốc như cơ sở dữ liệu thông qua <a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener noreferrer">làm mất hiệu lực bộ nhớ đệm</a>.</li>
<li>Làm mất hiệu lực bộ nhớ đệm là một vấn đề khó, có thêm sự phức tạp liên quan đến việc khi nào cần cập nhật bộ nhớ đệm.</li>
<li>Cần thay đổi ứng dụng như thêm Redis hoặc memcached.</li></p><p></ul><h3>Nguồn và tài liệu đọc thêm</h3></p><ul><li><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast" target="_blank" rel="noopener noreferrer">Từ cache đến in-memory data grid</a></li>
<li><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener noreferrer">Các mẫu thiết kế hệ thống có thể mở rộng</a></li>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener noreferrer">Giới thiệu về kiến trúc hệ thống để mở rộng</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">Scalability, availability, stability, patterns</a></li>
<li><a href="https://web.archive.org/web/20230126233752/https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener noreferrer">Scalability</a></li>
<li><a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html" target="_blank" rel="noopener noreferrer">Chiến lược AWS ElastiCache</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="noopener noreferrer">Wikipedia</a>)</li></p><p></ul><h2>Bất đồng bộ</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Nguồn: Giới thiệu về kiến trúc hệ thống để mở rộng</a></i>
</p></p><p>Luồng công việc bất đồng bộ giúp giảm thời gian yêu cầu cho các thao tác tốn kém mà bình thường sẽ được thực hiện ngay lập tức. Chúng cũng có thể giúp thực hiện các công việc tốn nhiều thời gian trước, như tổng hợp dữ liệu định kỳ.</p><h3>Hàng đợi tin nhắn</h3></p><p>Hàng đợi tin nhắn nhận, giữ và chuyển phát tin nhắn. Nếu một thao tác quá chậm để thực hiện ngay, bạn có thể sử dụng hàng đợi tin nhắn với quy trình sau:</p><ul><li>Ứng dụng gửi một công việc vào hàng đợi, sau đó thông báo cho người dùng về trạng thái công việc</li>
<li>Một worker nhận công việc từ hàng đợi, xử lý, rồi báo hiệu công việc đã hoàn thành</li></p><p></ul>Người dùng không bị chặn và công việc được xử lý ở chế độ nền. Trong thời gian này, client có thể tùy ý thực hiện một số xử lý nhỏ để khiến tác vụ có vẻ như đã hoàn thành. Ví dụ, khi đăng tweet, tweet có thể được đăng ngay lập tức lên timeline của bạn, nhưng có thể mất một thời gian trước khi tweet của bạn thực sự được gửi đến tất cả người theo dõi.</p><p><strong><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a></strong> hữu ích như một message broker đơn giản nhưng có thể bị mất tin nhắn.</p><p><strong><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener noreferrer">RabbitMQ</a></strong> phổ biến nhưng yêu cầu bạn phải thích nghi với giao thức 'AMQP' và tự quản lý các node.</p><p><strong><a href="https://aws.amazon.com/sqs/" target="_blank" rel="noopener noreferrer">Amazon SQS</a></strong> là dịch vụ được lưu trữ nhưng có thể có độ trễ cao và có khả năng tin nhắn được gửi hai lần.</p><h3>Hàng đợi tác vụ</h3></p><p>Hàng đợi tác vụ nhận các tác vụ và dữ liệu liên quan, thực hiện chúng, sau đó trả về kết quả. Chúng có thể hỗ trợ lập lịch và được sử dụng để chạy các công việc tính toán nặng ở chế độ nền.</p><p><strong><a href="https://docs.celeryproject.org/en/stable/" target="_blank" rel="noopener noreferrer">Celery</a></strong> hỗ trợ lập lịch và chủ yếu hỗ trợ python.</p><h3>Áp lực ngược (Back pressure)</h3></p><p>Nếu các hàng đợi bắt đầu tăng lên đáng kể, kích thước hàng đợi có thể lớn hơn bộ nhớ, dẫn đến lỗi bộ nhớ cache, đọc từ đĩa và hiệu suất chậm hơn. <a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener noreferrer">Áp lực ngược</a> có thể giúp bằng cách giới hạn kích thước hàng đợi, giữ tốc độ thông lượng cao và thời gian phản hồi tốt cho các công việc đã có trong hàng đợi. Khi hàng đợi đầy, khách hàng sẽ nhận được thông báo máy chủ bận hoặc mã trạng thái HTTP 503 để thử lại sau. Khách hàng có thể thử lại yêu cầu vào thời điểm sau, có thể với <a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener noreferrer">phương pháp lùi theo cấp số nhân</a>.</p><h3>Bất lợi: tính bất đồng bộ</h3></p><ul><li>Các trường hợp sử dụng như tính toán giá rẻ và quy trình thời gian thực có thể phù hợp hơn với hoạt động đồng bộ, vì việc đưa hàng đợi vào có thể gây ra độ trễ và phức tạp.</li></p><p></ul><h3>Nguồn và đọc thêm</h3></p><ul><li><a href="https://www.youtube.com/watch?v=1KRYH75wgy4" target="_blank" rel="noopener noreferrer">Tất cả là một trò chơi số</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener noreferrer">Áp dụng áp lực ngược khi quá tải</a></li>
<li><a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="noopener noreferrer">Định luật Little</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa hàng đợi tin nhắn và hàng đợi tác vụ là gì?</a></li></p><p></ul><h2>Giao tiếp</h2></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Nguồn: Mô hình 7 lớp OSI</a></i>
</p></p><h3>Giao thức truyền siêu văn bản (HTTP)</h3></p><p>HTTP là một phương thức để mã hóa và truyền dữ liệu giữa máy khách và máy chủ. Đây là giao thức yêu cầu/đáp ứng: máy khách gửi yêu cầu và máy chủ phản hồi với nội dung liên quan và thông tin trạng thái hoàn thành về yêu cầu. HTTP là tự chứa, cho phép yêu cầu và phản hồi đi qua nhiều bộ định tuyến và máy chủ trung gian thực hiện cân bằng tải, bộ nhớ đệm, mã hóa và nén.</p><p>Một yêu cầu HTTP cơ bản gồm một động từ (phương thức) và một tài nguyên (điểm cuối). Dưới đây là các động từ HTTP phổ biến:</p><p>| Động từ | Mô tả | Idempotent* | An toàn | Có thể lưu vào bộ đệm |
|---|---|---|---|---|
| GET | Đọc một tài nguyên | Có | Có | Có |
| POST | Tạo một tài nguyên hoặc kích hoạt một tiến trình xử lý dữ liệu | Không | Không | Có nếu phản hồi chứa thông tin độ tươi mới |
| PUT | Tạo hoặc thay thế một tài nguyên | Có | Không | Không |
| PATCH | Cập nhật một phần tài nguyên | Không | Không | Có nếu phản hồi chứa thông tin độ tươi mới |
| DELETE | Xóa một tài nguyên | Có | Không | Không |</p><p>*Có thể gọi nhiều lần mà không có kết quả khác biệt.</p><p>HTTP là một giao thức tầng ứng dụng dựa vào các giao thức tầng thấp hơn như <strong>TCP</strong> và <strong>UDP</strong>.</p><p>#### Nguồn và đọc thêm: HTTP</p><ul><li><a href="https://www.nginx.com/resources/glossary/http/" target="_blank" rel="noopener noreferrer">HTTP là gì?</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa HTTP và TCP</a></li>
<li><a href="https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa PUT và PATCH</a></li></p><p></ul><h3>Giao thức điều khiển truyền tải (TCP)</h3></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Nguồn: Cách làm game nhiều người chơi</a></i>
</p></p><p>TCP là một giao thức hướng kết nối hoạt động trên <a href="https://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener noreferrer">mạng IP</a>. Kết nối được thiết lập và kết thúc bằng cách sử dụng <a href="https://en.wikipedia.org/wiki/Handshaking" target="_blank" rel="noopener noreferrer">bắt tay</a>. Tất cả các gói gửi đi đều được đảm bảo đến đích theo đúng thứ tự ban đầu và không bị lỗi thông qua:</p><ul><li>Số thứ tự và <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation" target="_blank" rel="noopener noreferrer">trường kiểm tra tổng</a> cho từng gói</li>
<li>Gói <a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks" target="_blank" rel="noopener noreferrer">xác nhận</a>) và tự động truyền lại</li></p><p></ul>Nếu người gửi không nhận được phản hồi đúng, nó sẽ gửi lại các gói. Nếu có nhiều lần hết thời gian chờ, kết nối sẽ bị ngắt. TCP cũng thực hiện <a href="https://en.wikipedia.org/wiki/Flow_control_(data" target="_blank" rel="noopener noreferrer">kiểm soát luồng</a>) và <a href="https://en.wikipedia.org/wiki/Network_congestion#Congestion_control" target="_blank" rel="noopener noreferrer">kiểm soát tắc nghẽn</a>. Những đảm bảo này gây ra độ trễ và thường dẫn đến việc truyền dữ liệu kém hiệu quả hơn UDP.</p><p>Để đảm bảo thông lượng cao, các máy chủ web có thể giữ một số lượng lớn kết nối TCP mở, dẫn đến sử dụng bộ nhớ cao. Việc có nhiều kết nối mở giữa các luồng máy chủ web và ví dụ, một máy chủ <a href="https://memcached.org/" target="_blank" rel="noopener noreferrer">memcached</a> có thể tốn kém. <a href="https://en.wikipedia.org/wiki/Connection_pool" target="_blank" rel="noopener noreferrer">Pooling kết nối</a> có thể giúp ngoài việc chuyển sang UDP khi phù hợp.</p><p>TCP hữu ích cho các ứng dụng đòi hỏi độ tin cậy cao nhưng không quá nhạy về thời gian. Một số ví dụ bao gồm máy chủ web, dữ liệu cơ sở dữ liệu, SMTP, FTP và SSH.</p><p>Sử dụng TCP thay vì UDP khi:</p><ul><li>Bạn cần tất cả dữ liệu phải đến nguyên vẹn</li>
<li>Bạn muốn tự động ước lượng tối ưu băng thông mạng</li></p><p></ul><h3>Giao thức datagram người dùng (UDP)</h3></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Nguồn: Cách tạo một trò chơi nhiều người chơi</a></i>
</p></p><p>UDP là giao thức không kết nối. Datagram (tương tự như gói tin) chỉ được đảm bảo ở cấp độ datagram. Datagram có thể đến đích không theo thứ tự hoặc có thể không đến được. UDP không hỗ trợ kiểm soát tắc nghẽn. Không có các đảm bảo như TCP, UDP thường hiệu quả hơn.</p><p>UDP có thể phát sóng, gửi datagram đến tất cả các thiết bị trong mạng con. Điều này hữu ích với <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener noreferrer">DHCP</a> vì máy khách chưa nhận được địa chỉ IP, do đó ngăn chặn việc TCP truyền dữ liệu mà không có địa chỉ IP.</p><p>UDP kém tin cậy hơn nhưng hoạt động tốt trong các trường hợp sử dụng thời gian thực như VoIP, trò chuyện video, streaming và trò chơi nhiều người chơi thời gian thực.</p><p>Sử dụng UDP thay cho TCP khi:</p><ul><li>Bạn cần độ trễ thấp nhất</li>
<li>Dữ liệu đến muộn còn tệ hơn dữ liệu bị mất</li>
<li>Bạn muốn tự triển khai cơ chế sửa lỗi</li></p><p></ul>#### Nguồn và đọc thêm: TCP và UDP</p><ul><li><a href="http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/" target="_blank" rel="noopener noreferrer">Mạng cho lập trình game</a></li>
<li><a href="http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/" target="_blank" rel="noopener noreferrer">Sự khác biệt chính giữa các giao thức TCP và UDP</a></li>
<li><a href="http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp" target="_blank" rel="noopener noreferrer">Sự khác biệt giữa TCP và UDP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener noreferrer">Giao thức điều khiển truyền tải</a></li>
<li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer">Giao thức datagram người dùng</a></li>
<li><a href="http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf" target="_blank" rel="noopener noreferrer">Scaling memcache tại Facebook</a></li></p><p></ul><h3>Gọi thủ tục từ xa (RPC)</h3></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Nguồn: Crack the system design interview</a></i>
</p></p><p>Trong RPC, một máy khách gây ra việc thực thi một thủ tục ở không gian địa chỉ khác, thường là máy chủ từ xa. Thủ tục này được mã hóa như một lời gọi thủ tục cục bộ, trừu tượng hóa chi tiết về cách giao tiếp với máy chủ khỏi chương trình máy khách. Các lời gọi từ xa thường chậm hơn và kém tin cậy hơn các lời gọi cục bộ, vì vậy nên phân biệt các lời gọi RPC với lời gọi cục bộ. Các framework RPC phổ biến bao gồm <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener noreferrer">Protobuf</a>, <a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer">Thrift</a>, và <a href="https://avro.apache.org/docs/current/" target="_blank" rel="noopener noreferrer">Avro</a>.</p><p>RPC là giao thức yêu cầu-phản hồi:</p><ul><li><strong>Chương trình khách</strong> - Gọi thủ tục stub phía khách. Các tham số được đẩy lên stack giống như một lời gọi thủ tục cục bộ.</li>
<li><strong>Thủ tục stub phía khách</strong> - Đóng gói (marshals) id thủ tục và các tham số vào một thông điệp yêu cầu.</li>
<li><strong>Mô-đun truyền thông phía khách</strong> - Hệ điều hành gửi thông điệp từ khách đến máy chủ.</li>
<li><strong>Mô-đun truyền thông phía máy chủ</strong> - Hệ điều hành chuyển các gói tin đến thủ tục stub phía máy chủ.</li>
<li><strong>Thủ tục stub phía máy chủ</strong> - Giải nén kết quả, gọi thủ tục máy chủ tương ứng với id thủ tục và truyền các tham số đã cho.</li>
<li>Phản hồi từ máy chủ lặp lại các bước trên theo thứ tự ngược lại.</li></p><p></ul>Ví dụ các lời gọi RPC:</p><pre><code class="language-">GET /someoperation?data=anId</p><p>POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}</code></pre>
RPC tập trung vào việc phơi bày các hành vi. RPC thường được sử dụng vì lý do hiệu năng trong giao tiếp nội bộ, vì bạn có thể tự tay xây dựng các lệnh gọi gốc phù hợp hơn với trường hợp sử dụng của mình.</p><p>Chọn thư viện gốc (hay còn gọi là SDK) khi:</p><ul><li>Bạn biết nền tảng mục tiêu của mình.</li>
<li>Bạn muốn kiểm soát cách "logic" của mình được truy cập.</li>
<li>Bạn muốn kiểm soát cách kiểm soát lỗi xảy ra bên ngoài thư viện của mình.</li>
<li>Hiệu năng và trải nghiệm người dùng cuối là mối quan tâm chính của bạn.</li></p><p></ul>HTTP API tuân theo <strong>REST</strong> thường được sử dụng nhiều hơn cho các API công khai.</p><p>#### Nhược điểm: RPC</p><ul><li>Các client RPC trở nên phụ thuộc chặt chẽ vào cách triển khai dịch vụ.</li>
<li>Một API mới phải được định nghĩa cho mỗi thao tác hoặc trường hợp sử dụng mới.</li>
<li>Có thể khó gỡ lỗi RPC.</li>
<li>Bạn có thể không tận dụng được các công nghệ hiện có ngay lập tức. Ví dụ, có thể cần thêm nỗ lực để đảm bảo <a href="https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener noreferrer">các lệnh gọi RPC được lưu vào bộ nhớ đệm đúng cách</a> trên các máy chủ cache như <a href="http://www.squid-cache.org/" target="_blank" rel="noopener noreferrer">Squid</a>.</li></p><p></ul><h3>Representational state transfer (REST)</h3></p><p>REST là một kiểu kiến trúc áp đặt mô hình client/server, trong đó client thao tác trên tập hợp các tài nguyên do server quản lý. Server cung cấp đại diện của tài nguyên và các hành động có thể thao tác hoặc lấy đại diện mới của tài nguyên đó. Mọi giao tiếp đều phải không trạng thái và có thể lưu vào bộ nhớ đệm.</p><p>Có bốn đặc tính của một giao diện RESTful:</p><ul><li><strong>Định danh tài nguyên (URI trong HTTP)</strong> - sử dụng cùng một URI bất kể thao tác nào.</li>
<li><strong>Thay đổi theo đại diện (Động từ trong HTTP)</strong> - sử dụng động từ, header và body.</li>
<li><strong>Thông điệp lỗi tự mô tả (phản hồi trạng thái trong HTTP)</strong> - sử dụng mã trạng thái, không phát minh lại bánh xe.</li>
<li><strong><a href="http://restcookbook.com/Basics/hateoas/" target="_blank" rel="noopener noreferrer">HATEOAS</a> (giao diện HTML cho HTTP)</strong> - dịch vụ web của bạn nên được truy cập đầy đủ qua trình duyệt.</li></p><p></ul>Ví dụ các lệnh gọi REST:</p><pre><code class="language-">GET /someresources/anId</p><p>PUT /someresources/anId
{"anotherdata": "another value"}</code></pre>
REST tập trung vào việc cung cấp dữ liệu. Nó giảm thiểu sự kết nối chặt chẽ giữa client/server và thường được sử dụng cho các HTTP API công khai. REST sử dụng phương pháp cung cấp tài nguyên thông qua URI một cách tổng quát và đồng nhất, <a href="https://github.com/for-GET/know-your-http-well/blob/master/headers.md" target="_blank" rel="noopener noreferrer">biểu diễn qua các header</a>, và hành động qua các động từ như GET, POST, PUT, DELETE và PATCH. Là stateless, REST rất phù hợp cho mở rộng ngang và phân vùng.</p><p>#### Nhược điểm: REST</p><ul><li>Vì REST tập trung vào việc cung cấp dữ liệu, nó có thể không phù hợp nếu tài nguyên không được tổ chức hoặc truy cập một cách tự nhiên trong một hệ thống phân cấp đơn giản. Ví dụ, trả về tất cả các bản ghi cập nhật trong giờ qua phù hợp với một tập hợp sự kiện cụ thể không dễ dàng thể hiện dưới dạng một đường dẫn. Với REST, có khả năng phải thực hiện với sự kết hợp của đường dẫn URI, tham số truy vấn và có thể là phần thân yêu cầu.</li>
<li>REST thường dựa vào một vài động từ (GET, POST, PUT, DELETE và PATCH) mà đôi khi không phù hợp với trường hợp sử dụng của bạn. Ví dụ, di chuyển tài liệu hết hạn vào thư mục lưu trữ có thể không phù hợp một cách rõ ràng với các động từ này.</li>
<li>Việc lấy các tài nguyên phức tạp với cấu trúc phân cấp lồng nhau cần nhiều lần trao đổi giữa client và server để hiển thị một view duy nhất, ví dụ như lấy nội dung của một bài blog và các bình luận trên bài đó. Đối với các ứng dụng di động hoạt động trong điều kiện mạng thay đổi, nhiều lần trao đổi này là điều rất không mong muốn.</li>
<li>Theo thời gian, có thể có thêm nhiều trường dữ liệu được bổ sung vào phản hồi API và các client cũ sẽ nhận tất cả các trường dữ liệu mới, kể cả những trường mà chúng không cần, dẫn đến payload bị phình to và độ trễ lớn hơn.</li></p><p></ul><h3>So sánh các gọi RPC và REST</h3></p><p>| Hoạt động | RPC | REST |
|---|---|---|
| Đăng ký    | <strong>POST</strong> /signup | <strong>POST</strong> /persons |
| Nghỉ việc    | <strong>POST</strong> /resign<br/>{<br/>"personid": "1234"<br/>} | <strong>DELETE</strong> /persons/1234 |
| Đọc thông tin một người | <strong>GET</strong> /readPerson?personid=1234 | <strong>GET</strong> /persons/1234 |
| Đọc danh sách vật phẩm của một người | <strong>GET</strong> /readUsersItemsList?personid=1234 | <strong>GET</strong> /persons/1234/items |
| Thêm vật phẩm vào danh sách của một người | <strong>POST</strong> /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | <strong>POST</strong> /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Cập nhật vật phẩm    | <strong>POST</strong> /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | <strong>PUT</strong> /items/456<br/>{<br/>"key": "value"<br/>} |
| Xóa vật phẩm | <strong>POST</strong> /removeItem<br/>{<br/>"itemid": "456"<br/>} | <strong>DELETE</strong> /items/456 |</p><p><p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Nguồn: Bạn có thật sự biết vì sao bạn thích REST hơn RPC không</a></i>
</p></p><p>#### Nguồn và tài liệu đọc thêm: REST và RPC</p><ul><li><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/" target="_blank" rel="noopener noreferrer">Bạn có thật sự biết vì sao bạn thích REST hơn RPC không</a></li>
<li><a href="http://programmers.stackexchange.com/a/181186" target="_blank" rel="noopener noreferrer">Khi nào cách tiếp cận kiểu RPC phù hợp hơn REST?</a></li>
<li><a href="http://stackoverflow.com/questions/15056878/rest-vs-json-rpc" target="_blank" rel="noopener noreferrer">REST vs JSON-RPC</a></li>
<li><a href="https://web.archive.org/web/20170608193645/http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener noreferrer">Phá bỏ các huyền thoại về RPC và REST</a></li>
<li><a href="https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs" target="_blank" rel="noopener noreferrer">Những bất lợi khi sử dụng REST</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">Crack the system design interview</a></li>
<li><a href="https://code.facebook.com/posts/1468950976659943/" target="_blank" rel="noopener noreferrer">Thrift</a></li>
<li><a href="http://arstechnica.com/civis/viewtopic.php?t=1190508" target="_blank" rel="noopener noreferrer">Tại sao REST dùng cho nội bộ mà không phải RPC</a></li></p><p></ul><h2>Bảo mật</h2></p><p>Phần này có thể cần cập nhật. Hãy cân nhắc <a href="#contributing" target="_blank" rel="noopener noreferrer">đóng góp</a>!</p><p>Bảo mật là một chủ đề rộng. Trừ khi bạn có kinh nghiệm đáng kể, có nền tảng về bảo mật, hoặc đang ứng tuyển vào vị trí yêu cầu kiến thức về bảo mật, bạn có lẽ chỉ cần biết những điều cơ bản sau:</p><ul><li>Mã hóa dữ liệu khi truyền và khi lưu trữ.</li>
<li>Làm sạch tất cả dữ liệu đầu vào từ người dùng hoặc bất kỳ tham số nào được người dùng truy cập để ngăn chặn <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">XSS</a> và <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener noreferrer">SQL injection</a>.</li>
<li>Sử dụng truy vấn tham số hóa để ngăn SQL injection.</li>
<li>Áp dụng nguyên tắc <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener noreferrer">quyền hạn tối thiểu</a>.</li></p><p></ul><h3>Nguồn và tài liệu đọc thêm</h3></p><ul><li><a href="https://github.com/shieldfy/API-Security-Checklist" target="_blank" rel="noopener noreferrer">Danh sách kiểm tra bảo mật API</a></li>
<li><a href="https://github.com/FallibleInc/security-guide-for-developers" target="_blank" rel="noopener noreferrer">Hướng dẫn bảo mật cho lập trình viên</a></li>
<li><a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet" target="_blank" rel="noopener noreferrer">OWASP top ten</a></li></p><p></ul><h2>Phụ lục</h2></p><p>Đôi khi bạn sẽ được yêu cầu ước lượng nhanh. Ví dụ, bạn có thể cần xác định mất bao lâu để tạo 100 ảnh thumbnail từ đĩa hoặc một cấu trúc dữ liệu sẽ tiêu tốn bao nhiêu bộ nhớ. <strong>Bảng số mũ của hai</strong> và <strong>Các con số độ trễ mà lập trình viên nên biết</strong> là những tài liệu tham khảo hữu ích.</p><h3>Bảng số mũ của hai</h3></p><pre><code class="language-">Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB</code></pre></p><p>#### Nguồn và tài liệu đọc thêm</p><ul><li><a href="https://vi.wikipedia.org/wiki/L%C5%A9y_th%E1%BB%ABa_c%E1%BB%A7a_hai" target="_blank" rel="noopener noreferrer">Lũy thừa của hai</a></li></p><p></ul><h3>Những con số độ trễ mà mọi lập trình viên nên biết</h3></p><pre><code class="language-">Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
HDD seek                            10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from HDD     30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms</p><p>Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</code></pre>
Các chỉ số hữu ích dựa trên các con số ở trên:</p><ul><li>Đọc tuần tự từ HDD ở tốc độ 30 MB/s</li>
<li>Đọc tuần tự từ Ethernet 1 Gbps ở tốc độ 100 MB/s</li>
<li>Đọc tuần tự từ SSD ở tốc độ 1 GB/s</li>
<li>Đọc tuần tự từ bộ nhớ chính ở tốc độ 4 GB/s</li>
<li>6-7 lượt đi/về toàn cầu mỗi giây</li>
<li>2.000 lượt đi/về mỗi giây trong một trung tâm dữ liệu</li></p><p></ul>#### Hình minh họa các con số độ trễ</p><p><img src="https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67" alt=""></p><p>#### Nguồn và tài liệu đọc thêm</p><ul><li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener noreferrer">Những con số độ trễ mà lập trình viên nên biết - 1</a></li>
<li><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener noreferrer">Những con số độ trễ mà lập trình viên nên biết - 2</a></li>
<li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener noreferrer">Thiết kế, bài học và lời khuyên khi xây dựng hệ thống phân tán lớn</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="noopener noreferrer">Lời khuyên Kỹ thuật phần mềm từ việc xây dựng hệ thống phân tán quy mô lớn</a></li></p><p></ul><h3>Các câu hỏi phỏng vấn thiết kế hệ thống bổ sung</h3></p><blockquote>Các câu hỏi phỏng vấn thiết kế hệ thống phổ biến, kèm liên kết đến tài liệu hướng dẫn cách giải.</blockquote></p><p>| Câu hỏi | Tài liệu tham khảo |
|---|---|
| Thiết kế dịch vụ đồng bộ tập tin như Dropbox | <a href="https://www.youtube.com/watch?v=PE4gwstWhmc" target="_blank" rel="noopener noreferrer">youtube.com</a> |
| Thiết kế công cụ tìm kiếm như Google | <a href="http://queue.acm.org/detail.cfm?id=988407" target="_blank" rel="noopener noreferrer">queue.acm.org</a><br/><a href="http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search" target="_blank" rel="noopener noreferrer">stackexchange.com</a><br/><a href="http://www.ardendertat.com/2012/01/11/implementing-search-engines/" target="_blank" rel="noopener noreferrer">ardendertat.com</a><br/><a href="http://infolab.stanford.edu/~backrub/google.html" target="_blank" rel="noopener noreferrer">stanford.edu</a> |
| Thiết kế trình thu thập dữ liệu web có khả năng mở rộng như Google | <a href="https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch" target="_blank" rel="noopener noreferrer">quora.com</a> |
| Thiết kế Google Docs | <a href="https://code.google.com/p/google-mobwrite/" target="_blank" rel="noopener noreferrer">code.google.com</a><br/><a href="https://neil.fraser.name/writing/sync/" target="_blank" rel="noopener noreferrer">neil.fraser.name</a> |
| Thiết kế kho key-value như Redis | <a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Thiết kế hệ thống cache như Memcached | <a href="http://www.slideshare.net/oemebamo/introduction-to-memcached" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Thiết kế hệ thống đề xuất như Amazon | <a href="https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html" target="_blank" rel="noopener noreferrer">hulu.com</a><br/><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="noopener noreferrer">ijcai13.org</a> |
| Thiết kế hệ thống tinyurl như Bitly | <a href="http://n00tc0d3r.blogspot.com/" target="_blank" rel="noopener noreferrer">n00tc0d3r.blogspot.com</a> |
| Thiết kế ứng dụng chat như WhatsApp | <a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html" target="_blank" rel="noopener noreferrer">highscalability.com</a>
| Thiết kế hệ thống chia sẻ ảnh như Instagram | <a href="http://highscalability.com/flickr-architecture" target="_blank" rel="noopener noreferrer">highscalability.com</a><br/><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener noreferrer">highscalability.com</a> |
| Thiết kế chức năng news feed của Facebook | <a href="http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed" target="_blank" rel="noopener noreferrer">quora.com</a><br/><a href="http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed" target="_blank" rel="noopener noreferrer">quora.com</a><br/><a href="http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Thiết kế chức năng timeline của Facebook | <a href="https://www.facebook.com/note.php?note_id=10150468255628920" target="_blank" rel="noopener noreferrer">facebook.com</a><br/><a href="http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html" target="_blank" rel="noopener noreferrer">highscalability.com</a> |
| Thiết kế chức năng chat của Facebook | <a href="http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf" target="_blank" rel="noopener noreferrer">erlang-factory.com</a><br/><a href="https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0" target="_blank" rel="noopener noreferrer">facebook.com</a> |</p><p>| Thiết kế một chức năng tìm kiếm đồ thị giống Facebook | <a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920" target="_blank" rel="noopener noreferrer">facebook.com</a><br/><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920" target="_blank" rel="noopener noreferrer">facebook.com</a><br/><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920" target="_blank" rel="noopener noreferrer">facebook.com</a> |
| Thiết kế một mạng phân phối nội dung giống CloudFlare | <a href="https://figshare.com/articles/Globally_distributed_content_delivery/6605972" target="_blank" rel="noopener noreferrer">figshare.com</a> |
| Thiết kế hệ thống chủ đề thịnh hành giống Twitter | <a href="http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/" target="_blank" rel="noopener noreferrer">michael-noll.com</a><br/><a href="http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/" target="_blank" rel="noopener noreferrer">snikolov .wordpress.com</a> |
| Thiết kế hệ thống sinh ID ngẫu nhiên | <a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="noopener noreferrer">blog.twitter.com</a><br/><a href="https://github.com/twitter/snowflake/" target="_blank" rel="noopener noreferrer">github.com</a> |
| Trả về k yêu cầu hàng đầu trong một khoảng thời gian | <a href="https://www.cs.ucsb.edu/sites/default/files/documents/2005-23.pdf" target="_blank" rel="noopener noreferrer">cs.ucsb.edu</a><br/><a href="http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf" target="_blank" rel="noopener noreferrer">wpi.edu</a> |
| Thiết kế hệ thống phục vụ dữ liệu từ nhiều trung tâm dữ liệu | <a href="http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html" target="_blank" rel="noopener noreferrer">highscalability.com</a> |
| Thiết kế trò chơi bài đa người chơi trực tuyến | <a href="https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="noopener noreferrer">indieflashblog.com</a><br/><a href="http://buildnewgames.com/real-time-multiplayer/" target="_blank" rel="noopener noreferrer">buildnewgames.com</a> |
| Thiết kế hệ thống thu gom rác | <a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/" target="_blank" rel="noopener noreferrer">stuffwithstuff.com</a><br/><a href="http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf" target="_blank" rel="noopener noreferrer">washington.edu</a> |
| Thiết kế bộ giới hạn tần suất gọi API | <a href="https://stripe.com/blog/rate-limiters" target="_blank" rel="noopener noreferrer">https://stripe.com/blog/</a> |
| Thiết kế một Sàn giao dịch chứng khoán (như NASDAQ hoặc Binance) | <a href="https://youtu.be/b1e4t2k2KJY" target="_blank" rel="noopener noreferrer">Jane Street</a><br/><a href="https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/" target="_blank" rel="noopener noreferrer">Golang Implementation</a><br/><a href="http://bhomnick.net/building-a-simple-limit-order-in-go/" target="_blank" rel="noopener noreferrer">Go Implementation</a> |
| Thêm một câu hỏi thiết kế hệ thống | <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a> |</p><h3>Kiến trúc thực tế</h3></p><blockquote>Các bài viết về cách hệ thống thực tế được thiết kế.</blockquote></p><p><p align="center">
  <img src="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/images/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Nguồn: Twitter timelines at scale</a></i>
</p></p><p><strong>Đừng tập trung vào chi tiết vụn vặt trong các bài viết sau, thay vào đó:</strong></p><ul><li>Xác định các nguyên lý chung, công nghệ phổ biến và mẫu thiết kế trong các bài viết này</li>
<li>Tìm hiểu các vấn đề được giải quyết bởi từng thành phần, điểm mạnh, điểm yếu</li>
<li>Xem lại các bài học kinh nghiệm</li></p><p></ul>|Loại | Hệ thống | Tài liệu tham khảo |
|---|---|---|
| Xử lý dữ liệu | <strong>MapReduce</strong> - Xử lý dữ liệu phân tán từ Google | <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a> |
| Xử lý dữ liệu | <strong>Spark</strong> - Xử lý dữ liệu phân tán từ Databricks | <a href="http://www.slideshare.net/AGrishchenko/apache-spark-architecture" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Xử lý dữ liệu | <strong>Storm</strong> - Xử lý dữ liệu phân tán từ Twitter | <a href="http://www.slideshare.net/previa/storm-16094009" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| | | |
| Kho dữ liệu | <strong>Bigtable</strong> - Cơ sở dữ liệu cột phân tán từ Google | <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">harvard.edu</a> |
| Kho dữ liệu | <strong>HBase</strong> - Triển khai mã nguồn mở của Bigtable | <a href="http://www.slideshare.net/alexbaranau/intro-to-hbase" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Kho dữ liệu | <strong>Cassandra</strong> - Cơ sở dữ liệu cột phân tán từ Facebook | <a href="http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666" target="_blank" rel="noopener noreferrer">slideshare.net</a>
| Kho dữ liệu | <strong>DynamoDB</strong> - Cơ sở dữ liệu hướng tài liệu từ Amazon | <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="noopener noreferrer">harvard.edu</a> |
| Kho dữ liệu | <strong>MongoDB</strong> - Cơ sở dữ liệu hướng tài liệu | <a href="http://www.slideshare.net/mdirolf/introduction-to-mongodb" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Kho dữ liệu | <strong>Spanner</strong> - Cơ sở dữ liệu phân tán toàn cầu từ Google | <a href="http://research.google.com/archive/spanner-osdi2012.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a> |
| Kho dữ liệu | <strong>Memcached</strong> - Hệ thống bộ nhớ đệm phân tán | <a href="http://www.slideshare.net/oemebamo/introduction-to-memcached" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Kho dữ liệu | <strong>Redis</strong> - Hệ thống bộ nhớ đệm phân tán có khả năng lưu trữ lâu dài và kiểu giá trị | <a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| | | |
| Hệ thống tập tin | <strong>Google File System (GFS)</strong> - Hệ thống tập tin phân tán | <a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a> |
| Hệ thống tập tin | <strong>Hadoop File System (HDFS)</strong> - Phiên bản mã nguồn mở của GFS | <a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener noreferrer">apache.org</a> |
| | | |
| Khác | <strong>Chubby</strong> - Dịch vụ khóa cho các hệ thống phân tán liên kết lỏng của Google | <a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a> |
| Khác | <strong>Dapper</strong> - Hạ tầng truy vết hệ thống phân tán | <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a>
| Khác | <strong>Kafka</strong> - Hàng đợi thông điệp pub/sub từ LinkedIn | <a href="http://www.slideshare.net/mumrah/kafka-talk-tri-hug" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| Khác | <strong>Zookeeper</strong> - Hạ tầng và dịch vụ tập trung hỗ trợ đồng bộ hóa | <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">slideshare.net</a> |
| | Thêm kiến trúc | <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a> |</p><h3>Kiến trúc của các công ty</h3></p><p>| Công ty | Tham khảo |
|---|---|
| Amazon | <a href="http://highscalability.com/amazon-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc Amazon</a> |
| Cinchcast | <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="noopener noreferrer">Sản xuất 1.500 giờ âm thanh mỗi ngày</a> |
| DataSift | <a href="http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html" target="_blank" rel="noopener noreferrer">Khai thác dữ liệu thời gian thực với 120.000 tweet mỗi giây</a> |
| Dropbox | <a href="https://www.youtube.com/watch?v=PE4gwstWhmc" target="_blank" rel="noopener noreferrer">Cách Dropbox mở rộng quy mô</a> |
| ESPN | <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="noopener noreferrer">Vận hành với 100.000 duh nuh nuhs mỗi giây</a> |
| Google | <a href="http://highscalability.com/google-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc Google</a> |
| Instagram | <a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener noreferrer">14 triệu người dùng, hàng terabyte ảnh</a><br/><a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="noopener noreferrer">Công nghệ phía sau Instagram</a> |
| Justin.tv | <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="noopener noreferrer">Kiến trúc phát video trực tuyến của Justin.tv</a> |
| Facebook | <a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf" target="_blank" rel="noopener noreferrer">Mở rộng memcached tại Facebook</a><br/><a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf" target="_blank" rel="noopener noreferrer">TAO: Kho dữ liệu phân tán cho social graph của Facebook</a><br/><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener noreferrer">Lưu trữ ảnh của Facebook</a><br/><a href="http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html" target="_blank" rel="noopener noreferrer">Cách Facebook Live phát trực tiếp đến 800.000 người xem đồng thời</a> |
| Flickr | <a href="http://highscalability.com/flickr-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc Flickr</a> |
| Mailbox | <a href="http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html" target="_blank" rel="noopener noreferrer">Từ 0 đến một triệu người dùng trong 6 tuần</a> |
| Netflix | <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html" target="_blank" rel="noopener noreferrer">Toàn cảnh hệ thống Netflix</a><br/><a href="http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html" target="_blank" rel="noopener noreferrer">Netflix: Chuyện gì xảy ra khi bạn nhấn Play?</a> |
| Pinterest | <a href="http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html" target="_blank" rel="noopener noreferrer">Từ 0 đến hàng chục tỷ lượt xem trang mỗi tháng</a><br/><a href="http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html" target="_blank" rel="noopener noreferrer">18 triệu khách truy cập, tăng trưởng 10 lần, 12 nhân viên</a> |
| Playfish | <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="noopener noreferrer">50 triệu người dùng hàng tháng và tiếp tục tăng trưởng</a> |
| PlentyOfFish | <a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc PlentyOfFish</a> |
| Salesforce | <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="noopener noreferrer">Cách họ xử lý 1,3 tỷ giao dịch mỗi ngày</a> |
| Stack Overflow | <a href="http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html" target="_blank" rel="noopener noreferrer">Kiến trúc Stack Overflow</a> |
| TripAdvisor | <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="noopener noreferrer">40 triệu khách truy cập, 200 triệu lượt xem trang động, 30TB dữ liệu</a> |
| Tumblr | <a href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html" target="_blank" rel="noopener noreferrer">15 tỷ lượt xem trang mỗi tháng</a> |
| Twitter | <a href="http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster" target="_blank" rel="noopener noreferrer">Làm Twitter nhanh hơn 10.000 lần</a><br/><a href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html" target="_blank" rel="noopener noreferrer">Lưu trữ 250 triệu tweet mỗi ngày bằng MySQL</a><br/><a href="http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html" target="_blank" rel="noopener noreferrer">150 triệu người dùng hoạt động, 300K QPS, 22 MB/S dữ liệu lớn</a><br/><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener noreferrer">Timeline ở quy mô lớn</a><br/><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="noopener noreferrer">Dữ liệu lớn và nhỏ tại Twitter</a><br/><a href="https://www.youtube.com/watch?v=z8LU0Cj6BOU" target="_blank" rel="noopener noreferrer">Vận hành tại Twitter: mở rộng vượt quá 100 triệu người dùng</a><br/><a href="http://highscalability.com/blog/2016/4/20/how-twitter-handles-3000-images-per-second.html" target="_blank" rel="noopener noreferrer">Cách Twitter xử lý 3.000 ảnh mỗi giây</a> |
| Uber | <a href="http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html" target="_blank" rel="noopener noreferrer">Cách Uber mở rộng nền tảng thị trường thời gian thực</a><br/><a href="http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html" target="_blank" rel="noopener noreferrer">Bài học từ việc mở rộng Uber lên 2000 kỹ sư, 1000 dịch vụ, và 8000 kho Git</a> |
| WhatsApp | <a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html" target="_blank" rel="noopener noreferrer">Kiến trúc WhatsApp mà Facebook mua với giá 19 tỷ USD</a> |
| YouTube | <a href="https://www.youtube.com/watch?v=w5WVu624fY8" target="_blank" rel="noopener noreferrer">Khả năng mở rộng của YouTube</a><br/><a href="http://highscalability.com/youtube-architecture" target="_blank" rel="noopener noreferrer">Kiến trúc YouTube</a> |</p><h3>Blog kỹ thuật của các công ty</h3></p><blockquote>Kiến trúc của các công ty mà bạn đang phỏng vấn.</blockquote>
>
<blockquote>Những câu hỏi bạn gặp phải có thể đến từ cùng một lĩnh vực.</blockquote></p><ul><li><a href="http://nerds.airbnb.com/" target="_blank" rel="noopener noreferrer">Airbnb Engineering</a></li>
<li><a href="https://developer.atlassian.com/blog/" target="_blank" rel="noopener noreferrer">Atlassian Developers</a></li>
<li><a href="https://aws.amazon.com/blogs/aws/" target="_blank" rel="noopener noreferrer">AWS Blog</a></li>
<li><a href="http://word.bitly.com/" target="_blank" rel="noopener noreferrer">Bitly Engineering Blog</a></li>
<li><a href="https://blog.box.com/blog/category/engineering" target="_blank" rel="noopener noreferrer">Box Blogs</a></li>
<li><a href="http://blog.cloudera.com/" target="_blank" rel="noopener noreferrer">Cloudera Developer Blog</a></li>
<li><a href="https://tech.dropbox.com/" target="_blank" rel="noopener noreferrer">Dropbox Tech Blog</a></li>
<li><a href="https://www.quora.com/q/quoraengineering" target="_blank" rel="noopener noreferrer">Engineering at Quora</a></li>
<li><a href="http://www.ebaytechblog.com/" target="_blank" rel="noopener noreferrer">Ebay Tech Blog</a></li>
<li><a href="https://blog.evernote.com/tech/" target="_blank" rel="noopener noreferrer">Evernote Tech Blog</a></li>
<li><a href="http://codeascraft.com/" target="_blank" rel="noopener noreferrer">Etsy Code as Craft</a></li>
<li><a href="https://www.facebook.com/Engineering" target="_blank" rel="noopener noreferrer">Facebook Engineering</a></li>
<li><a href="http://code.flickr.net/" target="_blank" rel="noopener noreferrer">Flickr Code</a></li>
<li><a href="http://engineering.foursquare.com/" target="_blank" rel="noopener noreferrer">Foursquare Engineering Blog</a></li>
<li><a href="https://github.blog/category/engineering" target="_blank" rel="noopener noreferrer">GitHub Engineering Blog</a></li>
<li><a href="http://googleresearch.blogspot.com/" target="_blank" rel="noopener noreferrer">Google Research Blog</a></li>
<li><a href="https://engineering.groupon.com/" target="_blank" rel="noopener noreferrer">Groupon Engineering Blog</a></li>
<li><a href="https://engineering.heroku.com/" target="_blank" rel="noopener noreferrer">Heroku Engineering Blog</a></li>
<li><a href="http://product.hubspot.com/blog/topic/engineering" target="_blank" rel="noopener noreferrer">Hubspot Engineering Blog</a></li>
<li><a href="http://highscalability.com/" target="_blank" rel="noopener noreferrer">High Scalability</a></li>
<li><a href="http://instagram-engineering.tumblr.com/" target="_blank" rel="noopener noreferrer">Instagram Engineering</a></li>
<li><a href="https://software.intel.com/en-us/blogs/" target="_blank" rel="noopener noreferrer">Intel Software Blog</a></li>
<li><a href="https://blogs.janestreet.com/category/ocaml/" target="_blank" rel="noopener noreferrer">Jane Street Tech Blog</a></li>
<li><a href="http://engineering.linkedin.com/blog" target="_blank" rel="noopener noreferrer">LinkedIn Engineering</a></li>
<li><a href="https://engineering.microsoft.com/" target="_blank" rel="noopener noreferrer">Microsoft Engineering</a></li>
<li><a href="https://blogs.msdn.microsoft.com/pythonengineering/" target="_blank" rel="noopener noreferrer">Microsoft Python Engineering</a></li>
<li><a href="http://techblog.netflix.com/" target="_blank" rel="noopener noreferrer">Netflix Tech Blog</a></li>
<li><a href="https://medium.com/paypal-engineering" target="_blank" rel="noopener noreferrer">Paypal Developer Blog</a></li>
<li><a href="https://medium.com/@Pinterest_Engineering" target="_blank" rel="noopener noreferrer">Pinterest Engineering Blog</a></li>
<li><a href="http://www.redditblog.com/" target="_blank" rel="noopener noreferrer">Reddit Blog</a></li>
<li><a href="https://developer.salesforce.com/blogs/engineering/" target="_blank" rel="noopener noreferrer">Salesforce Engineering Blog</a></li>
<li><a href="https://slack.engineering/" target="_blank" rel="noopener noreferrer">Slack Engineering Blog</a></li>
<li><a href="https://labs.spotify.com/" target="_blank" rel="noopener noreferrer">Spotify Labs</a></li>
<li><a href="https://stripe.com/blog/engineering" target="_blank" rel="noopener noreferrer">Stripe Engineering Blog</a></li>
<li><a href="http://www.twilio.com/engineering" target="_blank" rel="noopener noreferrer">Twilio Engineering Blog</a></li>
<li><a href="https://blog.twitter.com/engineering/" target="_blank" rel="noopener noreferrer">Twitter Engineering</a></li>
<li><a href="http://eng.uber.com/" target="_blank" rel="noopener noreferrer">Uber Engineering Blog</a></li>
<li><a href="http://yahooeng.tumblr.com/" target="_blank" rel="noopener noreferrer">Yahoo Engineering Blog</a></li>
<li><a href="http://engineeringblog.yelp.com/" target="_blank" rel="noopener noreferrer">Yelp Engineering Blog</a></li>
<li><a href="https://www.zynga.com/blogs/engineering" target="_blank" rel="noopener noreferrer">Zynga Engineering Blog</a></li></p><p></ul>#### Nguồn và đọc thêm</p><p>Muốn thêm blog? Để tránh trùng lặp công việc, hãy cân nhắc thêm blog công ty của bạn vào kho lưu trữ sau:</p><ul><li><a href="https://github.com/kilimchoi/engineering-blogs" target="_blank" rel="noopener noreferrer">kilimchoi/engineering-blogs</a></li></p><p></ul><h2>Đang phát triển</h2></p><p>Quan tâm đến việc thêm một mục hoặc giúp hoàn thành một mục đang tiến hành? <a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a>!</p><ul><li>Điện toán phân tán với MapReduce</li>
<li>Băm nhất quán</li>
<li>Scatter gather</li>
<li><a href="#contributing" target="_blank" rel="noopener noreferrer">Đóng góp</a></li></p><p></ul><h2>Ghi công</h2></p><p>Ghi công và nguồn được cung cấp xuyên suốt kho lưu trữ này.</p><p>Đặc biệt cảm ơn:</p><ul><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="noopener noreferrer">Hired in tech</a></li>
<li><a href="https://www.amazon.com/dp/0984782850/" target="_blank" rel="noopener noreferrer">Cracking the coding interview</a></li>
<li><a href="http://highscalability.com/" target="_blank" rel="noopener noreferrer">High scalability</a></li>
<li><a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="noopener noreferrer">checkcheckzz/system-design-interview</a></li>
<li><a href="https://github.com/shashank88/system_design" target="_blank" rel="noopener noreferrer">shashank88/system_design</a></li>
<li><a href="https://github.com/mmcgrana/services-engineering" target="_blank" rel="noopener noreferrer">mmcgrana/services-engineering</a></li>
<li><a href="https://gist.github.com/vasanthk/485d1c25737e8e72759f" target="_blank" rel="noopener noreferrer">System design cheat sheet</a></li>
<li><a href="http://dancres.github.io/Pages/" target="_blank" rel="noopener noreferrer">A distributed systems reading list</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">Cracking the system design interview</a></li></p><p></ul><h2>Thông tin liên hệ</h2></p><p>Hãy liên hệ với tôi để thảo luận về bất kỳ vấn đề, câu hỏi hoặc ý kiến nào.</p><p>Thông tin liên hệ của tôi có thể được tìm thấy trên <a href="https://github.com/donnemartin" target="_blank" rel="noopener noreferrer">trang GitHub của tôi</a>.</p><h2>Giấy phép</h2></p><p><em>Tôi cung cấp mã nguồn và tài nguyên trong kho lưu trữ này cho bạn theo giấy phép nguồn mở. Vì đây là kho lưu trữ cá nhân của tôi, giấy phép bạn nhận được đối với mã nguồn và tài nguyên là từ tôi chứ không phải từ công ty tôi (Facebook).</em></p><p>    Bản quyền 2017 Donne Martin</p><p>    Giấy phép Creative Commons Attribution 4.0 International License (CC BY 4.0)</p><p>    http://creativecommons.org/licenses/by/4.0/</p><p>
---

Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">Open Ai Tx</a> | Last indexed: 2025-08-09

---</p>
        </div>
        
        <div class="original-link">
            <strong>Original README:</strong> <a href="https://raw.githubusercontent.com/donnemartin/system-design-primer/master/README.md" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Translated by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" rel="noopener noreferrer">OpenAiTx</a> | 
        Last updated: 2025-08-09 
    </div>
    
</body>
</html>